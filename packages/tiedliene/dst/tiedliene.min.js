var F=(x)=>{if(x&&typeof x==="object"){let q=Array.isArray(x)?[]:{};for(let m in x)q[m]=F(x[m]);return q}return x};var G=(x,q,m)=>{let C=x;for(let B=0;B<q.length-1;B++){let E=q[B];if(!(E in C))C[E]={};C=C[E]}C[q[q.length-1]]=F(m)},J=(x,q)=>{let m=x;for(let C=0;C<q.length-1;C++)if(m=m[q[C]],!m)return;if(Array.isArray(m))m.splice(parseInt(q[q.length-1]),1);else delete m[q[q.length-1]]},H=(x,q,m=[])=>{let C=[];for(let B in x){let E=[...m,B];if(!(B in q))C.unshift({type:"delete",path:E,old:F(x[B])});else if(typeof x[B]==="object"&&typeof q[B]==="object")C.unshift(...H(x[B],q[B],E));else if(x[B]!==q[B])C.unshift({type:"set",path:E,old:F(x[B]),new:F(q[B])})}for(let B in q)if(!(B in x))C.unshift({type:"set",path:[...m,B],new:F(q[B])});return C},K=(x,q)=>{for(let m of q)if(m.type==="set")G(x,m.path,m.new);else if(m.type==="delete")J(x,m.path);return x},L=(x,q)=>{for(let m of q)if(m.type==="set")if(m.old===void 0)J(x,m.path);else G(x,m.path,m.old);else if(m.type==="delete")G(x,m.path,m.old);return x};var W=function(x,q){x=F(x),q=Object.assign({maximumHistory:50},q);let m=[],C=[];return{get:()=>{return F(x)},set:(B)=>{B=F(B);let E=H(x,B);if(E.length>0){if(m.push(E),q.maximumHistory&&m.length>q.maximumHistory)for(let I=m.length-q.maximumHistory;I>0;I--)m.shift();C.splice(0)}return x=B,F(x)},undo:()=>{if(m.length>0){let B=m.pop();if(B){if(C.push(B),q.maximumHistory&&C.length>q.maximumHistory)for(let E=C.length-q.maximumHistory;E>0;E--)C.shift();x=L(x,B)}}return F(x)},redo:()=>{if(C.length>0){let B=C.pop();if(B){if(m.push(B),q.maximumHistory&&m.length>q.maximumHistory)for(let E=m.length-q.maximumHistory;E>0;E--)m.shift();x=K(x,B)}}return F(x)}}};export{L as revertDiff,W as manageState,H as determineDiff,F as cloneRecursive,K as applyDiff};

//# debugId=947C734B06E38C5F64756E2164756E21
