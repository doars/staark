var F=(m)=>{if(typeof m==="object"){let q=Array.isArray(m)?[]:{};for(let x in m)q[x]=F(m[x]);return q}return m};var G=(m,q,x)=>{let C=m;for(let B=0;B<q.length-1;B++){let E=q[B];if(!(E in C))C[E]={};C=C[E]}C[q[q.length-1]]=F(x)},J=(m,q)=>{let x=m;for(let C=0;C<q.length-1;C++)if(x=x[q[C]],!x)return;if(Array.isArray(x))x.splice(parseInt(q[q.length-1]),1);else delete x[q[q.length-1]]},H=(m,q,x=[])=>{let C=[];for(let B in m){let E=[...x,B];if(!(B in q))C.unshift({type:"delete",path:E,old:F(m[B])});else if(typeof m[B]==="object"&&typeof q[B]==="object")C.unshift(...H(m[B],q[B],E));else if(m[B]!==q[B])C.unshift({type:"set",path:E,old:F(m[B]),new:F(q[B])})}for(let B in q)if(!(B in m))C.unshift({type:"set",path:[...x,B],new:F(q[B])});return C},K=(m,q)=>{for(let x of q)if(x.type==="set")G(m,x.path,x.new);else if(x.type==="delete")J(m,x.path);return m},L=(m,q)=>{for(let x of q)if(x.type==="set")if(x.old===void 0)J(m,x.path);else G(m,x.path,x.old);else if(x.type==="delete")G(m,x.path,x.old);return m};var W=function(m,q){m=F(m),q=Object.assign({maximumHistory:50},q);let x=[],C=[];return{get:()=>{return F(m)},set:(B)=>{B=F(B);let E=H(m,B);if(E.length>0){if(x.push(E),q.maximumHistory&&x.length>q.maximumHistory)for(let I=x.length-q.maximumHistory;I>0;I--)x.shift();C.splice(0)}return m=B,F(m)},undo:()=>{if(x.length>0){let B=x.pop();if(B){if(C.push(B),q.maximumHistory&&C.length>q.maximumHistory)for(let E=C.length-q.maximumHistory;E>0;E--)C.shift();m=L(m,B)}}return F(m)},redo:()=>{if(C.length>0){let B=C.pop();if(B){if(x.push(B),q.maximumHistory&&x.length>q.maximumHistory)for(let E=x.length-q.maximumHistory;E>0;E--)x.shift();m=K(m,B)}}return F(m)}}};export{L as revertDiff,W as manageState,H as determineDiff,F as cloneRecursive,K as applyDiff};

//# debugId=4F6A1C9C7CC1010F64756E2164756E21
