{
  "version": 3,
  "sources": ["../src/utilities/clone.js", "../src/library/diff.js", "../src/library/state.js"],
  "sourcesContent": ["/**\n * Creates a deep clone of a javascript value.\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n", "import { cloneRecursive } from '../utilities/clone.js'\n\n/**\n * @typedef {Object} Change\n * @property {'delete' | 'set'} type\n * @property {string[]} path\n * @property {*} [new]\n * @property {*} [old]\n */\n\n/**\n * Function to set a value at a given path.\n * @param {Record<string, any>} record\n * @param {string[]} path\n * @param {*} value\n */\nconst setValueAtPath = (\n  record,\n  path,\n  value,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = cloneRecursive(value)\n}\n\n/**\n * Function to delete a value at a given path.\n * @param {Record<string, any>} record\n * @param {string[]} path\n */\nconst deleteValueAtPath = (\n  record,\n  path,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\n/**\n * Determine the differences between two objects.\n * @param {Record<string, any>} before\n * @param {Record<string, any>} after\n * @param {string[]} [path=[]]\n * @returns {Change[]}\n */\nexport const determineDiff = (\n  before,\n  after,\n  path = [],\n) => {\n  const changes = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath)\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\n/**\n * Apply a diff to a state object.\n * @param {Record<string, any>} state\n * @param {Change[]} diff\n * @returns {Record<string, any>}\n */\nexport const applyDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\n/**\n * Revert a diff on a state object.\n * @param {Record<string, any>} state\n * @param {Change[]} diff\n * @returns {Record<string, any>}\n */\nexport const revertDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n", "import { cloneRecursive } from '../utilities/clone.js'\n\nimport {\n  determineDiff,\n  applyDiff,\n  revertDiff,\n} from './diff.js'\n\n/**\n * @typedef {import('./diff.js').Change} Change\n */\n\n/**\n * @typedef {Object} ManageOptions\n * @property {number} [maximumHistory]\n */\n\n/**\n * @param {Record<string, any>} state\n * @param {ManageOptions} [options]\n */\nexport const manageState = function (\n  state,\n  options,\n) {\n  state = cloneRecursive(state)\n  options = Object.assign({\n    maximumHistory: 50,\n  }, options)\n\n  /** @type {Change[][]} */\n  const undoStack = []\n  /** @type {Change[][]} */\n  const redoStack = []\n\n  return {\n    /**\n     * @returns {Record<string, any>}\n     */\n    get: () => {\n      return cloneRecursive(state)\n    },\n\n    /**\n     * @param {Record<string, any>} newState\n     * @returns {Record<string, any>}\n     */\n    set: (\n      newState,\n    ) => {\n      newState = cloneRecursive(newState)\n\n      const diffs = determineDiff(state, newState)\n      if (diffs.length > 0) {\n        undoStack.push(diffs)\n\n        // Cap stack size.\n        if (\n          options.maximumHistory\n          && undoStack.length > options.maximumHistory\n        ) {\n          for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n            undoStack.shift()\n          }\n        }\n\n        // Clear the redo stack when a new state is set.\n        redoStack.splice(0)\n      }\n\n      state = newState\n      return cloneRecursive(state)\n    },\n\n    /**\n     * @returns {Record<string, any>}\n     */\n    undo: () => {\n      if (undoStack.length > 0) {\n        const lastDiffs = undoStack.pop()\n        if (lastDiffs) {\n          redoStack.push(lastDiffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && redoStack.length > options.maximumHistory\n          ) {\n            for (let i = redoStack.length - options.maximumHistory; i > 0; i--) {\n              redoStack.shift()\n            }\n          }\n\n          state = revertDiff(state, lastDiffs)\n        }\n      }\n\n      return cloneRecursive(state)\n    },\n\n    /**\n     * @returns {Record<string, any>}\n     */\n    redo: () => {\n      if (redoStack.length > 0) {\n        const diffs = redoStack.pop()\n        if (diffs) {\n          undoStack.push(diffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && undoStack.length > options.maximumHistory\n          ) {\n            for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n              undoStack.shift()\n            }\n          }\n\n          state = applyDiff(state, diffs)\n        }\n      }\n\n      return cloneRecursive(state)\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
