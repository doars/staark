{
  "version": 3,
  "sources": ["../../../.scripts/iife.ts", "../src/library/diff.ts", "../src/library/state.ts", "../src/index.iife.ts"],
  "sourcesContent": ["export const iife = function (\n  path: Array<string>,\n  data: any\n) {\n  let subject: Record<string, any> = window\n  for (let i = 0; i < path.length - 1; i++) {\n    if (\n      typeof (subject[path[i]]) !== 'object'\n      || !Array.isArray(subject[path[i]])\n    ) {\n      subject[path[i]] = {}\n    }\n    subject = subject[path[i]]\n  }\n  subject[path[path.length - 1]] = data\n}\n", "export interface Change {\n  type: 'delete' | 'set',\n  path: string[],\n  new?: any,\n  old?: any,\n}\n\n// Function to set a value at a given path.\nconst setValueAtPath = (\n  record: Record<string, any>,\n  path: string[],\n  value: any,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = structuredClone(value)\n}\n\n// Function to delete a value at a given path.\nconst deleteValueAtPath = (\n  record: Record<string, any>,\n  path: string[],\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\nexport const determineDiff = (\n  before: Record<string, any>,\n  after: Record<string, any>,\n  path: string[] = [],\n): Change[] => {\n  const changes: Change[] = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: structuredClone(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath)\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: structuredClone(before[key]),\n        new: structuredClone(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: structuredClone(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\nexport const applyDiff = (\n  state: Record<string, any>,\n  diff: Change[],\n): Record<string, any> => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\nexport const revertDiff = (\n  state: Record<string, any>,\n  diff: Change[],\n): Record<string, any> => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n", "import {\n  Change,\n  determineDiff,\n  applyDiff,\n  revertDiff,\n} from './diff.js'\n\ninterface ManageOptions {\n  maximumHistory?: number,\n}\n\nexport const manageState = function (\n  state: Record<string, any>,\n  options?: ManageOptions,\n) {\n  state = structuredClone(state)\n  options = Object.assign({\n    maximumHistory: 50,\n  }, options)\n\n  const undoStack: Change[][] = []\n  const redoStack: Change[][] = []\n\n  return {\n    get: (\n    ) => {\n      return structuredClone(state)\n    },\n\n    set: (\n      newState: Record<string, any>,\n    ) => {\n      newState = structuredClone(newState)\n\n      const diffs = determineDiff(state, newState)\n      if (diffs.length > 0) {\n        undoStack.push(diffs)\n\n        // Cap stack size.\n        if (\n          options.maximumHistory\n          && undoStack.length > options.maximumHistory\n        ) {\n          for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n            undoStack.shift()\n          }\n        }\n\n        // Clear the redo stack when a new state is set.\n        redoStack.splice(0)\n      }\n\n      state = newState\n      return structuredClone(state)\n    },\n\n    undo: (\n    ) => {\n      if (undoStack.length > 0) {\n        const lastDiffs = undoStack.pop()\n        if (lastDiffs) {\n          redoStack.push(lastDiffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && redoStack.length > options.maximumHistory\n          ) {\n            for (let i = redoStack.length - options.maximumHistory; i > 0; i--) {\n              redoStack.shift()\n            }\n          }\n\n          state = revertDiff(state, lastDiffs)\n        }\n      }\n\n      return structuredClone(state)\n    },\n\n    redo: (\n    ) => {\n      if (redoStack.length > 0) {\n        const diffs = redoStack.pop()\n        if (diffs) {\n          undoStack.push(diffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && undoStack.length > options.maximumHistory\n          ) {\n            for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n              undoStack.shift()\n            }\n          }\n\n          state = applyDiff(state, diffs)\n        }\n      }\n\n      return structuredClone(state)\n    },\n  }\n}\n", "import { iife } from '../../../.scripts/iife.js'\n\nimport {\n  determineDiff,\n  applyDiff,\n  revertDiff,\n} from './library/diff.js'\nimport {\n  manageState,\n} from './library/state.js'\n\niife([\n  'tiedliene',\n], {\n  determineDiff,\n  applyDiff,\n  revertDiff,\n\n  manageState,\n})\n"],
  "mappings": "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",
  "names": []
}
