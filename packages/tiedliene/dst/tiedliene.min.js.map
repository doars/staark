{
  "version": 3,
  "sources": ["../src/utilities/clone.js", "../src/library/diff.js", "../src/library/state.js"],
  "sourcesContent": [
    "/**\n * Creates a deep clone of a javascript value.\n *\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (\n    value &&\n    typeof (value) === 'object'\n  ) {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n",
    "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\n\n/**\n * @typedef {Object} Change A change to a state object.\n * @property {'delete' | 'set'} type The type of change.\n * @property {string[]} path The path to the value that changed.\n * @property {*} [new] The new value.\n * @property {*} [old] The old value.\n */\n\n/**\n * Function to set a value at a given path.\n *\n * @param {Record<string, any>} record The record to update.\n * @param {string[]} path The path to the value to update.\n * @param {*} value The new value.\n */\nconst setValueAtPath = (\n  record,\n  path,\n  value,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = cloneRecursive(value)\n}\n\n/**\n * Function to delete a value at a given path.\n *\n * @param {Record<string, any>} record The record to update.\n * @param {string[]} path The path to the value to delete.\n */\nconst deleteValueAtPath = (\n  record,\n  path,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\n/**\n * Determine the differences between two objects.\n *\n * @param {Record<string, any>} before The object before the change.\n * @param {Record<string, any>} after The object after the change.\n * @param {string[]} [path=[]] The path to the current object.\n * @returns {Change[]} The changes between the two objects.\n */\nexport const determineDiff = (\n  before,\n  after,\n  path = [],\n) => {\n  const changes = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath),\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\n/**\n * Apply a diff to a state object.\n *\n * @param {Record<string, any>} state The state object to update.\n * @param {Change[]} diff The diff to apply.\n * @returns {Record<string, any>} The updated state object.\n */\nexport const applyDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\n/**\n * Revert a diff on a state object.\n *\n * @param {Record<string, any>} state The state object to revert.\n * @param {Change[]} diff The diff to revert.\n * @returns {Record<string, any>} The updated state object.\n */\nexport const revertDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n",
    "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\nimport {\n  determineDiff,\n  applyDiff,\n  revertDiff,\n} from './diff.js'\n\n/**\n * @typedef {import('./diff.js').Change} Change\n */\n\n/**\n * @typedef {Object} ManageOptions Options for managing state.\n * @property {number} [maximumHistory] The maximum number of changes to keep in the undo and redo stacks.\n */\n\n/**\n * Manages state and provides undo and redo functionality.\n *\n * @param {Record<string, any>} state The initial state.\n * @param {ManageOptions} [options] Options for managing state.\n */\nexport const manageState = function (\n  state,\n  options,\n) {\n  state = cloneRecursive(state)\n  options = Object.assign({\n    maximumHistory: 50,\n  }, options)\n\n  /** @type {Change[][]} */\n  const undoStack = []\n  /** @type {Change[][]} */\n  const redoStack = []\n\n  return {\n    /**\n     * Returns the current state.\n     *\n     * @returns {Record<string, any>} The current state.\n     */\n    get: (\n    ) => {\n      return cloneRecursive(state)\n    },\n\n    /**\n     * Sets the state and returns the new state.\n     *\n     * @param {Record<string, any>} newState The new state.\n     * @returns {Record<string, any>} The new state.\n     */\n    set: (\n      newState,\n    ) => {\n      newState = cloneRecursive(newState)\n\n      const diffs = determineDiff(state, newState)\n      if (diffs.length > 0) {\n        undoStack.push(diffs)\n\n        // Cap stack size.\n        if (\n          options.maximumHistory\n          && undoStack.length > options.maximumHistory\n        ) {\n          for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n            undoStack.shift()\n          }\n        }\n\n        // Clear the redo stack when a new state is set.\n        redoStack.splice(0)\n      }\n\n      state = newState\n      return cloneRecursive(state)\n    },\n\n    /**\n     * Undoes the last change and returns the new state.\n     *\n     * @returns {Record<string, any>} The new state.\n     */\n    undo: (\n    ) => {\n      if (undoStack.length > 0) {\n        const lastDiffs = undoStack.pop()\n        if (lastDiffs) {\n          redoStack.push(lastDiffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && redoStack.length > options.maximumHistory\n          ) {\n            for (let i = redoStack.length - options.maximumHistory; i > 0; i--) {\n              redoStack.shift()\n            }\n          }\n\n          state = revertDiff(state, lastDiffs)\n        }\n      }\n\n      return cloneRecursive(state)\n    },\n\n    /**\n     * Redoes the last change and returns the new state.\n     *\n     * @returns {Record<string, any>} The new state.\n     */\n    redo: (\n    ) => {\n      if (redoStack.length > 0) {\n        const diffs = redoStack.pop()\n        if (diffs) {\n          undoStack.push(diffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && undoStack.length > options.maximumHistory\n          ) {\n            for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n              undoStack.shift()\n            }\n          }\n\n          state = applyDiff(state, diffs)\n        }\n      }\n\n      return cloneRecursive(state)\n    },\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "947C734B06E38C5F64756E2164756E21",
  "names": []
}