var i=n=>{if(typeof n=="object")if(Array.isArray(n)){let t=[];for(let e=0;e<n.length;e++)t.push(i(n[e]));n=t}else{let t={};for(let e in n)t[e]=i(n[e]);n=t}return n};var c=(n,t,e)=>{let o=n;for(let r=0;r<t.length-1;r++){let s=t[r];s in o||(o[s]={}),o=o[s]}o[t[t.length-1]]=i(e)},y=(n,t)=>{let e=n;for(let o=0;o<t.length-1;o++)if(e=e[t[o]],!e)return;Array.isArray(e)?e.splice(parseInt(t[t.length-1]),1):delete e[t[t.length-1]]},f=(n,t,e=[])=>{let o=[];for(let r in n){let s=[...e,r];r in t?typeof n[r]=="object"&&typeof t[r]=="object"?o.unshift(...f(n[r],t[r],s)):n[r]!==t[r]&&o.unshift({type:"set",path:s,old:i(n[r]),new:i(t[r])}):o.unshift({type:"delete",path:s,old:i(n[r])})}for(let r in t)r in n||o.unshift({type:"set",path:[...e,r],new:i(t[r])});return o},p=(n,t)=>{for(let e of t)e.type==="set"?c(n,e.path,e.new):e.type==="delete"&&y(n,e.path);return n},d=(n,t)=>{for(let e of t)e.type==="set"?e.old===void 0?y(n,e.path):c(n,e.path,e.old):e.type==="delete"&&c(n,e.path,e.old);return n};export{p as applyDiff,f as determineDiff,d as revertDiff};
//# sourceMappingURL=tiedliene.base.min.js.map
