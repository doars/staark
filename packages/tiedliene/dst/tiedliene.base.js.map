{
  "version": 3,
  "sources": ["../src/utilities/clone.js", "../src/library/diff.js"],
  "sourcesContent": [
    "/**\n * Creates a deep clone of a javascript value.\n *\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (\n    value &&\n    typeof (value) === 'object'\n  ) {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n",
    "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\n\n/**\n * @typedef {Object} Change A change to a state object.\n * @property {'delete' | 'set'} type The type of change.\n * @property {string[]} path The path to the value that changed.\n * @property {*} [new] The new value.\n * @property {*} [old] The old value.\n */\n\n/**\n * Function to set a value at a given path.\n *\n * @param {Record<string, any>} record The record to update.\n * @param {string[]} path The path to the value to update.\n * @param {*} value The new value.\n */\nconst setValueAtPath = (\n  record,\n  path,\n  value,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = cloneRecursive(value)\n}\n\n/**\n * Function to delete a value at a given path.\n *\n * @param {Record<string, any>} record The record to update.\n * @param {string[]} path The path to the value to delete.\n */\nconst deleteValueAtPath = (\n  record,\n  path,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\n/**\n * Determine the differences between two objects.\n *\n * @param {Record<string, any>} before The object before the change.\n * @param {Record<string, any>} after The object after the change.\n * @param {string[]} [path=[]] The path to the current object.\n * @returns {Change[]} The changes between the two objects.\n */\nexport const determineDiff = (\n  before,\n  after,\n  path = [],\n) => {\n  const changes = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath),\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\n/**\n * Apply a diff to a state object.\n *\n * @param {Record<string, any>} state The state object to update.\n * @param {Change[]} diff The diff to apply.\n * @returns {Record<string, any>} The updated state object.\n */\nexport const applyDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\n/**\n * Revert a diff on a state object.\n *\n * @param {Record<string, any>} state The state object to revert.\n * @param {Change[]} diff The diff to revert.\n * @returns {Record<string, any>} The updated state object.\n */\nexport const revertDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n"
  ],
  "mappings": ";AAMO,IAAM,iBAAiB,CAC5B,UACG;AAAA,EACH,IACE,SACA,OAAQ,UAAW,UACnB;AAAA,IACA,MAAM,QACJ,MAAM,QAAQ,KAAK,IACf,CAAC,IACD,CAAC;AAAA,IAEP,WAAW,OAAO,OAAO;AAAA,MACvB,MAAM,OAAO,eAAe,MAAM,IAAI;AAAA,IACxC;AAAA,IACA,OAAO;AAAA,EACT;AAAA,EACA,OAAO;AAAA;;;ACJT,IAAM,iBAAiB,CACrB,QACA,MACA,UACG;AAAA,EACH,IAAI,UAAU;AAAA,EACd,SAAS,IAAI,EAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AAAA,IACxC,MAAM,MAAM,KAAK;AAAA,IACjB,IAAI,EAAE,OAAO,UAAU;AAAA,MACrB,QAAQ,OAAO,CAAC;AAAA,IAClB;AAAA,IACA,UAAU,QAAQ;AAAA,EACpB;AAAA,EACA,QAAQ,KAAK,KAAK,SAAS,MAAM,eAAe,KAAK;AAAA;AASvD,IAAM,oBAAoB,CACxB,QACA,SACG;AAAA,EACH,IAAI,UAAU;AAAA,EACd,SAAS,IAAI,EAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AAAA,IACxC,UAAU,QAAQ,KAAK;AAAA,IACvB,IAAI,CAAC,SAAS;AAAA,MAEZ;AAAA,IACF;AAAA,EACF;AAAA,EACA,IAAI,MAAM,QAAQ,OAAO,GAAG;AAAA,IAC1B,QAAQ,OAAO,SAAS,KAAK,KAAK,SAAS,EAAE,GAAG,CAAC;AAAA,EACnD,EAAO;AAAA,IACL,OAAO,QAAQ,KAAK,KAAK,SAAS;AAAA;AAAA;AAY/B,IAAM,gBAAgB,CAC3B,QACA,OACA,OAAO,CAAC,MACL;AAAA,EACH,MAAM,UAAU,CAAC;AAAA,EAGjB,WAAW,OAAO,QAAQ;AAAA,IACxB,MAAM,cAAc,CAAC,GAAG,MAAM,GAAG;AAAA,IAEjC,IAAI,EAAE,OAAO,QAAQ;AAAA,MACnB,QAAQ,QAAQ;AAAA,QACd,MAAM;AAAA,QACN,MAAM;AAAA,QACN,KAAK,eAAe,OAAO,IAAI;AAAA,MACjC,CAAC;AAAA,IACH,EAAO,SACL,OAAO,OAAO,SAAS,YACpB,OAAO,MAAM,SAAS,UACzB;AAAA,MAEA,QAAQ,QACN,GAAG,cAAc,OAAO,MAAM,MAAM,MAAM,WAAW,CACvD;AAAA,IACF,EAAO,SAAI,OAAO,SAAS,MAAM,MAAM;AAAA,MAErC,QAAQ,QAAQ;AAAA,QACd,MAAM;AAAA,QACN,MAAM;AAAA,QACN,KAAK,eAAe,OAAO,IAAI;AAAA,QAC/B,KAAK,eAAe,MAAM,IAAI;AAAA,MAChC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAGA,WAAW,OAAO,OAAO;AAAA,IACvB,IAAI,EAAE,OAAO,SAAS;AAAA,MACpB,QAAQ,QAAQ;AAAA,QACd,MAAM;AAAA,QACN,MAAM,CAAC,GAAG,MAAM,GAAG;AAAA,QACnB,KAAK,eAAe,MAAM,IAAI;AAAA,MAChC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,OAAO;AAAA;AAUF,IAAM,YAAY,CACvB,OACA,SACG;AAAA,EACH,WAAW,UAAU,MAAM;AAAA,IACzB,IAAI,OAAO,SAAS,OAAO;AAAA,MACzB,eAAe,OAAO,OAAO,MAAM,OAAO,GAAG;AAAA,IAC/C,EAAO,SAAI,OAAO,SAAS,UAAU;AAAA,MACnC,kBAAkB,OAAO,OAAO,IAAI;AAAA,IACtC;AAAA,EACF;AAAA,EACA,OAAO;AAAA;AAUF,IAAM,aAAa,CACxB,OACA,SACG;AAAA,EACH,WAAW,UAAU,MAAM;AAAA,IACzB,IAAI,OAAO,SAAS,OAAO;AAAA,MACzB,IAAI,OAAO,QAAQ,WAAW;AAAA,QAC5B,kBAAkB,OAAO,OAAO,IAAI;AAAA,MACtC,EAAO;AAAA,QACL,eAAe,OAAO,OAAO,MAAM,OAAO,GAAG;AAAA;AAAA,IAEjD,EAAO,SAAI,OAAO,SAAS,UAAU;AAAA,MACnC,eAAe,OAAO,OAAO,MAAM,OAAO,GAAG;AAAA,IAC/C;AAAA,EACF;AAAA,EACA,OAAO;AAAA;",
  "debugId": "118E922A329D338564756E2164756E21",
  "names": []
}