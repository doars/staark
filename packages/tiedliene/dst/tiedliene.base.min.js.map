{
  "version": 3,
  "sources": ["../src/utilities/clone.js", "../src/library/diff.js"],
  "sourcesContent": ["/**\n * Creates a deep clone of a javascript value.\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n", "import { cloneRecursive } from '../utilities/clone.js'\n\n/**\n * @typedef {Object} Change\n * @property {'delete' | 'set'} type\n * @property {string[]} path\n * @property {*} [new]\n * @property {*} [old]\n */\n\n/**\n * Function to set a value at a given path.\n * @param {Record<string, any>} record\n * @param {string[]} path\n * @param {*} value\n */\nconst setValueAtPath = (\n  record,\n  path,\n  value,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = cloneRecursive(value)\n}\n\n/**\n * Function to delete a value at a given path.\n * @param {Record<string, any>} record\n * @param {string[]} path\n */\nconst deleteValueAtPath = (\n  record,\n  path,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\n/**\n * Determine the differences between two objects.\n * @param {Record<string, any>} before\n * @param {Record<string, any>} after\n * @param {string[]} [path=[]]\n * @returns {Change[]}\n */\nexport const determineDiff = (\n  before,\n  after,\n  path = [],\n) => {\n  const changes = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath)\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\n/**\n * Apply a diff to a state object.\n * @param {Record<string, any>} state\n * @param {Change[]} diff\n * @returns {Record<string, any>}\n */\nexport const applyDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\n/**\n * Revert a diff on a state object.\n * @param {Record<string, any>} state\n * @param {Change[]} diff\n * @returns {Record<string, any>}\n */\nexport const revertDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n"],
  "mappings": "AAKO,IAAMA,EACXC,GACG,CACH,GAAI,OAAQA,GAAW,SAAU,CAC/B,IAAMC,EACJ,MAAM,QAAQD,CAAK,EACf,CAAC,EACD,CAAC,EAEP,QAAWE,KAAOF,EAChBC,EAAMC,CAAG,EAAIH,EAAeC,EAAME,CAAG,CAAC,EAExC,OAAOD,CACT,CACA,OAAOD,CACT,ECJA,IAAMG,EAAiB,CACrBC,EACAC,EACAC,IACG,CACH,IAAIC,EAAUH,EACd,QAASI,EAAI,EAAGA,EAAIH,EAAK,OAAS,EAAGG,IAAK,CACxC,IAAMC,EAAMJ,EAAKG,CAAC,EACZC,KAAOF,IACXA,EAAQE,CAAG,EAAI,CAAC,GAElBF,EAAUA,EAAQE,CAAG,CACvB,CACAF,EAAQF,EAAKA,EAAK,OAAS,CAAC,CAAC,EAAIK,EAAeJ,CAAK,CACvD,EAOMK,EAAoB,CACxBP,EACAC,IACG,CACH,IAAIE,EAAUH,EACd,QAAS,EAAI,EAAG,EAAIC,EAAK,OAAS,EAAG,IAEnC,GADAE,EAAUA,EAAQF,EAAK,CAAC,CAAC,EACrB,CAACE,EAEH,OAGA,MAAM,QAAQA,CAAO,EACvBA,EAAQ,OAAO,SAASF,EAAKA,EAAK,OAAS,CAAC,CAAC,EAAG,CAAC,EAEjD,OAAOE,EAAQF,EAAKA,EAAK,OAAS,CAAC,CAAC,CAExC,EASaO,EAAgB,CAC3BC,EACAC,EACAT,EAAO,CAAC,IACL,CACH,IAAMU,EAAU,CAAC,EAGjB,QAAWN,KAAOI,EAAQ,CACxB,IAAMG,EAAc,CAAC,GAAGX,EAAMI,CAAG,EAE3BA,KAAOK,EAOX,OAAOD,EAAOJ,CAAG,GAAM,UACpB,OAAOK,EAAML,CAAG,GAAM,SAGzBM,EAAQ,QACN,GAAGH,EAAcC,EAAOJ,CAAG,EAAGK,EAAML,CAAG,EAAGO,CAAW,CACvD,EACSH,EAAOJ,CAAG,IAAMK,EAAML,CAAG,GAElCM,EAAQ,QAAQ,CACd,KAAM,MACN,KAAMC,EACN,IAAKN,EAAeG,EAAOJ,CAAG,CAAC,EAC/B,IAAKC,EAAeI,EAAML,CAAG,CAAC,CAChC,CAAC,EApBDM,EAAQ,QAAQ,CACd,KAAM,SACN,KAAMC,EACN,IAAKN,EAAeG,EAAOJ,CAAG,CAAC,CACjC,CAAC,CAkBL,CAGA,QAAWA,KAAOK,EACVL,KAAOI,GACXE,EAAQ,QAAQ,CACd,KAAM,MACN,KAAM,CAAC,GAAGV,EAAMI,CAAG,EACnB,IAAKC,EAAeI,EAAML,CAAG,CAAC,CAChC,CAAC,EAIL,OAAOM,CACT,EAQaE,EAAY,CACvBC,EACAC,IACG,CACH,QAAWC,KAAUD,EACfC,EAAO,OAAS,MAClBjB,EAAee,EAAOE,EAAO,KAAMA,EAAO,GAAG,EACpCA,EAAO,OAAS,UACzBT,EAAkBO,EAAOE,EAAO,IAAI,EAGxC,OAAOF,CACT,EAQaG,EAAa,CACxBH,EACAC,IACG,CACH,QAAWC,KAAUD,EACfC,EAAO,OAAS,MACdA,EAAO,MAAQ,OACjBT,EAAkBO,EAAOE,EAAO,IAAI,EAEpCjB,EAAee,EAAOE,EAAO,KAAMA,EAAO,GAAG,EAEtCA,EAAO,OAAS,UACzBjB,EAAee,EAAOE,EAAO,KAAMA,EAAO,GAAG,EAGjD,OAAOF,CACT",
  "names": ["cloneRecursive", "value", "clone", "key", "setValueAtPath", "record", "path", "value", "current", "i", "key", "cloneRecursive", "deleteValueAtPath", "determineDiff", "before", "after", "changes", "currentPath", "applyDiff", "state", "diff", "change", "revertDiff"]
}
