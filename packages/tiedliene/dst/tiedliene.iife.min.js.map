{
  "version": 3,
  "sources": ["../../../.scripts/iife.ts", "../node_modules/@doars/staark-common/src/clone.ts", "../src/library/diff.ts", "../src/library/state.ts", "../src/index.iife.ts"],
  "sourcesContent": ["export const iife = function (\n  path: Array<string>,\n  data: any\n) {\n  let subject: Record<string, any> = window\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof (subject[path[i]]) !== 'object' || !Array.isArray(subject[path[i]])) {\n      subject[path[i]] = {}\n    }\n    subject = subject[path[i]]\n  }\n  subject[path[path.length - 1]] = data\n}\n", "import {\n  GenericObjectAny,\n} from './generics.js'\n\nexport const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: GenericObjectAny = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "import { cloneRecursive } from '@doars/staark-common/src/clone.js'\n\nexport interface Change {\n  type: 'delete' | 'set',\n  path: string[],\n  new?: any,\n  old?: any,\n}\n\n// Function to set a value at a given path.\nconst setValueAtPath = (\n  record: Record<string, any>,\n  path: string[],\n  value: any,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = cloneRecursive(value)\n}\n\n// Function to delete a value at a given path.\nconst deleteValueAtPath = (\n  record: Record<string, any>,\n  path: string[],\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\nexport const determineDiff = (\n  before: Record<string, any>,\n  after: Record<string, any>,\n  path: string[] = [],\n): Change[] => {\n  const changes: Change[] = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath)\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\nexport const applyDiff = (\n  state: Record<string, any>,\n  diff: Change[],\n): Record<string, any> => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\nexport const revertDiff = (\n  state: Record<string, any>,\n  diff: Change[],\n): Record<string, any> => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n", "import {\n  cloneRecursive,\n} from '@doars/staark-common/src/clone.js'\nimport {\n  Change,\n  determineDiff,\n  applyDiff,\n  revertDiff,\n} from './diff.js'\n\ninterface ManageOptions {\n  maximumHistory?: number,\n}\n\nexport const manageState = function (\n  state: Record<string, any>,\n  options?: ManageOptions,\n) {\n  state = cloneRecursive(state)\n  options = Object.assign({\n    maximumHistory: 50,\n  }, options)\n\n  const undoStack: Change[][] = []\n  const redoStack: Change[][] = []\n\n  return {\n    get: (\n    ) => {\n      return cloneRecursive(state)\n    },\n\n    set: (\n      newState: Record<string, any>,\n    ) => {\n      newState = cloneRecursive(newState)\n\n      const diffs = determineDiff(state, newState)\n      if (diffs.length > 0) {\n        undoStack.push(diffs)\n\n        // Cap stack size.\n        if (\n          options.maximumHistory\n          && undoStack.length > options.maximumHistory\n        ) {\n          for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n            undoStack.shift()\n          }\n        }\n\n        // Clear the redo stack when a new state is set.\n        redoStack.splice(0)\n      }\n\n      state = newState\n      return cloneRecursive(state)\n    },\n\n    undo: (\n    ) => {\n      if (undoStack.length > 0) {\n        const lastDiffs = undoStack.pop()\n        if (lastDiffs) {\n          redoStack.push(lastDiffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && redoStack.length > options.maximumHistory\n          ) {\n            for (let i = redoStack.length - options.maximumHistory; i > 0; i--) {\n              redoStack.shift()\n            }\n          }\n\n          state = revertDiff(state, lastDiffs)\n        }\n      }\n\n      return cloneRecursive(state)\n    },\n\n    redo: (\n    ) => {\n      if (redoStack.length > 0) {\n        const diffs = redoStack.pop()\n        if (diffs) {\n          undoStack.push(diffs)\n\n          // Cap stack size.\n          if (\n            options.maximumHistory\n            && undoStack.length > options.maximumHistory\n          ) {\n            for (let i = undoStack.length - options.maximumHistory; i > 0; i--) {\n              undoStack.shift()\n            }\n          }\n\n          state = applyDiff(state, diffs)\n        }\n      }\n\n      return cloneRecursive(state)\n    },\n  }\n}\n", "import { iife } from '../../../.scripts/iife.js'\n\nimport {\n  determineDiff,\n  applyDiff,\n  revertDiff,\n} from './library/diff.js'\nimport {\n  manageState,\n} from './library/state.js'\n\niife([\n  'tiedliene',\n], {\n  determineDiff,\n  applyDiff,\n  revertDiff,\n\n  manageState,\n})\n"],
  "mappings": "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",
  "names": ["iife", "path", "data", "subject", "i", "cloneRecursive", "value", "clone", "i", "key", "setValueAtPath", "record", "path", "value", "current", "key", "cloneRecursive", "deleteValueAtPath", "i", "determineDiff", "before", "after", "changes", "currentPath", "applyDiff", "state", "diff", "change", "revertDiff", "manageState", "state", "options", "cloneRecursive", "undoStack", "redoStack", "newState", "diffs", "determineDiff", "i", "lastDiffs", "revertDiff", "applyDiff", "iife", "determineDiff", "applyDiff", "revertDiff", "manageState"]
}
