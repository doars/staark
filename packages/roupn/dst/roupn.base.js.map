{
  "version": 3,
  "sources": ["../src/library/message-types.js", "../src/utilities/encoding-client.js", "../src/utilities/event.js", "../src/utilities/protocol.js", "../src/utilities/time.js", "../src/utilities/code.js", "../src/library/key-generator.js", "../src/library/payload-keys.js", "../src/library/client-connector.js"],
  "sourcesContent": ["export const CONNECTION_CONNECTED = 'CONNECTED'\nexport const CONNECTION_CONNECTING = 'CONNECTING'\nexport const CONNECTION_DISCONNECTED = 'DISCONNECTED'\nexport const CONNECTION_DISCONNECTING = 'DISCONNECTING'\nexport const CONNECTION_PENDING_VERIFICATION = 'PENDING_VERIFICATION'\n\nexport const ERROR = '_ER'\nexport const MESSAGE = '_MS'\n\nexport const KEY_EXCHANGE_ACCEPT = '_KA'\nexport const KEY_EXCHANGE_OFFER = '_KO'\n\nexport const ROOM_CLOSED = '_RC'\nexport const ROOM_JOINED = '_RJ'\nexport const ROOM_LEFT = '_RL'\nexport const ROOM_REMOVED = '_RR'\n\nexport const STATE_UPDATE = '_SU'\nexport const STATE_SYNCH = '_SS'\n\nexport const USER_JOINED = '_UJ'\nexport const USER_KICK = '_UK'\nexport const USER_LEFT = '_UL'\nexport const USER_VERIFIED = '_UV'\n", "export const base64ToBuffer = (\n  base64,\n) => {\n  const binary = atob(base64)\n  return Uint8Array.from(\n    binary,\n    character => character.charCodeAt(0),\n  ).buffer\n}\n\nexport const base64ToString = (\n  base64,\n) => {\n  const binary = atob(base64)\n  const bytes = Uint8Array.from(\n    binary,\n    character => character.charCodeAt(0)\n  )\n  return new TextDecoder().decode(bytes)\n}\n\nexport const stringToBase64 = (\n  string,\n) => {\n  const bytes = new TextEncoder().encode(string)\n\n  if (bytes.length < 65536) {\n    return btoa(\n      String.fromCharCode(...bytes),\n    )\n  }\n\n  let binary = ''\n  const chunkSize = 65536\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode(...chunk)\n  }\n  return btoa(binary)\n}\n\nexport const bufferToBase64 = (\n  buffer,\n) => {\n  const bytes = new Uint8Array(buffer)\n\n  if (bytes.length < 65536) {\n    return btoa(\n      String.fromCharCode(...bytes),\n    )\n  }\n\n  let binary = ''\n  const chunkSize = 65536\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode(...chunk)\n  }\n  return btoa(binary)\n}\n", "/**\n * Type definition for event listener options.\n * @typedef {Object} EventListenerOptions\n * @property {boolean} [once] - If true, the listener will be removed after the first call.\n */\n\n/**\n * Type definition for an event listener callback.\n * @typedef {(data: any) => void} EventListenerCallback\n */\n\n/**\n * Type definition for the event object returned by createEvent.\n * @typedef {Object} Event\n * @property {(callback: EventListenerCallback, options?: EventListenerOptions) => void} addListener\n * @property {(callback: EventListenerCallback) => void} removeListener\n * @property {(data: any) => void} dispatch\n */\n\n/**\n * Creates a custom event system with add, remove, and dispatch capabilities.\n *\n * @returns {Event} An event object with methods to manage listeners.\n */\nexport const createEvent = (\n) => {\n  /** @type {Map<EventListenerCallback, EventListenerOptions | undefined>} */\n  const listeners = new Map()\n\n  return {\n    /**\n     * Adds a listener callback for the event.\n     * @param {EventListenerCallback} callback - The listener function to add.\n     * @param {EventListenerOptions} [options] - Optional options for the listener (e.g., { once: true }).\n     */\n    addListener: (\n      callback,\n      options,\n    ) => {\n      if (!listeners.has(callback)) {\n        listeners.set(callback, options)\n      }\n    },\n\n    /**\n     * Removes a listener callback from the event.\n     * @param {EventListenerCallback} callback - The listener function to remove.\n     */\n    removeListener: (\n      callback,\n    ) => {\n      listeners.delete(callback)\n    },\n\n    /**\n     * Dispatches the event to all registered listeners.\n     * @param {any} data - Data to pass to each listener callback.\n     */\n    dispatch: (\n      data,\n    ) => {\n      for (const [listener, options] of listeners.entries()) {\n        listener(data)\n        if (\n          options\n          && options.once\n        ) {\n          listeners.delete(listener)\n        }\n      }\n    },\n  }\n}\n", "const DELIMITER = '|'\nconst INFIX = ':'\n\nexport const encode = (\n  parts,\n  stringToBase64,\n) => {\n  const segments = []\n  for (const key in parts) {\n    const value = parts[key]\n    if (\n      value !== null\n      && value !== undefined\n    ) {\n      segments.push(key + INFIX + stringToBase64(\n        String(value)),\n      )\n    }\n  }\n  return segments.join(DELIMITER)\n}\n\nexport const decode = (\n  message,\n  base64ToString,\n) => {\n  const parts = {}\n  const segments = message.split(DELIMITER)\n  for (const segment of segments) {\n    const index = segment.indexOf(INFIX)\n    if (index > 0) {\n      const key = segment.substring(0, index)\n      const value = segment.substring(index + 1)\n      parts[key] = base64ToString(value)\n    }\n  }\n  return parts\n}\n", "\n/**\n * Calculates time synchronization values based on provided server and sender times.\n *\n * @param {string} serverTime - The date and time the server broadcasted the data.\n * @param {string} senderTime - The date and time the sender send the data.\n * @returns {{\n *   delay: number,\n *   offset: number,\n *   adjusted: number,\n * }} An object containing the calculated delay, offset, and adjusted time.\n */\nexport const calculateTime = (\n  serverTime,\n  senderTime,\n) => {\n  const receiverTime = Date.now()\n\n  if (!serverTime) {\n    return {\n      delay: 0,\n      offset: 0,\n      adjusted: receiverTime,\n    }\n  }\n\n  if (!senderTime) {\n    const offset = serverTime - receiverTime\n    return {\n      delay: 0,\n      offset: offset,\n      adjusted: (\n        receiverTime\n        + offset\n      ),\n    }\n  }\n\n  const delay = receiverTime - senderTime\n  const offset = (\n    (serverTime - senderTime)\n    + (serverTime - receiverTime)\n  ) / 2\n  return {\n    delay: delay,\n    offset: offset,\n    adjusted: (\n      receiverTime\n      - delay\n      + offset\n    ),\n  }\n}\n", "/**\n * A string containing the allowed characters for generating identifiers.\n * @type {string}\n */\nexport const ALPHANUMERIC_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n/**\n * A string containing the allowed characters for generating codes. Excludes easily confused characters such as 'I', 'O', 'L', '1', and '0'.\n * @type {string}\n */\nexport const IDENTIFIABLE_CHARACTERS = 'ABCDEFGHKMNPQRSTUVWXYZ23456789'\n\n/**\n * Generates a random code string of the specified length.\n *\n * @param {number} [length=6] - The length of the code to generate.\n * @param {string} [characters='ABCDEFGHKMNPQRSTUVWXYZ23456789'] - The characters the code can consist of.\n * @returns {string} A randomly generated code.\n */\nexport const generateCode = (\n  length = 24,\n  characters = ALPHANUMERIC_CHARACTERS,\n) => {\n  let code = ''\n  for (let i = 0; i < length; i++) {\n    code += characters.charAt(\n      Math.floor(\n        Math.random()\n        * characters.length\n      ),\n    )\n  }\n  return code\n}\n", "export const DIFFIE_HELLMAN_ALGORITHM = 'ECDH'\nexport const DIFFIE_HELLMAN_CURVE = 'P-256'\nexport const DIFFIE_HELLMAN_EXPORT_FORMAT = 'raw'\nexport const HASH_ALGORITHM = 'SHA-256'\nexport const PUBLIC_KEY_EXPORT_FORMAT = 'spki'\nexport const SHARED_ENCRYPTION_ALGORITHM = 'AES-GCM'\nexport const SHARED_KEY_LENGTH = 256\nexport const USER_ENCRYPTION_ALGORITHM = 'RSA-OAEP'\nexport const USER_SIGNATURE_ALGORITHM = 'RSASSA-PKCS1-v1_5'\n\n// Values are inlined because of the string generated by the toString call will not have the same context. It is not written in a string in order to allow the build tool to minify and post-process the function's contents.\n\nexport const USER_KEY_GENERATOR = 'self.addEventListener(\\'message\\',' + ((\n) => {\n  Promise.all([\n    crypto.subtle.generateKey({\n      name: 'RSA-OAEP',\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: { name: 'SHA-256', },\n    }, true, ['encrypt', 'decrypt',]),\n    crypto.subtle.generateKey({\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: { name: 'SHA-256', },\n    }, true, ['sign', 'verify',]),\n    crypto.subtle.generateKey({\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    }, true, ['deriveKey',]),\n  ])\n    .then(([\n      myEncryptKeys,\n      mySignKeys,\n      myExchangeKeys,\n    ]) => {\n      Promise.all([\n        crypto.subtle.exportKey(\n          'spki',\n          myEncryptKeys.publicKey,\n        ),\n        crypto.subtle.exportKey(\n          'spki',\n          mySignKeys.publicKey,\n        ),\n      ])\n        .then(([\n          myPublicEncryptKey,\n          myPublicSignKey,\n        ]) => {\n          self.postMessage({\n            success: true,\n            myEncryptKeys,\n            mySignKeys,\n            myExchangeKeys,\n            myPublicEncryptKey,\n            myPublicSignKey,\n          })\n        })\n        .catch((error) => {\n          self.postMessage({\n            success: false,\n            error: error.message,\n          })\n        })\n    })\n    .catch((error) => {\n      self.postMessage({\n        success: false,\n        error: error.message,\n      })\n    })\n}).toString() + ')'\n\nexport const SHARED_KEY_GENERATOR = 'self.addEventListener(\\'message\\',' + ((\n) => {\n  crypto.subtle.generateKey({\n    length: 256,\n    name: 'AES-GCM',\n  }, true, ['encrypt', 'decrypt'])\n    .then(sharedKey => {\n      self.postMessage({\n        success: true,\n        sharedKey,\n      })\n    })\n    .catch(error => {\n      self.postMessage({\n        success: false,\n        error: error.message,\n      })\n    })\n}).toString() + ')'\n", "export const SERVER_PAYLOAD = 'S'\nexport const SERVER_TIME = 'T'\n\nexport const SHARED_ENCRYPTION_PAYLOAD = 'E'\nexport const SHARED_ENCRYPTION_IV = 'I'\n\nexport const USER = 'U'\nexport const USER_DIRECT_PAYLOAD = 'D'\nexport const USER_ENCRYPTION_IV = 'V'\nexport const USER_ENCRYPTION_KEY = 'K'\nexport const USER_ENCRYPTION_PAYLOAD = 'P'\nexport const USER_ENCRYPTION_SIGNATURE = 'G'\n", "import {\n  CONNECTION_CONNECTED,\n  CONNECTION_CONNECTING,\n  CONNECTION_DISCONNECTED,\n  CONNECTION_DISCONNECTING,\n  CONNECTION_PENDING_VERIFICATION,\n\n  KEY_EXCHANGE_ACCEPT,\n  KEY_EXCHANGE_OFFER,\n  ROOM_CLOSED,\n  ROOM_JOINED,\n  USER_JOINED,\n  USER_KICK,\n  USER_LEFT,\n  USER_VERIFIED,\n} from './message-types.js'\n\nimport {\n  base64ToBuffer,\n  base64ToString,\n  stringToBase64,\n  bufferToBase64,\n} from '../utilities/encoding-client.js'\nimport {\n  createEvent,\n} from '../utilities/event.js'\nimport {\n  decode,\n  encode,\n} from '../utilities/protocol.js'\nimport {\n  calculateTime,\n} from '../utilities/time.js'\nimport {\n  IDENTIFIABLE_CHARACTERS,\n} from '../utilities/code.js'\nimport {\n  DIFFIE_HELLMAN_ALGORITHM,\n  DIFFIE_HELLMAN_CURVE,\n  DIFFIE_HELLMAN_EXPORT_FORMAT,\n  HASH_ALGORITHM,\n  PUBLIC_KEY_EXPORT_FORMAT,\n  SHARED_ENCRYPTION_ALGORITHM,\n  SHARED_KEY_LENGTH,\n  USER_ENCRYPTION_ALGORITHM,\n  USER_SIGNATURE_ALGORITHM,\n\n  SHARED_KEY_GENERATOR,\n  USER_KEY_GENERATOR,\n} from './key-generator.js'\nimport {\n  SERVER_PAYLOAD,\n  SERVER_TIME,\n\n  SHARED_ENCRYPTION_IV,\n  SHARED_ENCRYPTION_PAYLOAD,\n\n  USER,\n  USER_DIRECT_PAYLOAD,\n\n  USER_ENCRYPTION_IV,\n  USER_ENCRYPTION_KEY,\n  USER_ENCRYPTION_PAYLOAD,\n  USER_ENCRYPTION_SIGNATURE,\n} from './payload-keys.js'\n\n/**\n * @typedef {import('../utilities/event.js').Event} Event\n */\n\n/**\n * @typedef {Object} ConnectorOptions\n *\n * @property {string} [createRoomEndpoint='/create-room'] - HTTP endpoint for creating a room.\n * @property {string} [joinRoomEndpoint='/join-room'] - WebSocket endpoint for joining a room.\n *\n * @property {string} [contentType='application/json'] - Content-Type for HTTP requests.\n * @property {Function} [deserializeMessage=JSON.parse] - Function to deserialize incoming messages.\n * @property {Function} [serializeMessage=JSON.stringify] - Function to serialize outgoing messages.\n *\n * @property {string} [httpUrl='http://localhost:3000'] - Base HTTP URL for API requests.\n * @property {string} [wsUrl='http://localhost:3000'] - Base WebSocket URL for room connections.\n *\n * @property {number} [messageBufferMaxCount=50] - The maximum number of messages to store in the buffer.\n * @property {number} [messageBufferMaxDuration=60000] - The maximum duration in milliseconds to store a message in the buffer.\n *\n * @property {string} verificationCodeLength\n */\n\n/**\n * @typedef {Object} ConnectorAPI\n *\n * @property {Event} onConnection - Event for connection state change notifications.\n * @property {Event} onError - Event for error handling.\n * @property {Event} onMessage - Event for receiving messages.\n * @property {Event} onRoomJoin - Event for room join notifications.\n * @property {Event} onRoomLeave - Event for room leave notifications.\n * @property {Event} onUserJoin - Event for user join notifications.\n * @property {Event} onUserLeave - Event for user leave notifications.\n * @property {Event} onUserVerified - Event for user verified notifications.\n *\n * @property {Function} createRoom - Creates a new room and joins it.\n * @property {Function} closeRoom - Closes the room for all. Only allowed by the creator.\n * @property {Function} joinRoom - Joins an existing room.\n * @property {Function} leaveRoom - Leaves the current room.\n * @property {Function} messageRoom - Sends a message to the current room.\n *\n * @property {Function} kickUser - Removes a player's connection. Only allowed by the creator.\n */\n\n/**\n * Creates a connector for managing room-based WebSocket communication.\n *\n * @param {ConnectorOptions} [options={}] - Configuration options for the connector.\n * @returns {ConnectorAPI} Connector API with event handlers and room management methods.\n */\nexport const createClientConnector = (\n  options = {},\n) => {\n  const {\n    contentType = 'application/json',\n    deserializeMessage = JSON.parse,\n    serializeMessage = JSON.stringify,\n\n    createRoomEndpoint = '/create-room',\n    joinRoomEndpoint = '/join-room',\n\n    httpUrl = 'http://localhost:3000',\n    wsUrl = 'http://localhost:3000',\n\n    messageBufferMaxCount = 50,\n    messageBufferMaxDuration = 60 * 1000,\n  } = options\n\n  let _creatorId,\n    _generatedKeys,\n    _keyGenerationPromise,\n    _myId,\n    _myEncryptKeys,\n    _myExchangeKeys,\n    _myPublicEncryptKey,\n    _myPublicSignKey,\n    _mySignKeys,\n    _sharedKey,\n    _sharedMessagesBuffer = [],\n    _socket,\n    _roomCode,\n    _userDerivedKeys = new Map(),\n    _userEncryptKeys = new Map(),\n    _userSignKeys = new Map(),\n    _userVerification = new Map(),\n    _connectionState = CONNECTION_DISCONNECTED\n  const _generateMyKeys = (\n  ) => {\n    if (\n      !_generatedKeys\n      && !_keyGenerationPromise\n    ) {\n      _keyGenerationPromise = new Promise((\n        resolve,\n        reject,\n      ) => {\n        const worker = new Worker(\n          URL.createObjectURL(\n            new Blob([USER_KEY_GENERATOR,], {\n              type: 'text/javascript',\n            }),\n          ),\n        )\n\n        worker.addEventListener('message', (\n          event,\n        ) => {\n          if (event.data.success) {\n            _myEncryptKeys = event.data.myEncryptKeys\n            _mySignKeys = event.data.mySignKeys\n            _myExchangeKeys = event.data.myExchangeKeys\n            _myPublicEncryptKey = event.data.myPublicEncryptKey\n            _myPublicSignKey = event.data.myPublicSignKey\n\n            _generatedKeys = true\n            _keyGenerationPromise = null\n            resolve()\n          } else {\n            const error = new Error(event.data.error)\n            onError.dispatch({\n              error,\n            })\n            reject(error)\n          }\n          worker.terminate()\n        })\n\n        worker.addEventListener('error', (\n          error,\n        ) => {\n          onError.dispatch({\n            error,\n          })\n          reject(error)\n          worker.terminate()\n        })\n\n        worker.postMessage({\n          type: 'USER_KEYS',\n        })\n      })\n    }\n    return _keyGenerationPromise\n  }\n  // Start generating new keys.\n  _generateMyKeys()\n\n  const onError = createEvent()\n  const onMessage = createEvent()\n  const onRoomJoin = createEvent()\n  const onRoomLeave = createEvent()\n  const onUserJoin = createEvent()\n  const onUserLeave = createEvent()\n  const onUserVerified = createEvent()\n  const onUserVerificationCode = createEvent()\n  const onConnection = createEvent()\n\n  const _setConnectionState = (\n    state,\n  ) => {\n    if (_connectionState !== state) {\n      _connectionState = state\n      onConnection.dispatch({\n        state,\n      })\n    }\n  }\n\n  const _generateVerificationCode = async (\n    userId,\n  ) => {\n    const derivedKey = _userDerivedKeys.get(userId)\n    if (!derivedKey) {\n      return\n    }\n\n    _userVerification.set(\n      userId,\n      Array.from(\n        new Uint8Array(\n          await crypto.subtle.digest(\n            HASH_ALGORITHM,\n            new TextEncoder().encode(\n              _roomCode\n              + bufferToBase64(\n                await crypto.subtle.exportKey(\n                  'raw',\n                  derivedKey,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    )\n\n    onUserVerificationCode.dispatch({\n      userId,\n      code: getVerificationCode(userId),\n    })\n  }\n\n  /**\n   * Closes the current socket connection and resets the socket reference. This function should be called when leaving a room to ensure that the socket connection is properly closed and the state is cleaned up.\n   */\n  const leaveRoom = (\n  ) => {\n    if (\n      _connectionState === CONNECTION_DISCONNECTED\n      || _connectionState === CONNECTION_DISCONNECTING\n    ) {\n      return\n    }\n    _setConnectionState(CONNECTION_DISCONNECTING)\n\n    if (_socket) {\n      _socket.close()\n    }\n\n    _creatorId = _generatedKeys = _keyGenerationPromise = _myId = _myEncryptKeys = _myExchangeKeys = _myPublicEncryptKey = _myPublicSignKey = _mySignKeys = _sharedKey = _sharedMessagesBuffer = _socket = null\n    _userDerivedKeys.clear()\n    _userEncryptKeys.clear()\n    _userSignKeys.clear()\n    _userVerification.clear()\n\n    // Setup new keys right away.\n    _generateMyKeys()\n\n    _setConnectionState(CONNECTION_DISCONNECTED)\n  }\n\n  /**\n   * Joins a WebSocket room with the specified room code and optional credentials. Establishes a WebSocket connection to the server, appending the room code, password, and creator secret (if provided) as query parameters. Sets up event listeners for 'close', 'error', and 'message' events to handle room leave, errors, and incoming messages.\n   *\n   * @param {string} roomCode - The code of the room to join.\n   * @param {string|null} [password=null] - Optional password for the room.\n   * @param {string|null} [creatorSecret=null] - Optional creator secret for verifying this user is the creator of the room.\n   */\n  const _joinRoom = (\n    roomCode,\n    creatorSecret = null,\n  ) => {\n    if (\n      !creatorSecret\n      && _connectionState\n      && _connectionState !== CONNECTION_DISCONNECTED\n    ) {\n      return\n    }\n    _setConnectionState(CONNECTION_CONNECTING)\n\n    _roomCode = roomCode\n\n    const url = new URL(\n      wsUrl + joinRoomEndpoint,\n    )\n    url.searchParams.append(\n      'code',\n      _roomCode,\n    )\n    if (creatorSecret) {\n      url.searchParams.append(\n        'creator',\n        creatorSecret,\n      )\n    }\n\n    _socket = new WebSocket(\n      url.toString(),\n    )\n\n    _socket.addEventListener('close', (\n      event,\n    ) => {\n      onRoomLeave.dispatch({\n        event,\n      })\n\n      leaveRoom()\n    })\n\n    _socket.addEventListener('error', (\n      event,\n    ) => {\n      onError.dispatch({\n        event,\n      })\n      leaveRoom()\n    })\n\n    _socket.addEventListener('message', async (\n      event,\n    ) => {\n      _processMessage(\n        decode(\n          event.data,\n          base64ToString,\n        ),\n        event.data,\n      )\n    })\n  }\n\n  const _processMessage = async (\n    parts,\n    raw,\n    isBuffered = false,\n  ) => {\n    const {\n      [SERVER_PAYLOAD]: serverPayload,\n      [SERVER_TIME]: serverTime,\n\n      [SHARED_ENCRYPTION_IV]: sharedEncryptionIv,\n      [SHARED_ENCRYPTION_PAYLOAD]: sharedEncryptionPayload,\n\n      [USER_DIRECT_PAYLOAD]: userDirectPayload,\n      [USER_ENCRYPTION_IV]: userEncryptionIv,\n      [USER_ENCRYPTION_KEY]: userEncryptionKey,\n      [USER_ENCRYPTION_PAYLOAD]: userEncryptionPayload,\n      [USER_ENCRYPTION_SIGNATURE]: userEncryptionSignature,\n      [USER]: userReceiver,\n    } = parts\n\n    let data, deserializedData, payload\n\n    if (serverPayload) {\n      payload = serverPayload\n    } else if (userDirectPayload) {\n      payload = userDirectPayload\n    } else {\n      payload = raw\n    }\n\n    if (sharedEncryptionPayload) {\n      if (\n        !_sharedKey\n        || (\n          !isBuffered\n          && _sharedMessagesBuffer.length > 0\n        )\n      ) {\n        // Can't decrypt without the key, store the messages for later.\n        _sharedMessagesBuffer.push({\n          time: Date.now(),\n          parts,\n          raw,\n        })\n\n        // Remove oldest message if buffer is full.\n        if (_sharedMessagesBuffer.length > messageBufferMaxCount) {\n          _sharedMessagesBuffer.shift()\n        }\n        return\n      }\n      if (!sharedEncryptionIv) {\n        onError.dispatch(\n          new Error('Missing IV to decrypt message')\n        )\n        return\n      }\n\n      data = await crypto.subtle.decrypt(\n        {\n          iv: base64ToBuffer(sharedEncryptionIv),\n          name: SHARED_ENCRYPTION_ALGORITHM,\n        },\n        _sharedKey,\n        base64ToBuffer(sharedEncryptionPayload),\n      )\n      data = new TextDecoder().decode(data)\n    } else if (userEncryptionPayload) {\n      if (\n        !userEncryptionSignature\n        || !userEncryptionKey\n        || !userEncryptionIv\n      ) {\n        // Assume the message is not encrypted just send as a user specific message.\n        return\n      }\n      if (!_generatedKeys) {\n        await _generateMyKeys()\n      }\n\n      const payloadData = deserializeMessage(\n        new TextDecoder()\n          .decode(\n            await crypto.subtle.decrypt(\n              {\n                iv: base64ToBuffer(userEncryptionIv),\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              await crypto.subtle.importKey(\n                'raw',\n                await crypto.subtle.decrypt(\n                  {\n                    name: USER_ENCRYPTION_ALGORITHM,\n                  },\n                  _myEncryptKeys.privateKey,\n                  base64ToBuffer(userEncryptionKey),\n                ),\n                {\n                  name: SHARED_ENCRYPTION_ALGORITHM,\n                },\n                true,\n                ['encrypt', 'decrypt',],\n              ),\n              base64ToBuffer(userEncryptionPayload),\n            ),\n          ),\n      )\n\n      if (payloadData.type === KEY_EXCHANGE_ACCEPT) {\n        deserializedData = payloadData\n      } else {\n        const senderId = payloadData.sender\n\n        if (!senderId) {\n          onError.dispatch({\n            error: new Error('Message from unknown sender'),\n          })\n          return\n        }\n\n        const senderPublicKey = _userSignKeys.get(senderId)\n        if (!senderPublicKey) {\n          onError.dispatch({\n            error: new Error('No public key for ' + senderId),\n          })\n          return\n        }\n\n        if (!(await crypto.subtle.verify(\n          USER_SIGNATURE_ALGORITHM,\n          senderPublicKey,\n          base64ToBuffer(userEncryptionSignature),\n          dataBuffer,\n        ))) {\n          onError.dispatch({\n            error: new Error('Invalid signature from ' + senderId),\n          })\n          return\n        }\n\n        deserializedData = payloadData\n      }\n    } else {\n      data = payload\n    }\n\n    if (!deserializedData) {\n      try {\n        deserializedData = deserializeMessage(data)\n      } catch (error) {\n        onError.dispatch({\n          error: new Error('Failed to parse message ' + raw),\n        })\n        return\n      }\n    }\n    data = deserializedData\n\n    switch (data.type) {\n      case KEY_EXCHANGE_OFFER:\n        if (_myId === _creatorId) {\n          const newUserId = data.sender\n\n          _userEncryptKeys.set(\n            newUserId,\n            await crypto.subtle.importKey(\n              PUBLIC_KEY_EXPORT_FORMAT,\n              base64ToBuffer(data.publicEncryptKey),\n              { hash: HASH_ALGORITHM, name: USER_ENCRYPTION_ALGORITHM, },\n              true,\n              ['encrypt',],\n            ),\n          )\n\n          const publicSignKey = await crypto.subtle.importKey(\n            PUBLIC_KEY_EXPORT_FORMAT,\n            base64ToBuffer(data.publicSignKey),\n            { hash: HASH_ALGORITHM, name: USER_SIGNATURE_ALGORITHM, },\n            true,\n            ['verify',],\n          )\n\n          const publicExchangeKeyData = base64ToBuffer(data.publicExchangeKey)\n          if (!(await crypto.subtle.verify(\n            USER_SIGNATURE_ALGORITHM,\n            publicSignKey,\n            base64ToBuffer(data.signature),\n            publicExchangeKeyData,\n          ))) {\n            onError.dispatch({\n              error: new Error('Invalid signature for exchange from ' + newUserId),\n            })\n            return\n          }\n\n          _userSignKeys.set(newUserId, publicSignKey)\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          _userDerivedKeys.set(\n            newUserId,\n            await crypto.subtle.deriveKey(\n              {\n                name: DIFFIE_HELLMAN_ALGORITHM,\n                public: await crypto.subtle.importKey(\n                  DIFFIE_HELLMAN_EXPORT_FORMAT,\n                  publicExchangeKeyData,\n                  {\n                    name: DIFFIE_HELLMAN_ALGORITHM,\n                    namedCurve: DIFFIE_HELLMAN_CURVE,\n                  },\n                  true,\n                  [],\n                ),\n              },\n              _myExchangeKeys.privateKey,\n              {\n                length: SHARED_KEY_LENGTH,\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt', 'decrypt',],\n            ),\n          )\n\n          const myPublicExchangeKey = await crypto.subtle.exportKey(\n            DIFFIE_HELLMAN_EXPORT_FORMAT,\n            _myExchangeKeys.publicKey,\n          )\n          _message({\n            type: KEY_EXCHANGE_ACCEPT,\n\n            publicEncryptKey: bufferToBase64(_myPublicEncryptKey),\n            publicExchangeKey: bufferToBase64(myPublicExchangeKey),\n            publicSignKey: bufferToBase64(_myPublicSignKey),\n            signature: bufferToBase64(\n              await crypto.subtle.sign(\n                USER_SIGNATURE_ALGORITHM,\n                _mySignKeys.privateKey,\n                myPublicExchangeKey,\n              ),\n            ),\n          }, {\n            receiver: newUserId,\n          })\n          _generateVerificationCode(newUserId)\n        }\n        break\n\n      case KEY_EXCHANGE_ACCEPT:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (data.publicSignKey) {\n            const hostPublicSignKey = await crypto.subtle.importKey(\n              PUBLIC_KEY_EXPORT_FORMAT,\n              base64ToBuffer(data.publicSignKey),\n              {\n                hash: HASH_ALGORITHM,\n                name: USER_SIGNATURE_ALGORITHM,\n              },\n              true,\n              ['verify',],\n            )\n\n            if (\n              data.publicExchangeKey\n              && data.signature\n            ) {\n              if (!(await crypto.subtle.verify(\n                USER_SIGNATURE_ALGORITHM,\n                hostPublicSignKey,\n                base64ToBuffer(data.signature),\n                base64ToBuffer(data.publicExchangeKey),\n              ))) {\n                onError.dispatch({\n                  error: new Error('Invalid signature for exchange from ' + _creatorId),\n                })\n                leaveRoom()\n                return\n              }\n            }\n            _userSignKeys.set(\n              _creatorId,\n              hostPublicSignKey,\n            )\n          }\n\n          if (data.publicEncryptKey) {\n            _userEncryptKeys.set(\n              _creatorId,\n              await crypto.subtle.importKey(\n                PUBLIC_KEY_EXPORT_FORMAT,\n                base64ToBuffer(data.publicEncryptKey),\n                {\n                  hash: HASH_ALGORITHM,\n                  name: USER_ENCRYPTION_ALGORITHM,\n                },\n                true,\n                ['encrypt',],\n              ),\n            )\n          }\n\n          if (data.publicExchangeKey) {\n            if (!_generatedKeys) {\n              await _generateMyKeys()\n            }\n\n            _userDerivedKeys.set(\n              _creatorId,\n              await crypto.subtle.deriveKey(\n                {\n                  name: DIFFIE_HELLMAN_ALGORITHM,\n                  public: await crypto.subtle.importKey(\n                    DIFFIE_HELLMAN_EXPORT_FORMAT,\n                    base64ToBuffer(data.publicExchangeKey),\n                    {\n                      name: DIFFIE_HELLMAN_ALGORITHM,\n                      namedCurve: DIFFIE_HELLMAN_CURVE,\n                    },\n                    true,\n                    [],\n                  ),\n                },\n                _myExchangeKeys.privateKey,\n                {\n                  length: SHARED_KEY_LENGTH,\n                  name: SHARED_ENCRYPTION_ALGORITHM,\n                },\n                true,\n                ['encrypt', 'decrypt',],\n              )\n            )\n          }\n\n          if (\n            data.sharedKey\n            && data.sharedKeyIv\n          ) {\n            const derivedKey = _userDerivedKeys.get(_creatorId)\n            if (!derivedKey) {\n              onError.dispatch({\n                error: new Error('No derived key for host ' + _creatorId),\n              })\n              return\n            }\n\n            _sharedKey = await crypto.subtle.importKey(\n              'raw',\n              await crypto.subtle.decrypt(\n                {\n                  iv: base64ToBuffer(data.sharedKeyIv),\n                  name: SHARED_ENCRYPTION_ALGORITHM,\n                },\n                derivedKey,\n                base64ToBuffer(data.sharedKey),\n              ),\n              {\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt', 'decrypt',],\n            )\n\n            onUserVerified.dispatch({\n              userId: _myId,\n            })\n\n            if (_sharedMessagesBuffer.length > 0) {\n              const now = Date.now()\n              _sharedMessagesBuffer = _sharedMessagesBuffer.filter((item) => (\n                now - item.time < messageBufferMaxDuration\n              ))\n\n              while (_sharedMessagesBuffer.length > 0) {\n                const {\n                  parts,\n                  raw,\n                } = _sharedMessagesBuffer.shift()\n                _processMessage(\n                  parts,\n                  raw,\n                  true,\n                )\n              }\n            }\n\n            _setConnectionState(CONNECTION_CONNECTED)\n          } else {\n            _generateVerificationCode(_creatorId)\n          }\n        }\n        break\n\n      case ROOM_JOINED:\n        _creatorId = data.creatorId\n        _myId = data.userId\n\n        onRoomJoin.dispatch({\n          creatorId: data.creatorId,\n          roomCode: _roomCode,\n          userId: data.userId,\n          users: data.users,\n        })\n\n        if (_myId !== _creatorId) {\n          _setConnectionState(CONNECTION_PENDING_VERIFICATION)\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          const myPublicExchangeKey = await crypto.subtle.exportKey(\n            DIFFIE_HELLMAN_EXPORT_FORMAT,\n            _myExchangeKeys.publicKey,\n          )\n\n          _message({\n            type: KEY_EXCHANGE_OFFER,\n            publicEncryptKey: bufferToBase64(_myPublicEncryptKey),\n            publicExchangeKey: bufferToBase64(myPublicExchangeKey),\n            publicSignKey: bufferToBase64(_myPublicSignKey),\n            signature: bufferToBase64(\n              await crypto.subtle.sign(\n                USER_SIGNATURE_ALGORITHM,\n                _mySignKeys.privateKey,\n                myPublicExchangeKey,\n              ),\n            ),\n          }, {\n            allowUnencrypted: true,\n            receiver: _creatorId,\n          })\n        } else {\n          _setConnectionState(CONNECTION_CONNECTED)\n        }\n        break\n\n      case USER_LEFT:\n        onUserLeave.dispatch({\n          userId: data.userId,\n        })\n        _userDerivedKeys.delete(data.userId)\n        _userEncryptKeys.delete(data.userId)\n        _userSignKeys.delete(data.userId)\n        break\n\n      case USER_JOINED:\n        onUserJoin.dispatch({\n          userId: data.userId,\n        })\n        break\n\n      case USER_VERIFIED:\n        onUserVerified.dispatch({\n          userId: data.userId,\n        })\n        break\n\n      default:\n        onMessage.dispatch({\n          data,\n          time: calculateTime(\n            serverTime,\n            data?.senderTime,\n          ),\n        })\n        break\n    }\n  }\n\n  const _message = async (\n    data,\n    options = {},\n  ) => {\n    if (\n      !_socket\n      || _socket.readyState !== WebSocket.OPEN\n    ) {\n      onError.dispatch({\n        error: new Error('No open socket'),\n      })\n      return false\n    }\n\n    const message = serializeMessage({\n      ...data,\n      sender: _myId,\n      senderTime: Date.now(),\n    })\n    const parts = {}\n\n    if (options.receiver) {\n      const receiverPublicKey = _userEncryptKeys.get(options.receiver)\n      if (receiverPublicKey) {\n        const tempKey = await crypto.subtle.generateKey(\n          {\n            name: SHARED_ENCRYPTION_ALGORITHM,\n            length: 256,\n          },\n          true,\n          ['encrypt', 'decrypt',],\n        )\n        const iv = crypto.getRandomValues(\n          new Uint8Array(12),\n        )\n        const encryptedPayload = await crypto.subtle.encrypt(\n          {\n            iv,\n            name: SHARED_ENCRYPTION_ALGORITHM,\n          },\n          tempKey,\n          new TextEncoder().encode(message),\n        )\n\n        if (!_generatedKeys) {\n          await _generateMyKeys()\n        }\n\n        parts[USER_ENCRYPTION_SIGNATURE] = bufferToBase64(\n          await crypto.subtle.sign(\n            USER_SIGNATURE_ALGORITHM,\n            _mySignKeys.privateKey,\n            encryptedPayload,\n          ),\n        )\n        parts[USER_ENCRYPTION_KEY] = bufferToBase64(\n          await crypto.subtle.encrypt(\n            {\n              name: USER_ENCRYPTION_ALGORITHM,\n            },\n            receiverPublicKey,\n            await crypto.subtle.exportKey(\n              'raw',\n              tempKey,\n            ),\n          ),\n        )\n        parts[USER_ENCRYPTION_PAYLOAD] = bufferToBase64(encryptedPayload)\n        parts[USER_ENCRYPTION_IV] = bufferToBase64(iv)\n      } else if (!options.allowUnencrypted) {\n        onError.dispatch({\n          error: new Error('No public key for ' + options.receiver),\n        })\n        return false\n      } else {\n        parts[USER_DIRECT_PAYLOAD] = message\n      }\n\n      parts[USER] = options.receiver\n    } else if (options.server) {\n      parts[SERVER_PAYLOAD] = message\n    } else if (_sharedKey) {\n      const iv = crypto.getRandomValues(\n        new Uint8Array(12),\n      )\n\n      parts[SHARED_ENCRYPTION_IV] = bufferToBase64(iv)\n      parts[SHARED_ENCRYPTION_PAYLOAD] = bufferToBase64(\n        await crypto.subtle.encrypt(\n          {\n            iv,\n            name: SHARED_ENCRYPTION_ALGORITHM,\n          },\n          _sharedKey,\n          new TextEncoder().encode(message),\n        ),\n      )\n    } else {\n      onError.dispatch(\n        new Error('Trying to send without valid destination')\n      )\n      return false\n    }\n\n    _socket.send(\n      encode(\n        parts,\n        stringToBase64,\n      ),\n    )\n    return true\n  }\n\n  const messageServer = (\n    data,\n  ) => (\n    _myId\n    && _myId === _creatorId\n    && _message(data, {\n      server: true,\n    })\n  )\n  const messageUser = (\n    data,\n    userId,\n  ) => (\n    userId\n    && _message(data, {\n      receiver: userId,\n    })\n  )\n\n  const getVerificationCode = (\n    userId,\n    codeLength = 6,\n  ) => {\n    if (!_userVerification.has(userId)) {\n      return false\n    }\n    const hashArray = _userVerification.get(userId)\n    let code = ''\n    for (let i = 0; i < codeLength; i++) {\n      const index = hashArray[i] % IDENTIFIABLE_CHARACTERS.length\n      code += IDENTIFIABLE_CHARACTERS[index]\n    }\n    return code\n  }\n\n  return {\n    onConnection,\n    onError,\n    onMessage,\n\n    onRoomJoin,\n    onRoomLeave,\n\n    onUserJoin,\n    onUserLeave,\n    onUserVerified,\n    onUserVerificationCode,\n\n    messageRoom: (\n      data,\n    ) => _message(data),\n    messageServer,\n    messageUser,\n\n    closeRoom: (\n    ) => messageServer({\n      type: ROOM_CLOSED,\n    }),\n    createRoom: async (\n      options = {},\n    ) => {\n      if (\n        _connectionState\n        && _connectionState !== CONNECTION_DISCONNECTED\n      ) {\n        return\n      }\n      _setConnectionState(CONNECTION_CONNECTING)\n\n      try {\n        await new Promise((\n          resolve,\n          reject,\n        ) => {\n          const worker = new Worker(\n            URL.createObjectURL(\n              new Blob([SHARED_KEY_GENERATOR,], {\n                type: 'text/javascript',\n              }),\n            ),\n          )\n\n          worker.addEventListener('message', (\n            event,\n          ) => {\n            if (event.data.success) {\n              _sharedKey = event.data.sharedKey\n              resolve()\n            } else {\n              reject(\n                new Error(event.data.error)\n              )\n            }\n            worker.terminate()\n          })\n\n          worker.addEventListener('error', (\n            error,\n          ) => {\n            reject(error)\n            worker.terminate()\n          })\n\n          worker.postMessage({\n            type: 'SHARED_KEY',\n          })\n        })\n      } catch (error) {\n        _setConnectionState(CONNECTION_DISCONNECTED)\n        onError.dispatch({\n          error,\n        })\n        return\n      }\n\n      const url = new URL(\n        httpUrl\n        + createRoomEndpoint\n      )\n      if (options.limit) {\n        url.searchParams.append(\n          'limit',\n          options.limit,\n        )\n      }\n\n      const response = await fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          Accept: contentType,\n        },\n      })\n      if (!response.ok) {\n        throw new Error('Failed to create room')\n      }\n\n      let data = await response.text()\n      data = deserializeMessage(data)\n\n      _myId = data.userId\n\n      _joinRoom(\n        data.roomCode,\n        data.creatorSecret,\n      )\n\n      return data\n    },\n    joinRoom: (\n      roomCode,\n    ) => _joinRoom(\n      roomCode,\n    ),\n    leaveRoom,\n\n    kickUser: (\n      userId,\n    ) => messageServer({\n      type: USER_KICK,\n      userId,\n    }),\n\n    getVerificationCode,\n    verifyUser: async (\n      userId,\n      code,\n    ) => {\n      if (\n        _myId !== _creatorId\n        || !code\n      ) {\n        return false\n      }\n\n      const expectedCode = getVerificationCode(\n        userId,\n        code.length,\n      )\n      if (\n        !expectedCode\n        || !code\n        || expectedCode !== code\n      ) {\n        return false\n      }\n\n      const derivedKey = _userDerivedKeys.get(userId)\n      if (!derivedKey) {\n        return false\n      }\n\n      const iv = crypto.getRandomValues(\n        new Uint8Array(12),\n      )\n      _message({\n        type: KEY_EXCHANGE_ACCEPT,\n        sharedKey: bufferToBase64(\n          await crypto.subtle.encrypt(\n            {\n              iv,\n              name: SHARED_ENCRYPTION_ALGORITHM,\n            },\n            derivedKey,\n            await crypto.subtle.exportKey(\n              'raw',\n              _sharedKey,\n            ),\n          ),\n        ),\n        sharedKeyIv: bufferToBase64(iv),\n      }, {\n        receiver: userId,\n      })\n\n      onUserVerified.dispatch({\n        userId,\n      })\n      messageServer({\n        type: USER_VERIFIED,\n        userId,\n      })\n\n      return true\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": ["stringToBase64", "base64ToString", "offset", "parts", "raw", "options"]
}
