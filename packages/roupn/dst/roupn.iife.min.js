(()=>{var Ir=Object.defineProperty,Nr=Object.defineProperties;var Cr=Object.getOwnPropertyDescriptors;var Qe=Object.getOwnPropertySymbols;var Ar=Object.prototype.hasOwnProperty,xr=Object.prototype.propertyIsEnumerable;var Ze=(t,e,r)=>e in t?Ir(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ee=(t,e)=>{for(var r in e||(e={}))Ar.call(e,r)&&Ze(t,r,e[r]);if(Qe)for(var r of Qe(e))xr.call(e,r)&&Ze(t,r,e[r]);return t},re=(t,e)=>Nr(t,Cr(e));var B=(t,e,r)=>new Promise((n,o)=>{var d=x=>{try{u(r.next(x))}catch(P){o(P)}},G=x=>{try{u(r.throw(x))}catch(P){o(P)}},u=x=>x.done?n(x.value):Promise.resolve(x.value).then(d,G);u((r=r.apply(t,e)).next())});var qe=(t,e)=>{let r=window;for(let n=0;n<t.length-1;n++)(typeof r[t[n]]!="object"||!Array.isArray(r[t[n]]))&&(r[t[n]]={}),r=r[t[n]];r[t[t.length-1]]=e};var _e="CONNECTED",ge="CONNECTING",J="DISCONNECTED",Re="DISCONNECTING",$e="PENDING_VERIFICATION";var te="_KA",Ie="_KO",er="_RC",rr="_RJ";var Ne="_SU",Ce="_SS",tr="_UJ",nr="_UK",or="_UL",Ae="_UV";var I=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},sr=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},ir=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)},N=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)};var L=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var cr="|",ar=":",dr=(t,e)=>{let r=[];for(let n in t){let o=t[n];o!=null&&r.push(n+ar+e(String(o)))}return r.join(cr)},lr=(t,e)=>{let r={},n=t.split(cr);for(let o of n){let d=o.indexOf(ar);if(d>0){let G=o.substring(0,d),u=o.substring(d+1);r[G]=e(u)}}return r};var yr=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,o=(t-e+(t-r))/2;return{delay:n,offset:o,adjusted:r-n+o}};var Tr="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",xe="ABCDEFGHKMNPQRSTUVWXYZ23456789",pr=(t=24,e=Tr)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var ne="ECDH",Te="P-256",oe="raw",W="SHA-256",se="spki",O="AES-GCM";var ie="RSA-OAEP",H="RSASSA-PKCS1-v1_5",ur="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,o])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:o})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",fr="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Oe="S",Er="T",Ke="E",be="I",we="U",Ue="D",Se="V",De="K",Le="P",Pe="G";var fe=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:o="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:G="http://localhost:3000",wsUrl:u="http://localhost:3000",messageBufferMaxCount:x=50,messageBufferMaxDuration:P=60*1e3}=t,_,A,F,T,X,S,s,p,m,a,h=[],D,ce,V=new Map,Q=new Map,Z=new Map,ae=new Map,k=J,j=()=>(!A&&!F&&(F=new Promise((c,l)=>{let g=new Worker(URL.createObjectURL(new Blob([ur],{type:"text/javascript"})));g.addEventListener("message",y=>{if(y.data.success)X=y.data.myEncryptKeys,m=y.data.mySignKeys,S=y.data.myExchangeKeys,s=y.data.myPublicEncryptKey,p=y.data.myPublicSignKey,A=!0,F=null,c();else{let f=new Error(y.data.error);C.dispatch({error:f}),l(f)}g.terminate()}),g.addEventListener("error",y=>{C.dispatch({error:y}),l(y),g.terminate()}),g.postMessage({type:"USER_KEYS"})})),F);j();let C=L(),He=L(),ke=L(),Ye=L(),Ge=L(),Fe=L(),de=L(),Ve=L(),je=L(),Y=c=>{k!==c&&(k=c,je.dispatch({state:c}))},Be=c=>B(null,null,function*(){let l=V.get(c);l&&(ae.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest(W,new TextEncoder().encode(ce+N(yield crypto.subtle.exportKey("raw",l))))))),Ve.dispatch({userId:c,code:he(c)}))}),le=()=>{k===J||k===Re||(Y(Re),D&&D.close(),_=A=F=T=X=S=s=p=m=a=h=D=null,V.clear(),Q.clear(),Z.clear(),ae.clear(),j(),Y(J))},Je=(c,l=null)=>{if(!l&&k&&k!==J)return;Y(ge),ce=c;let g=new URL(u+d);g.searchParams.append("code",ce),l&&g.searchParams.append("creator",l),D=new WebSocket(g.toString()),D.addEventListener("close",y=>{Ye.dispatch({event:y}),le()}),D.addEventListener("error",y=>{C.dispatch({event:y}),le()}),D.addEventListener("message",y=>B(null,null,function*(){Xe(lr(y.data,sr),y.data)}))},Xe=(c,l,g=!1)=>B(null,null,function*(){let{[Oe]:y,[Er]:f,[be]:R,[Ke]:b,[Ue]:w,[Se]:U,[De]:q,[Le]:ze,[Pe]:We,[we]:Rr}=c,i,$,pe;if(y?pe=y:w?pe=w:pe=l,b){if(!a||!g&&h.length>0){h.push({time:Date.now(),parts:c,raw:l}),h.length>x&&h.shift();return}if(!R){C.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:I(R),name:O},a,I(b)),i=new TextDecoder().decode(i)}else if(ze){if(!We||!q||!U)return;A||(yield j());let E=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:I(U),name:O},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ie},X.privateKey,I(q)),{name:O},!0,["encrypt","decrypt"]),I(ze))));if(E.type===te)$=E;else{let v=E.sender;if(!v){C.dispatch({error:new Error("Message from unknown sender")});return}let M=Z.get(v);if(!M){C.dispatch({error:new Error("No public key for "+v)});return}if(!(yield crypto.subtle.verify(H,M,I(We),dataBuffer))){C.dispatch({error:new Error("Invalid signature from "+v)});return}$=E}}else i=pe;if(!$)try{$=r(i)}catch(E){C.dispatch({error:new Error("Failed to parse message "+l)});return}switch(i=$,i.type){case Ie:if(T===_){let E=i.sender;Q.set(E,yield crypto.subtle.importKey(se,I(i.publicEncryptKey),{hash:W,name:ie},!0,["encrypt"]));let v=yield crypto.subtle.importKey(se,I(i.publicSignKey),{hash:W,name:H},!0,["verify"]),M=I(i.publicExchangeKey);if(!(yield crypto.subtle.verify(H,v,I(i.signature),M))){C.dispatch({error:new Error("Invalid signature for exchange from "+E)});return}Z.set(E,v),A||(yield j()),V.set(E,yield crypto.subtle.deriveKey({name:ne,public:yield crypto.subtle.importKey(oe,M,{name:ne,namedCurve:Te},!0,[])},S.privateKey,{length:256,name:O},!0,["encrypt","decrypt"]));let ue=yield crypto.subtle.exportKey(oe,S.publicKey);z({type:te,publicEncryptKey:N(s),publicExchangeKey:N(ue),publicSignKey:N(p),signature:N(yield crypto.subtle.sign(H,m.privateKey,ue))},{receiver:E}),Be(E)}break;case te:if(Rr===T&&i.sender===_){if(i.publicSignKey){let E=yield crypto.subtle.importKey(se,I(i.publicSignKey),{hash:W,name:H},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(H,E,I(i.signature),I(i.publicExchangeKey)))){C.dispatch({error:new Error("Invalid signature for exchange from "+_)}),le();return}Z.set(_,E)}if(i.publicEncryptKey&&Q.set(_,yield crypto.subtle.importKey(se,I(i.publicEncryptKey),{hash:W,name:ie},!0,["encrypt"])),i.publicExchangeKey&&(A||(yield j()),V.set(_,yield crypto.subtle.deriveKey({name:ne,public:yield crypto.subtle.importKey(oe,I(i.publicExchangeKey),{name:ne,namedCurve:Te},!0,[])},S.privateKey,{length:256,name:O},!0,["encrypt","decrypt"]))),i.sharedKey&&i.sharedKeyIv){let E=V.get(_);if(!E){C.dispatch({error:new Error("No derived key for host "+_)});return}if(a=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:I(i.sharedKeyIv),name:O},E,I(i.sharedKey)),{name:O},!0,["encrypt","decrypt"]),de.dispatch({userId:T}),h.length>0){let v=Date.now();for(h=h.filter(M=>v-M.time<P);h.length>0;){let{parts:M,raw:ue}=h.shift();Xe(M,ue,!0)}}Y(_e)}else Be(_)}break;case rr:if(_=i.creatorId,T=i.userId,ke.dispatch({creatorId:i.creatorId,roomCode:ce,userId:i.userId,users:i.users}),T!==_){Y($e),A||(yield j());let E=yield crypto.subtle.exportKey(oe,S.publicKey);z({type:Ie,publicEncryptKey:N(s),publicExchangeKey:N(E),publicSignKey:N(p),signature:N(yield crypto.subtle.sign(H,m.privateKey,E))},{allowUnencrypted:!0,receiver:_})}else Y(_e);break;case or:Fe.dispatch({userId:i.userId}),V.delete(i.userId),Q.delete(i.userId),Z.delete(i.userId);break;case tr:Ge.dispatch({userId:i.userId});break;case Ae:de.dispatch({userId:i.userId});break;default:He.dispatch({data:i,time:yr(f,i==null?void 0:i.senderTime)});break}}),z=(g,...y)=>B(null,[g,...y],function*(c,l={}){if(!D||D.readyState!==WebSocket.OPEN)return C.dispatch({error:new Error("No open socket")}),!1;let f=n(re(ee({},c),{sender:T,senderTime:Date.now()})),R={};if(l.receiver){let b=Q.get(l.receiver);if(b){let w=yield crypto.subtle.generateKey({name:O,length:256},!0,["encrypt","decrypt"]),U=crypto.getRandomValues(new Uint8Array(12)),q=yield crypto.subtle.encrypt({iv:U,name:O},w,new TextEncoder().encode(f));A||(yield j()),R[Pe]=N(yield crypto.subtle.sign(H,m.privateKey,q)),R[De]=N(yield crypto.subtle.encrypt({name:ie},b,yield crypto.subtle.exportKey("raw",w))),R[Le]=N(q),R[Se]=N(U)}else if(l.allowUnencrypted)R[Ue]=f;else return C.dispatch({error:new Error("No public key for "+l.receiver)}),!1;R[we]=l.receiver}else if(l.server)R[Oe]=f;else if(a){let b=crypto.getRandomValues(new Uint8Array(12));R[be]=N(b),R[Ke]=N(yield crypto.subtle.encrypt({iv:b,name:O},a,new TextEncoder().encode(f)))}else return C.dispatch(new Error("Trying to send without valid destination")),!1;return D.send(dr(R,ir)),!0}),ye=c=>T&&T===_&&z(c,{server:!0}),gr=(c,l)=>l&&z(c,{receiver:l}),he=(c,l=6)=>{if(!ae.has(c))return!1;let g=ae.get(c),y="";for(let f=0;f<l;f++){let R=g[f]%xe.length;y+=xe[R]}return y};return{onConnection:je,onError:C,onMessage:He,onRoomJoin:ke,onRoomLeave:Ye,onUserJoin:Ge,onUserLeave:Fe,onUserVerified:de,onUserVerificationCode:Ve,messageRoom:c=>z(c),messageServer:ye,messageUser:gr,closeRoom:()=>ye({type:er}),createRoom:(...l)=>B(null,[...l],function*(c={}){if(k&&k!==J)return;Y(ge);try{yield new Promise((R,b)=>{let w=new Worker(URL.createObjectURL(new Blob([fr],{type:"text/javascript"})));w.addEventListener("message",U=>{U.data.success?(a=U.data.sharedKey,R()):b(new Error(U.data.error)),w.terminate()}),w.addEventListener("error",U=>{b(U),w.terminate()}),w.postMessage({type:"SHARED_KEY"})})}catch(R){Y(J),C.dispatch({error:R});return}let g=new URL(G+o);c.limit&&g.searchParams.append("limit",c.limit);let y=yield fetch(g.toString(),{method:"GET",headers:{Accept:e}});if(!y.ok)throw new Error("Failed to create room");let f=yield y.text();return f=r(f),T=f.userId,Je(f.roomCode,f.creatorSecret),f}),joinRoom:c=>Je(c),leaveRoom:le,kickUser:c=>ye({type:nr,userId:c}),getVerificationCode:he,verifyUser:(c,l)=>B(null,null,function*(){if(T!==_||!l)return!1;let g=he(c,l.length);if(!g||!l||g!==l)return!1;let y=V.get(c);if(!y)return!1;let f=crypto.getRandomValues(new Uint8Array(12));return z({type:te,sharedKey:N(yield crypto.subtle.encrypt({iv:f,name:O},y,yield crypto.subtle.exportKey("raw",a))),sharedKeyIv:N(f)},{receiver:c}),de.dispatch({userId:c}),ye({type:Ae,userId:c}),!0})}};var K=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=K(t[r]);return e}return t};var ve=(t,e,r)=>{let n=t;for(let o=0;o<e.length-1;o++){let d=e[o];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=K(r)},hr=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},Ee=(t,e,r=[])=>{let n=[];for(let o in t){let d=[...r,o];o in e?typeof t[o]=="object"&&typeof e[o]=="object"?n.unshift(...Ee(t[o],e[o],d)):t[o]!==e[o]&&n.unshift({type:"set",path:d,old:K(t[o]),new:K(e[o])}):n.unshift({type:"delete",path:d,old:K(t[o])})}for(let o in e)o in t||n.unshift({type:"set",path:[...r,o],new:K(e[o])});return n},me=(t,e)=>{for(let r of e)r.type==="set"?ve(t,r.path,r.new):r.type==="delete"&&hr(t,r.path);return t},Me=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?hr(t,r.path):ve(t,r.path,r.old):r.type==="delete"&&ve(t,r.path,r.old);return t};var _r=(t={},e={},r={})=>{let n=fe(t),{messageRoom:o}=n,{windowPerUser:d=16,synchronisationInterval:G=60*1e3}=t,u=[],x,P=0,_=0,A=d,F=s=>{let p=pr(),m=s.length>0?s[0].identifier:null;u.unshift({identifier:p,previous:m,sender:e.userId,stateDelta:s,time:{adjusted:Date.now()+P-_}}),u.length>A&&u.splice(A),o({identifier:p,previous:m,stateDelta:s,type:Ne}),S()},T=()=>{if(e.previousState){let s=Ee(e.previousState,r);s.length>0&&F(s)}},X=()=>{e.users.length>1&&o({type:Ce,state:K(r)})},S=()=>{e.previousState=K(r)};return n.onMessage.addListener(({data:s,time:p})=>{if(!(s.sender===e.userId||s.receiver&&s.receiver!==e.userId)){if(P=(P+p.delay)/2,_=(_+p.offset)/2,s.type===Ce){let m=0;for(;m<u.length&&!(u[m].time.adjusted>=p.adjusted);m++);u.splice(0,m);for(let a in r)delete r[a];for(let a in s.state)r[a]=s.state[a];for(let a=0;a<u.length;a++)me(r,u[a].stateDelta);S()}else if(s.type===Ne){let m=!0;for(let a=0;a<u.length;a++){let h=u[a];if(h.identifier===s.previous||h.previous===s.previous&&h.time.adjusted<p.adjusted){u.splice(a,0,re(ee({},s),{time:p})),m=!1;break}}m&&u.unshift(re(ee({},s),{time:p}));for(let a=0;a<u.length;a++){let h=u[a];if(h.identifier===s.identifier)break;Me(r,h.stateDelta)}for(let a=0;a<u.length;a++){let h=u[a];if(me(r,h.stateDelta),h.identifier===s.identifier)break}S()}}}),n.onConnection.addListener(({state:s})=>{e.connectionState=s}),n.onRoomJoin.addListener(({creatorId:s,roomCode:p,userId:m,users:a})=>{e.creatorId=s,e.roomCode=p,e.userId=m,e.users=a,e.verifiedUsers=[],e.previousState=K(r),m===s&&(e.verifiedUsers.push(m),x=setInterval(X,G))}),n.onRoomLeave.addListener(()=>{for(let s in e)delete e[s];x&&clearInterval(x)}),n.onUserJoin.addListener(({userId:s})=>{e.users.push(s),A=d+d*e.users.length}),n.onUserVerificationCode.addListener(s=>{s.userId===e.creatorId&&(e.verificationCode=s.code)}),n.onUserVerified.addListener(({userId:s})=>{e.verifiedUsers.push(s),A=d+d*e.users.length,e.userId===e.creatorId&&X()}),n.onUserLeave.addListener(({userId:s})=>{for(let p=0;p<e.users.length;p++)if(e.users[p]===s){e.users.splice(p,1);break}for(let p=0;p<e.verifiedUsers.length;p++)if(e.verifiedUsers[p]===s){e.verifiedUsers.splice(p,1);break}A=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:T},n)};qe(["roupn"],{createClientConnector:fe,createClientSynchronizer:_r});})();
