(()=>{var Cr=Object.defineProperty,Ar=Object.defineProperties;var xr=Object.getOwnPropertyDescriptors;var Xe=Object.getOwnPropertySymbols;var br=Object.prototype.hasOwnProperty,Tr=Object.prototype.propertyIsEnumerable;var Be=(t,e,r)=>e in t?Cr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ae=(t,e)=>{for(var r in e||(e={}))br.call(e,r)&&Be(t,r,e[r]);if(Xe)for(var r of Xe(e))Tr.call(e,r)&&Be(t,r,e[r]);return t},de=(t,e)=>Ar(t,xr(e));var J=(t,e,r)=>new Promise((n,o)=>{var d=A=>{try{E(r.next(A))}catch(H){o(H)}},F=A=>{try{E(r.throw(A))}catch(H){o(H)}},E=A=>A.done?n(A.value):Promise.resolve(A.value).then(d,F);E((r=r.apply(t,e)).next())});var Je=(t,e)=>{let r=window;for(let n=0;n<t.length-1;n++)(typeof r[t[n]]!="object"||!Array.isArray(r[t[n]]))&&(r[t[n]]={}),r=r[t[n]];r[t[t.length-1]]=e};var be="CONNECTED",Te="CONNECTING",z="DISCONNECTED",we="DISCONNECTING",ze="PENDING_VERIFICATION";var wr="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",Oe="ABCDEFGHKMNPQRSTUVWXYZ23456789",We=(t=24,e=wr)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var I=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},Qe=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},Ze=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)},N=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)};var P=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var qe=(t,e)=>{let r=[];for(let n in t){let o=t[n];o!=null&&r.push(n+":"+e(String(o)))}return r.join("|")},$e=(t,e)=>{let r={},n=t.split("|");for(let o of n){let d=o.indexOf(":");if(d>0){let F=o.substring(0,d),E=o.substring(d+1);r[F]=e(E)}}return r};var er=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,o=(t-e+(t-r))/2;return{delay:n,offset:o,adjusted:r-n+o}};var ue="ECDH",De="P-256";var ee="SHA-256",pe="spki",M="AES-GCM";var le="RSA-OAEP",W="RSASSA-PKCS1-v1_5",rr="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,o])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:o})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",tr="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Ie=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:o="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:F="http://localhost:3000",wsUrl:E="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:H=60*1e3}=t,b=z,p,D,j,Q,K,s,y,h,u,x,re,v,X,fe,G,U=[],S,Z=new Map,te=new Map,ne=new Map,ye=new Map,Ae=new Map,B=()=>(!D&&!j&&(j=new Promise((c,a)=>{let g=new Worker(URL.createObjectURL(new Blob([rr],{type:"text/javascript"})));g.addEventListener("message",l=>{if(l.data.success)Q=l.data.myEncryptKeys,u=l.data.mySignKeys,K=l.data.myExchangeKeys,y=l.data.myPublicEncryptKey,h=l.data.myPublicSignKey,D=!0,j=null,c();else{let _=new Error(l.data.error);m.dispatch({error:_}),a(_)}g.terminate()}),g.addEventListener("error",l=>{m.dispatch({error:l}),a(l),g.terminate()}),g.postMessage({type:"USER_KEYS"})})),j);B();let m=P(),Le=P(),Pe=P(),Me=P(),He=P(),ve=P(),Ee=P(),ke=P(),Ge=P(),Y=c=>{b!==c&&(b=c,Ge.dispatch({state:c}))},Ye=c=>J(null,null,function*(){let a=Z.get(c);a&&(ye.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest(ee,new TextEncoder().encode(fe+N(yield crypto.subtle.exportKey("raw",a))))))),ke.dispatch({userId:c,code:xe(c)}))}),q=()=>{b===z||b===we||(Y(we),S&&S.close(),p=D=j=s=Q=K=y=h=u=x=re=v=X=G=U=S=null,Z.clear(),te.clear(),ne.clear(),ye.clear(),Ae.clear(),B(),Y(z))},me=c=>_e({type:"_UK",userId:c}),Ve=(c,a=null)=>{if(!a&&b&&b!==z)return;Y(Te),fe=c;let g=new URL(E+d);g.searchParams.append("code",fe),a&&g.searchParams.append("creator",a),S=new WebSocket(g.toString()),S.addEventListener("close",l=>{Me.dispatch({event:l}),q()}),S.addEventListener("error",l=>{m.dispatch({event:l}),q()}),S.addEventListener("message",l=>J(null,null,function*(){Fe($e(l.data,Qe),l.data)}))},Fe=(c,a,g=!1)=>J(null,null,function*(){let{["S"]:l,["T"]:_,["I"]:R,["E"]:L,["D"]:C,["V"]:w,["K"]:se,["P"]:oe,["G"]:je,["U"]:ie}=c,i,ce,he,$;if(l?he=l:C?he=C:he=a,L){if(!G||!g&&U.length>0){U.push({time:Date.now(),parts:c,raw:a}),U.length>A&&U.shift();return}if(!R){m.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:I(R),name:M},G,I(L)),i=new TextDecoder().decode(i),$=!0}else if(oe){if(!se||!w){m.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}D||(yield B());let f=I(oe),O=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:I(w),name:M},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:le},Q.privateKey,I(se)),{name:M},!0,["encrypt","decrypt"]),f)));if($=!0,O.type==="_X1")ce=O;else if(je){let k=O.sender;if(!k){m.dispatch({error:new Error("Message from unknown sender")});return}let ge=ne.get(k);if(!ge){m.dispatch({error:new Error("No public key for "+k)});return}if(!(yield crypto.subtle.verify(W,ge,I(je),f))){m.dispatch({error:new Error("Invalid signature from "+k)});return}ce=O}else{m.dispatch({error:new Error("Missing encryption signature")});return}}else i=he;if(!ce)try{ce=r(i)}catch(f){m.dispatch({error:new Error("Failed to parse message "+a)});return}switch(i=ce,i.type){case"_RJ":if(p=i.creatorId,s=i.userId,Pe.dispatch({creatorId:i.creatorId,roomCode:fe,userId:i.userId,users:i.users}),s===p)Y(be);else{Y(ze),D||(yield B());let f=yield crypto.subtle.exportKey("raw",K.publicKey);V({type:"_X0",publicData:typeof v=="function"?v():v,publicEncryptKey:N(y),publicExchangeKey:N(f),publicSignKey:N(h)},{allowUnencrypted:!0,receiver:p})}break;case"_X0":if(ie===p&&s===p){let f=i.sender;if(X&&!X({data:i.publicData,userId:f})){me(f);return}te.set(f,yield crypto.subtle.importKey(pe,I(i.publicEncryptKey),{hash:ee,name:le},!0,["encrypt"]));let O=yield crypto.subtle.importKey(pe,I(i.publicSignKey),{hash:ee,name:W},!0,["verify"]),k=I(i.publicExchangeKey);if(!(yield crypto.subtle.verify(W,O,I(i.signature),k))){m.dispatch({error:new Error("Invalid signature for exchange from "+f)});return}ne.set(f,O),D||(yield B()),Z.set(f,yield crypto.subtle.deriveKey({name:ue,public:yield crypto.subtle.importKey("raw",k,{name:ue,namedCurve:De},!0,[])},K.privateKey,{length:256,name:M},!0,["encrypt","decrypt"]));let ge=yield crypto.subtle.exportKey("raw",K.publicKey);V({type:"_X1",publicData:typeof v=="function"?v():v,publicEncryptKey:N(y),publicExchangeKey:N(ge),publicSignKey:N(h)},{receiver:f}),Ye(f)}break;case"_X1":if(ie===s&&i.sender===p){if(X&&!X({data:i.publicData,userId:p})){q();return}let f=yield crypto.subtle.importKey(pe,I(i.publicSignKey),{hash:ee,name:W},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(W,f,I(i.signature),I(i.publicExchangeKey)))){m.dispatch({error:new Error("Invalid signature for exchange from "+p)}),q();return}ne.set(p,f),te.set(p,yield crypto.subtle.importKey(pe,I(i.publicEncryptKey),{hash:ee,name:le},!0,["encrypt"])),D||(yield B()),Z.set(p,yield crypto.subtle.deriveKey({name:ue,public:yield crypto.subtle.importKey("raw",I(i.publicExchangeKey),{name:ue,namedCurve:De},!0,[])},K.privateKey,{length:256,name:M},!0,["encrypt","decrypt"])),Ye(p)}break;case"_X2":if(ie===s&&i.sender===p){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}if(re&&!re({data:i.privateData,userId:p})){q();return}V({type:"_X3",privateData:x},{receiver:p})}break;case"_X3":if(ie===p&&s===p){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}let f=i.sender;if(!Ae.get(f)){m.dispatch({error:new Error("User not verified")}),me(f);return}if(re&&!re({data:i.privateData,userId:f})){me(f);return}V({type:"_X4",sharedKey:N(yield crypto.subtle.exportKey("raw",G))},{receiver:f}),Ee.dispatch({userId:f}),_e({type:"_UV",userId:f})}break;case"_X4":if(ie===s&&i.sender===p){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}if(G=yield crypto.subtle.importKey("raw",I(i.sharedKey),{name:M},!0,["encrypt","decrypt"]),Ee.dispatch({userId:s}),U.length>0){let f=Date.now();for(U=U.filter(O=>f-O.time<H);U.length>0;){let{parts:O,raw:k}=U.shift();Fe(O,k,!0)}}Y(be)}break;case"_UL":ve.dispatch({userId:i.userId}),Z.delete(i.userId),te.delete(i.userId),ne.delete(i.userId);break;case"_UJ":He.dispatch({userId:i.userId});break;case"_UV":Ee.dispatch({userId:i.userId});break;default:if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}Le.dispatch({data:i,time:er(_,i==null?void 0:i.senderTime)});break}}),V=(g,...l)=>J(null,[g,...l],function*(c,a={}){if(!S||S.readyState!==WebSocket.OPEN)return m.dispatch({error:new Error("No open socket")}),!1;let _=n(de(ae({},c),{sender:s,senderTime:Date.now()})),R={},L=a.receiver;if(L){let C=te.get(L);if(C){let w=yield crypto.subtle.generateKey({name:M,length:256},!0,["encrypt","decrypt"]),se=crypto.getRandomValues(new Uint8Array(12)),oe=yield crypto.subtle.encrypt({iv:se,name:M},w,new TextEncoder().encode(_));D||(yield B()),R["V"]=N(se),R["K"]=N(yield crypto.subtle.encrypt({name:le},C,yield crypto.subtle.exportKey("raw",w))),R["P"]=N(oe),R["G"]=N(yield crypto.subtle.sign(W,u.privateKey,oe))}else if(a.allowUnencrypted)R["D"]=_;else return m.dispatch({error:new Error("No public key for "+L)}),!1;R["U"]=L}else if(a.server)R["S"]=_;else if(G){let C=crypto.getRandomValues(new Uint8Array(12));R["I"]=N(C),R["E"]=N(yield crypto.subtle.encrypt({iv:C,name:M},G,new TextEncoder().encode(_)))}else return m.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(qe(R,Ze)),!0}),_e=c=>s&&s===p&&V(c,{server:!0}),Nr=(c,a)=>a&&V(c,{receiver:a}),xe=(c,a=6)=>{if(!ye.has(c))return!1;let g=ye.get(c),l="";for(let _=0;_<a;_++){let R=g[_]%Oe.length;l+=Oe[R]}return l};return{onConnection:Ge,onError:m,onMessage:Le,onRoomJoin:Pe,onRoomLeave:Me,onUserJoin:He,onUserLeave:ve,onUserVerified:Ee,onUserVerificationCode:ke,messageRoom:c=>V(c),messageServer:_e,messageUser:Nr,closeRoom:()=>_e({type:"_RC"}),createRoom:(...a)=>J(null,[...a],function*(c={}){if(b&&b!==z)return;Y(Te),c.publicData&&(v=c.publicData),c.verifyPublicData&&(X=c.verifyPublicData);try{yield new Promise((R,L)=>{let C=new Worker(URL.createObjectURL(new Blob([tr],{type:"text/javascript"})));C.addEventListener("message",w=>{w.data.success?(G=w.data.sharedKey,R()):L(new Error(w.data.error)),C.terminate()}),C.addEventListener("error",w=>{L(w),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(R){Y(z),m.dispatch({error:R});return}let g=new URL(F+o);c.limit&&g.searchParams.append("limit",c.limit);let l=yield fetch(g.toString(),{method:"GET",headers:{Accept:e}});if(!l.ok)throw new Error("Failed to create room");let _=yield l.text();return _=r(_),s=_.userId,Ve(_.roomCode,_.creatorSecret),_}),joinRoom:(c,a={})=>{a.publicData&&(v=a.publicData),a.verifyPublicData&&(X=a.verifyPublicData),Ve(c)},leaveRoom:q,kickUser:me,getVerificationCode:xe,verifyUser:(c,a)=>J(null,null,function*(){if(s!==p||!a)return!1;let g=xe(c,a.length);return!g||!a||g!==a||(Ae.set(c,!0),!Z.get(c))?!1:(V({type:"_X2",privateData:x},{receiver:c}),!0)})}};var T=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=T(t[r]);return e}return t};var Ue=(t,e,r)=>{let n=t;for(let o=0;o<e.length-1;o++){let d=e[o];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=T(r)},hr=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},Ne=(t,e,r=[])=>{let n=[];for(let o in t){let d=[...r,o];o in e?typeof t[o]=="object"&&typeof e[o]=="object"?n.unshift(...Ne(t[o],e[o],d)):t[o]!==e[o]&&n.unshift({type:"set",path:d,old:T(t[o]),new:T(e[o])}):n.unshift({type:"delete",path:d,old:T(t[o])})}for(let o in e)o in t||n.unshift({type:"set",path:[...r,o],new:T(e[o])});return n},Ce=(t,e)=>{for(let r of e)r.type==="set"?Ue(t,r.path,r.new):r.type==="delete"&&hr(t,r.path);return t},Se=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?hr(t,r.path):Ue(t,r.path,r.old):r.type==="delete"&&Ue(t,r.path,r.old);return t};var Ir=(t={},e={},r={})=>{let n=Ie(t),{messageRoom:o}=n,{windowPerUser:d=16,synchronisationInterval:F=60*1e3}=t,E=[],A,H=0,b=0,p=d,D=s=>{let y=We(),h=s.length>0?s[0].identifier:null;E.unshift({identifier:y,previous:h,sender:e.userId,stateDelta:s,time:{adjusted:Date.now()+H-b}}),E.length>p&&E.splice(p),o({identifier:y,previous:h,stateDelta:s,type:"_SU"}),K()},j=()=>{if(e.previousState){let s=Ne(e.previousState,r);s.length>0&&D(s)}},Q=()=>{e.users.length>1&&o({type:"_SS",state:T(r)})},K=()=>{e.previousState=T(r)};return n.onMessage.addListener(({data:s,time:y})=>{if(!(s.sender===e.userId||s.receiver&&s.receiver!==e.userId)){if(H=(H+y.delay)/2,b=(b+y.offset)/2,s.type==="_SS"){let h=0;for(;h<E.length&&!(E[h].time.adjusted>=y.adjusted);h++);E.splice(0,h);for(let u in r)delete r[u];for(let u in s.state)r[u]=s.state[u];for(let u=0;u<E.length;u++)Ce(r,E[u].stateDelta);K()}else if(s.type==="_SU"){let h=!0;for(let u=0;u<E.length;u++){let x=E[u];if(x.identifier===s.previous||x.previous===s.previous&&x.time.adjusted<y.adjusted){E.splice(u,0,de(ae({},s),{time:y})),h=!1;break}}h&&E.unshift(de(ae({},s),{time:y}));for(let u=0;u<E.length;u++){let x=E[u];if(x.identifier===s.identifier)break;Se(r,x.stateDelta)}for(let u=0;u<E.length;u++){let x=E[u];if(Ce(r,x.stateDelta),x.identifier===s.identifier)break}K()}}}),n.onConnection.addListener(({state:s})=>{e.connectionState=s}),n.onRoomJoin.addListener(({creatorId:s,roomCode:y,userId:h,users:u})=>{e.creatorId=s,e.roomCode=y,e.userId=h,e.users=u,e.verifiedUsers=[],e.previousState=T(r),h===s&&(e.verifiedUsers.push(h),A=setInterval(Q,F))}),n.onRoomLeave.addListener(()=>{for(let s in e)delete e[s];A&&clearInterval(A)}),n.onUserJoin.addListener(({userId:s})=>{e.users.push(s),p=d+d*e.users.length}),n.onUserVerificationCode.addListener(s=>{s.userId===e.creatorId&&(e.verificationCode=s.code)}),n.onUserVerified.addListener(({userId:s})=>{e.verifiedUsers.push(s),p=d+d*e.users.length,e.userId===e.creatorId&&Q()}),n.onUserLeave.addListener(({userId:s})=>{for(let y=0;y<e.users.length;y++)if(e.users[y]===s){e.users.splice(y,1);break}for(let y=0;y<e.verifiedUsers.length;y++)if(e.verifiedUsers[y]===s){e.verifiedUsers.splice(y,1);break}p=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:j},n)};Je(["roupn"],{createClientConnector:Ie,createClientSynchronizer:Ir});})();
