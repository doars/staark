(()=>{var Cr=Object.defineProperty,Ar=Object.defineProperties;var xr=Object.getOwnPropertyDescriptors;var Xe=Object.getOwnPropertySymbols;var br=Object.prototype.hasOwnProperty,wr=Object.prototype.propertyIsEnumerable;var Be=(t,e,r)=>e in t?Cr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ae=(t,e)=>{for(var r in e||(e={}))br.call(e,r)&&Be(t,r,e[r]);if(Xe)for(var r of Xe(e))wr.call(e,r)&&Be(t,r,e[r]);return t},de=(t,e)=>Ar(t,xr(e));var z=(t,e,r)=>new Promise((n,o)=>{var d=A=>{try{E(r.next(A))}catch(v){o(v)}},j=A=>{try{E(r.throw(A))}catch(v){o(v)}},E=A=>A.done?n(A.value):Promise.resolve(A.value).then(d,j);E((r=r.apply(t,e)).next())});var Je=(t,e)=>{let r=window;for(let n=0;n<t.length-1;n++)(typeof r[t[n]]!="object"||!Array.isArray(r[t[n]]))&&(r[t[n]]={}),r=r[t[n]];r[t[t.length-1]]=e};var be="CONNECTED",we="CONNECTING",W="DISCONNECTED",Te="DISCONNECTING",ze="PENDING_VERIFICATION";var Tr="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",Oe="ABCDEFGHKMNPQRSTUVWXYZ23456789",We=(t=24,e=Tr)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var I=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},Qe=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},Ze=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)},N=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)};var P=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var qe=(t,e)=>{let r=[];for(let n in t){let o=t[n];o!=null&&r.push(n+":"+e(String(o)))}return r.join("|")},$e=(t,e)=>{let r={},n=t.split("|");for(let o of n){let d=o.indexOf(":");if(d>0){let j=o.substring(0,d),E=o.substring(d+1);r[j]=e(E)}}return r};var er=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,o=(t-e+(t-r))/2;return{delay:n,offset:o,adjusted:r-n+o}};var ue="ECDH",De="P-256";var ee="SHA-256",pe="spki",M="AES-GCM";var le="RSA-OAEP",F="RSASSA-PKCS1-v1_5",rr="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,o])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:o})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",tr="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Ie=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:o="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:j="http://localhost:3000",wsUrl:E="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:v=60*1e3}=t,b=W,l,D,X,Q,K,s,y,h,u,x,re,H,B,fe,G,U=[],S,Z=new Map,te=new Map,ne=new Map,ye=new Map,Ae=new Map,J=()=>(!D&&!X&&(X=new Promise((c,a)=>{let g=new Worker(URL.createObjectURL(new Blob([rr],{type:"text/javascript"})));g.addEventListener("message",f=>{if(f.data.success)Q=f.data.myEncryptKeys,u=f.data.mySignKeys,K=f.data.myExchangeKeys,y=f.data.myPublicEncryptKey,h=f.data.myPublicSignKey,D=!0,X=null,c();else{let _=new Error(f.data.error);m.dispatch({error:_}),a(_)}g.terminate()}),g.addEventListener("error",f=>{m.dispatch({error:f}),a(f),g.terminate()}),g.postMessage({type:"USER_KEYS"})})),X);J();let m=P(),Le=P(),Pe=P(),Me=P(),ve=P(),He=P(),Ee=P(),ke=P(),Ge=P(),Y=c=>{b!==c&&(b=c,Ge.dispatch({state:c}))},Ye=c=>z(null,null,function*(){let a=Z.get(c);a&&(ye.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest(ee,new TextEncoder().encode(fe+N(yield crypto.subtle.exportKey("raw",a))))))),ke.dispatch({userId:c,code:xe(c)}))}),q=()=>{b===W||b===Te||(Y(Te),S&&S.close(),l=D=X=s=Q=K=y=h=u=x=re=H=B=G=U=S=null,Z.clear(),te.clear(),ne.clear(),ye.clear(),Ae.clear(),J(),Y(W))},me=c=>_e({type:"_UK",userId:c}),Ve=(c,a=null)=>{if(!a&&b&&b!==W)return;Y(we),fe=c;let g=new URL(E+d);g.searchParams.append("code",fe),a&&g.searchParams.append("creator",a),S=new WebSocket(g.toString()),S.addEventListener("close",f=>{Me.dispatch({event:f}),q()}),S.addEventListener("error",f=>{m.dispatch({event:f}),q()}),S.addEventListener("message",f=>z(null,null,function*(){Fe($e(f.data,Qe),f.data)}))},Fe=(c,a,g=!1)=>z(null,null,function*(){let{["S"]:f,["T"]:_,["I"]:R,["E"]:L,["D"]:C,["V"]:T,["K"]:se,["P"]:oe,["G"]:je,["U"]:ie}=c,i,ce,he,$;if(f?he=f:C?he=C:he=a,L){if(!G||!g&&U.length>0){U.push({time:Date.now(),parts:c,raw:a}),U.length>A&&U.shift();return}if(!R){m.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:I(R),name:M},G,I(L)),i=new TextDecoder().decode(i),$=!0}else if(oe){if(!se||!T){m.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}D||(yield J());let p=I(oe),O=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:I(T),name:M},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:le},Q.privateKey,I(se)),{name:M},!0,["encrypt","decrypt"]),p)));if($=!0,O.type==="_X1")ce=O;else if(je){let k=O.sender;if(!k){m.dispatch({error:new Error("Message from unknown sender")});return}let ge=ne.get(k);if(!ge){m.dispatch({error:new Error("No public key for "+k)});return}if(!(yield crypto.subtle.verify(F,ge,I(je),p))){m.dispatch({error:new Error("Invalid signature from "+k)});return}ce=O}else{m.dispatch({error:new Error("Missing encryption signature")});return}}else i=he;if(!ce)try{ce=r(i)}catch(p){m.dispatch({error:new Error("Failed to parse message "+a)});return}switch(i=ce,i.type){case"_RJ":if(l=i.creatorId,s=i.userId,Pe.dispatch({creatorId:i.creatorId,roomCode:fe,userId:i.userId,users:i.users}),s===l)Y(be);else{Y(ze),D||(yield J());let p=yield crypto.subtle.exportKey("raw",K.publicKey);V({type:"_X0",publicData:typeof H=="function"?H():H,publicEncryptKey:N(y),publicExchangeKey:N(p),publicSignKey:N(h),signature:N(yield crypto.subtle.sign(F,u.privateKey,p))},{allowUnencrypted:!0,receiver:l})}break;case"_X0":if(ie===l&&s===l){let p=i.sender;if(B&&!B({data:i.publicData,userId:p})){me(p);return}te.set(p,yield crypto.subtle.importKey(pe,I(i.publicEncryptKey),{hash:ee,name:le},!0,["encrypt"]));let O=yield crypto.subtle.importKey(pe,I(i.publicSignKey),{hash:ee,name:F},!0,["verify"]),k=I(i.publicExchangeKey);if(!(yield crypto.subtle.verify(F,O,I(i.signature),k))){m.dispatch({error:new Error("Invalid signature for exchange from "+p)});return}ne.set(p,O),D||(yield J()),Z.set(p,yield crypto.subtle.deriveKey({name:ue,public:yield crypto.subtle.importKey("raw",k,{name:ue,namedCurve:De},!0,[])},K.privateKey,{length:256,name:M},!0,["encrypt","decrypt"]));let ge=yield crypto.subtle.exportKey("raw",K.publicKey);V({type:"_X1",publicData:typeof H=="function"?H():H,publicEncryptKey:N(y),publicExchangeKey:N(ge),publicSignKey:N(h)},{receiver:p}),Ye(p)}break;case"_X1":if(ie===s&&i.sender===l){if(B&&!B({data:i.publicData,userId:l})){q();return}let p=yield crypto.subtle.importKey(pe,I(i.publicSignKey),{hash:ee,name:F},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(F,p,I(i.signature),I(i.publicExchangeKey)))){m.dispatch({error:new Error("Invalid signature for exchange from "+l)}),q();return}ne.set(l,p),te.set(l,yield crypto.subtle.importKey(pe,I(i.publicEncryptKey),{hash:ee,name:le},!0,["encrypt"])),D||(yield J()),Z.set(l,yield crypto.subtle.deriveKey({name:ue,public:yield crypto.subtle.importKey("raw",I(i.publicExchangeKey),{name:ue,namedCurve:De},!0,[])},K.privateKey,{length:256,name:M},!0,["encrypt","decrypt"])),Ye(l)}break;case"_X2":if(ie===s&&i.sender===l){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}if(re&&!re({data:i.privateData,userId:l})){q();return}V({type:"_X3",privateData:x},{receiver:l})}break;case"_X3":if(ie===l&&s===l){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}let p=i.sender;if(!Ae.get(p)){m.dispatch({error:new Error("User not verified")}),me(p);return}if(re&&!re({data:i.privateData,userId:p})){me(p);return}V({type:"_X4",sharedKey:N(yield crypto.subtle.exportKey("raw",G))},{receiver:p}),Ee.dispatch({userId:p}),_e({type:"_UV",userId:p})}break;case"_X4":if(ie===s&&i.sender===l){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}if(G=yield crypto.subtle.importKey("raw",I(i.sharedKey),{name:M},!0,["encrypt","decrypt"]),Ee.dispatch({userId:s}),U.length>0){let p=Date.now();for(U=U.filter(O=>p-O.time<v);U.length>0;){let{parts:O,raw:k}=U.shift();Fe(O,k,!0)}}Y(be)}break;case"_UL":He.dispatch({userId:i.userId}),Z.delete(i.userId),te.delete(i.userId),ne.delete(i.userId);break;case"_UJ":ve.dispatch({userId:i.userId});break;case"_UV":Ee.dispatch({userId:i.userId});break;default:if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}Le.dispatch({data:i,time:er(_,i==null?void 0:i.senderTime)});break}}),V=(g,...f)=>z(null,[g,...f],function*(c,a={}){if(!S||S.readyState!==WebSocket.OPEN)return m.dispatch({error:new Error("No open socket")}),!1;let _=n(de(ae({},c),{sender:s,senderTime:Date.now()})),R={},L=a.receiver;if(L){let C=te.get(L);if(C){let T=yield crypto.subtle.generateKey({name:M,length:256},!0,["encrypt","decrypt"]),se=crypto.getRandomValues(new Uint8Array(12)),oe=yield crypto.subtle.encrypt({iv:se,name:M},T,new TextEncoder().encode(_));D||(yield J()),R["V"]=N(se),R["K"]=N(yield crypto.subtle.encrypt({name:le},C,yield crypto.subtle.exportKey("raw",T))),R["P"]=N(oe),R["G"]=N(yield crypto.subtle.sign(F,u.privateKey,oe))}else if(a.allowUnencrypted)R["D"]=_;else return m.dispatch({error:new Error("No public key for "+L)}),!1;R["U"]=L}else if(a.server)R["S"]=_;else if(G){let C=crypto.getRandomValues(new Uint8Array(12));R["I"]=N(C),R["E"]=N(yield crypto.subtle.encrypt({iv:C,name:M},G,new TextEncoder().encode(_)))}else return m.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(qe(R,Ze)),!0}),_e=c=>s&&s===l&&V(c,{server:!0}),Nr=(c,a)=>a&&V(c,{receiver:a}),xe=(c,a=6)=>{if(!ye.has(c))return!1;let g=ye.get(c),f="";for(let _=0;_<a;_++){let R=g[_]%Oe.length;f+=Oe[R]}return f};return{onConnection:Ge,onError:m,onMessage:Le,onRoomJoin:Pe,onRoomLeave:Me,onUserJoin:ve,onUserLeave:He,onUserVerified:Ee,onUserVerificationCode:ke,messageRoom:c=>V(c),messageServer:_e,messageUser:Nr,closeRoom:()=>_e({type:"_RC"}),createRoom:(...a)=>z(null,[...a],function*(c={}){if(b&&b!==W)return;Y(we),c.publicData&&(H=c.publicData),c.verifyPublicData&&(B=c.verifyPublicData);try{yield new Promise((R,L)=>{let C=new Worker(URL.createObjectURL(new Blob([tr],{type:"text/javascript"})));C.addEventListener("message",T=>{T.data.success?(G=T.data.sharedKey,R()):L(new Error(T.data.error)),C.terminate()}),C.addEventListener("error",T=>{L(T),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(R){Y(W),m.dispatch({error:R});return}let g=new URL(j+o);c.limit&&g.searchParams.append("limit",c.limit);let f=yield fetch(g.toString(),{method:"GET",headers:{Accept:e}});if(!f.ok)throw new Error("Failed to create room");let _=yield f.text();return _=r(_),s=_.userId,Ve(_.roomCode,_.creatorSecret),_}),joinRoom:(c,a={})=>{a.publicData&&(H=a.publicData),a.verifyPublicData&&(B=a.verifyPublicData),Ve(c)},leaveRoom:q,kickUser:me,getVerificationCode:xe,verifyUser:(c,a)=>z(null,null,function*(){if(s!==l||!a)return!1;let g=xe(c,a.length);return!g||!a||g!==a||(Ae.set(c,!0),!Z.get(c))?!1:(V({type:"_X2",privateData:x},{receiver:c}),!0)})}};var w=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=w(t[r]);return e}return t};var Ue=(t,e,r)=>{let n=t;for(let o=0;o<e.length-1;o++){let d=e[o];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=w(r)},hr=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},Ne=(t,e,r=[])=>{let n=[];for(let o in t){let d=[...r,o];o in e?typeof t[o]=="object"&&typeof e[o]=="object"?n.unshift(...Ne(t[o],e[o],d)):t[o]!==e[o]&&n.unshift({type:"set",path:d,old:w(t[o]),new:w(e[o])}):n.unshift({type:"delete",path:d,old:w(t[o])})}for(let o in e)o in t||n.unshift({type:"set",path:[...r,o],new:w(e[o])});return n},Ce=(t,e)=>{for(let r of e)r.type==="set"?Ue(t,r.path,r.new):r.type==="delete"&&hr(t,r.path);return t},Se=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?hr(t,r.path):Ue(t,r.path,r.old):r.type==="delete"&&Ue(t,r.path,r.old);return t};var Ir=(t={},e={},r={})=>{let n=Ie(t),{messageRoom:o}=n,{windowPerUser:d=16,synchronisationInterval:j=60*1e3}=t,E=[],A,v=0,b=0,l=d,D=s=>{let y=We(),h=s.length>0?s[0].identifier:null;E.unshift({identifier:y,previous:h,sender:e.userId,stateDelta:s,time:{adjusted:Date.now()+v-b}}),E.length>l&&E.splice(l),o({identifier:y,previous:h,stateDelta:s,type:"_SU"}),K()},X=()=>{if(e.previousState){let s=Ne(e.previousState,r);s.length>0&&D(s)}},Q=()=>{e.users.length>1&&o({type:"_SS",state:w(r)})},K=()=>{e.previousState=w(r)};return n.onMessage.addListener(({data:s,time:y})=>{if(!(s.sender===e.userId||s.receiver&&s.receiver!==e.userId)){if(v=(v+y.delay)/2,b=(b+y.offset)/2,s.type==="_SS"){let h=0;for(;h<E.length&&!(E[h].time.adjusted>=y.adjusted);h++);E.splice(0,h);for(let u in r)delete r[u];for(let u in s.state)r[u]=s.state[u];for(let u=0;u<E.length;u++)Ce(r,E[u].stateDelta);K()}else if(s.type==="_SU"){let h=!0;for(let u=0;u<E.length;u++){let x=E[u];if(x.identifier===s.previous||x.previous===s.previous&&x.time.adjusted<y.adjusted){E.splice(u,0,de(ae({},s),{time:y})),h=!1;break}}h&&E.unshift(de(ae({},s),{time:y}));for(let u=0;u<E.length;u++){let x=E[u];if(x.identifier===s.identifier)break;Se(r,x.stateDelta)}for(let u=0;u<E.length;u++){let x=E[u];if(Ce(r,x.stateDelta),x.identifier===s.identifier)break}K()}}}),n.onConnection.addListener(({state:s})=>{e.connectionState=s}),n.onRoomJoin.addListener(({creatorId:s,roomCode:y,userId:h,users:u})=>{e.creatorId=s,e.roomCode=y,e.userId=h,e.users=u,e.verifiedUsers=[],e.previousState=w(r),h===s&&(e.verifiedUsers.push(h),A=setInterval(Q,j))}),n.onRoomLeave.addListener(()=>{for(let s in e)delete e[s];A&&clearInterval(A)}),n.onUserJoin.addListener(({userId:s})=>{e.users.push(s),l=d+d*e.users.length}),n.onUserVerificationCode.addListener(s=>{s.userId===e.creatorId&&(e.verificationCode=s.code)}),n.onUserVerified.addListener(({userId:s})=>{e.verifiedUsers.push(s),l=d+d*e.users.length,e.userId===e.creatorId&&Q()}),n.onUserLeave.addListener(({userId:s})=>{for(let y=0;y<e.users.length;y++)if(e.users[y]===s){e.users.splice(y,1);break}for(let y=0;y<e.verifiedUsers.length;y++)if(e.verifiedUsers[y]===s){e.verifiedUsers.splice(y,1);break}l=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:X},n)};Je(["roupn"],{createClientConnector:Ie,createClientSynchronizer:Ir});})();
