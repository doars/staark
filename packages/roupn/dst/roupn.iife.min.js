(()=>{var J1=(x,q)=>{let $=window;for(let Q=0;Q<x.length-1;Q++){if(typeof $[x[Q]]!=="object"||!Array.isArray($[x[Q]]))$[x[Q]]={};$=$[x[Q]]}$[x[x.length-1]]=q};var P0="CONNECTED",C0="CONNECTING",c="DISCONNECTED",N0="DISCONNECTING",W1="PENDING_VERIFICATION";var A0="_X0",L0="_X1",K0="_X2",D0="_X3",m0="_X4",X1="_RC",z1="_RJ";var b0="_SU",g0="_SS",j1="_UJ",F1="_UK",Y1="_UL",h0="_UV";var T0="ABCDEFGHKMNPQRSTUVWXYZ23456789",V1=(x=24,q="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")=>{let $="";for(let Q=0;Q<x;Q++)$+=q.charAt(Math.floor(Math.random()*q.length));return $};var O=(x)=>{let q=atob(x);return Uint8Array.from(q,($)=>$.charCodeAt(0)).buffer},G1=(x)=>{let q=atob(x),$=Uint8Array.from(q,(Q)=>Q.charCodeAt(0));return new TextDecoder().decode($)},B1=(x)=>{let q=new TextEncoder().encode(x);if(q.length<65536)return btoa(String.fromCharCode(...q));let $="",Q=65536;for(let J=0;J<q.length;J+=Q){let Y=q.subarray(J,J+Q);$+=String.fromCharCode(...Y)}return btoa($)},U=(x)=>{let q=new Uint8Array(x);if(q.length<65536)return btoa(String.fromCharCode(...q));let $="",Q=65536;for(let J=0;J<q.length;J+=Q){let Y=q.subarray(J,J+Q);$+=String.fromCharCode(...Y)}return btoa($)};var R=()=>{let x=new Map;return{addListener:(q,$)=>{if(!x.has(q))x.set(q,$)},removeListener:(q)=>{x.delete(q)},dispatch:(q)=>{for(let[$,Q]of x.entries())if($(q),Q&&Q.once)x.delete($)}}};var w1=(x,q)=>{let $=[];for(let Q in x){let J=x[Q];if(J!==null&&J!==void 0)$.push(Q+":"+q(String(J)))}return $.join("|")},L1=(x,q)=>{let $={},Q=x.split("|");for(let J of Q){let Y=J.indexOf(":");if(Y>0){let r=J.substring(0,Y),M=J.substring(Y+1);$[r]=q(M)}}return $};var M1=(x,q)=>{let $=Date.now();if(!x)return{delay:0,offset:0,adjusted:$};if(!q){let Y=x-$;return{delay:0,offset:Y,adjusted:$+Y}}let Q=$-q,J=(x-q+(x-$))/2;return{delay:Q,offset:J,adjusted:$-Q+J}};var J0="ECDH",R0="P-256",W0="raw",s="SHA-256",X0="spki",l="AES-GCM",l0=256,z0="RSA-OAEP",u="RSASSA-PKCS1-v1_5",H1="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([x,q,$])=>{Promise.all([crypto.subtle.exportKey("spki",x.publicKey),crypto.subtle.exportKey("spki",q.publicKey)]).then(([Q,J])=>{self.postMessage({success:!0,myEncryptKeys:x,mySignKeys:q,myExchangeKeys:$,myPublicEncryptKey:Q,myPublicSignKey:J})}).catch((Q)=>{self.postMessage({success:!1,error:Q.message})})}).catch((x)=>{self.postMessage({success:!1,error:x.message})})}).toString()+")",k1="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then((x)=>{self.postMessage({success:!0,sharedKey:x})}).catch((x)=>{self.postMessage({success:!1,error:x.message})})}).toString()+")";var f0="S",O1="T",v0="E",I0="I",E0="U",S0="D",u0="V",y0="K",p0="P",_0="G";var M0=(x={})=>{let{contentType:q="application/json",deserializeMessage:$=JSON.parse,serializeMessage:Q=JSON.stringify,createRoomEndpoint:J="/create-room",joinRoomEndpoint:Y="/join-room",httpUrl:r="http://localhost:3000",wsUrl:M="http://localhost:3000",messageBufferMaxCount:a=50,messageBufferMaxDuration:t=60000}=x,N=c,G,b,y,d,g,Z,B,H,F,P,e,f,p,j0,I,h=[],T,n=new Map,q0=new Map,$0=new Map,F0=new Map,O0=new Map,_=()=>{if(!b&&!y)y=new Promise((W,j)=>{let w=new Worker(URL.createObjectURL(new Blob([H1],{type:"text/javascript"})));w.addEventListener("message",(X)=>{if(X.data.success)d=X.data.myEncryptKeys,F=X.data.mySignKeys,g=X.data.myExchangeKeys,B=X.data.myPublicEncryptKey,H=X.data.myPublicSignKey,b=!0,y=null,W();else{let k=Error(X.data.error);L.dispatch({error:k}),j(k)}w.terminate()}),w.addEventListener("error",(X)=>{L.dispatch({error:X}),j(X),w.terminate()}),w.postMessage({type:"USER_KEYS"})});return y};_();let L=R(),n0=R(),o0=R(),i0=R(),s0=R(),r0=R(),Y0=R(),a0=R(),t0=R(),E=(W)=>{if(N!==W)N=W,t0.dispatch({state:W})},e0=async(W)=>{let j=n.get(W);if(!j)return;F0.set(W,Array.from(new Uint8Array(await crypto.subtle.digest(s,new TextEncoder().encode(j0+U(await crypto.subtle.exportKey("raw",j))))))),a0.dispatch({userId:W,code:U0(W)})},o=()=>{if(N===c||N===N0)return;if(E(N0),T)T.close();G=b=y=Z=d=g=B=H=F=P=e=f=p=I=h=T=null,n.clear(),q0.clear(),$0.clear(),F0.clear(),O0.clear(),_(),E(c)},V0=(W)=>G0({type:F1,userId:W}),q1=(W,j=null)=>{if(!j&&N&&N!==c)return;E(C0),j0=W;let w=new URL(M+Y);if(w.searchParams.append("code",j0),j)w.searchParams.append("creator",j);T=new WebSocket(w.toString()),T.addEventListener("close",(X)=>{i0.dispatch({event:X}),o()}),T.addEventListener("error",(X)=>{L.dispatch({event:X}),o()}),T.addEventListener("message",async(X)=>{$1(L1(X.data,G1),X.data)})},$1=async(W,j,w=!1)=>{let{[f0]:X,[O1]:k,[I0]:C,[v0]:K,[S0]:D,[u0]:x0,[y0]:x1,[p0]:Q1,[_0]:Z1,[E0]:Q0}=W,z,Z0,B0,i;if(X)B0=X;else if(D)B0=D;else B0=j;if(K){if(!I||!w&&h.length>0){if(h.push({time:Date.now(),parts:W,raw:j}),h.length>a)h.shift();return}if(!C){L.dispatch(Error("Missing IV to decrypt message"));return}z=await crypto.subtle.decrypt({iv:O(C),name:l},I,O(K)),z=new TextDecoder().decode(z),i=!0}else if(Q1){if(!x1||!x0){L.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!b)await _();let V=O(Q1),m=$(new TextDecoder().decode(await crypto.subtle.decrypt({iv:O(x0),name:l},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:z0},d.privateKey,O(x1)),{name:l},!0,["encrypt","decrypt"]),V)));if(i=!0,m.type===L0)Z0=m;else if(Z1){let v=m.sender;if(!v){L.dispatch({error:Error("Message from unknown sender")});return}let w0=$0.get(v);if(!w0){L.dispatch({error:Error("No public key for "+v)});return}if(!await crypto.subtle.verify(u,w0,O(Z1),V)){L.dispatch({error:Error("Invalid signature from "+v)});return}Z0=m}else{L.dispatch({error:Error("Missing encryption signature")});return}}else z=B0;if(!Z0)try{Z0=$(z)}catch(V){L.dispatch({error:Error("Failed to parse message "+j)});return}switch(z=Z0,z.type){case z1:if(G=z.creatorId,Z=z.userId,o0.dispatch({creatorId:z.creatorId,roomCode:j0,userId:z.userId,users:z.users}),Z===G)E(P0);else{if(E(W1),!b)await _();let V=await crypto.subtle.exportKey(W0,g.publicKey);S({type:A0,publicData:typeof f==="function"?f():f,publicEncryptKey:U(B),publicExchangeKey:U(V),publicSignKey:U(H),signature:U(await crypto.subtle.sign(u,F.privateKey,V))},{allowUnencrypted:!0,receiver:G})}break;case A0:if(Q0===G&&Z===G){let V=z.sender;if(p&&!p({data:z.publicData,userId:V})){V0(V);return}q0.set(V,await crypto.subtle.importKey(X0,O(z.publicEncryptKey),{hash:s,name:z0},!0,["encrypt"]));let m=await crypto.subtle.importKey(X0,O(z.publicSignKey),{hash:s,name:u},!0,["verify"]),v=O(z.publicExchangeKey);if(!await crypto.subtle.verify(u,m,O(z.signature),v)){L.dispatch({error:Error("Invalid signature for exchange from "+V)});return}if($0.set(V,m),!b)await _();n.set(V,await crypto.subtle.deriveKey({name:J0,public:await crypto.subtle.importKey(W0,v,{name:J0,namedCurve:R0},!0,[])},g.privateKey,{length:l0,name:l},!0,["encrypt","decrypt"]));let w0=await crypto.subtle.exportKey(W0,g.publicKey);S({type:L0,publicData:typeof f==="function"?f():f,publicEncryptKey:U(B),publicExchangeKey:U(w0),publicSignKey:U(H)},{receiver:V}),e0(V)}break;case L0:if(Q0===Z&&z.sender===G){if(p&&!p({data:z.publicData,userId:G})){o();return}let V=await crypto.subtle.importKey(X0,O(z.publicSignKey),{hash:s,name:u},!0,["verify"]);if(z.publicExchangeKey&&z.signature){if(!await crypto.subtle.verify(u,V,O(z.signature),O(z.publicExchangeKey))){L.dispatch({error:Error("Invalid signature for exchange from "+G)}),o();return}}if($0.set(G,V),q0.set(G,await crypto.subtle.importKey(X0,O(z.publicEncryptKey),{hash:s,name:z0},!0,["encrypt"])),!b)await _();n.set(G,await crypto.subtle.deriveKey({name:J0,public:await crypto.subtle.importKey(W0,O(z.publicExchangeKey),{name:J0,namedCurve:R0},!0,[])},g.privateKey,{length:l0,name:l},!0,["encrypt","decrypt"])),e0(G)}break;case K0:if(Q0===Z&&z.sender===G){if(!i){L.dispatch({error:Error("Message was not encrypted")});return}if(e&&!e({data:z.privateData,userId:G})){o();return}S({type:D0,privateData:P},{receiver:G})}break;case D0:if(Q0===G&&Z===G){if(!i){L.dispatch({error:Error("Message was not encrypted")});return}let V=z.sender;if(!O0.get(V)){L.dispatch({error:Error("User not verified")}),V0(V);return}if(e&&!e({data:z.privateData,userId:V})){V0(V);return}S({type:m0,sharedKey:U(await crypto.subtle.exportKey("raw",I))},{receiver:V}),Y0.dispatch({userId:V}),G0({type:h0,userId:V})}break;case m0:if(Q0===Z&&z.sender===G){if(!i){L.dispatch({error:Error("Message was not encrypted")});return}if(I=await crypto.subtle.importKey("raw",O(z.sharedKey),{name:l},!0,["encrypt","decrypt"]),Y0.dispatch({userId:Z}),h.length>0){let V=Date.now();h=h.filter((m)=>V-m.time<t);while(h.length>0){let{parts:m,raw:v}=h.shift();$1(m,v,!0)}}E(P0)}break;case Y1:r0.dispatch({userId:z.userId}),n.delete(z.userId),q0.delete(z.userId),$0.delete(z.userId);break;case j1:s0.dispatch({userId:z.userId});break;case h0:Y0.dispatch({userId:z.userId});break;default:if(!i){L.dispatch({error:Error("Message was not encrypted")});return}n0.dispatch({data:z,time:M1(k,z?.senderTime)});break}},S=async(W,j={})=>{if(!T||T.readyState!==WebSocket.OPEN)return L.dispatch({error:Error("No open socket")}),!1;let w=Q({...W,sender:Z,senderTime:Date.now()}),X={},k=j.receiver;if(k){let C=q0.get(k);if(C){let K=await crypto.subtle.generateKey({name:l,length:256},!0,["encrypt","decrypt"]),D=crypto.getRandomValues(new Uint8Array(12)),x0=await crypto.subtle.encrypt({iv:D,name:l},K,new TextEncoder().encode(w));if(!b)await _();X[u0]=U(D),X[y0]=U(await crypto.subtle.encrypt({name:z0},C,await crypto.subtle.exportKey("raw",K))),X[p0]=U(x0),X[_0]=U(await crypto.subtle.sign(u,F.privateKey,x0))}else if(!j.allowUnencrypted)return L.dispatch({error:Error("No public key for "+k)}),!1;else X[S0]=w;X[E0]=k}else if(j.server)X[f0]=w;else if(I){let C=crypto.getRandomValues(new Uint8Array(12));X[I0]=U(C),X[v0]=U(await crypto.subtle.encrypt({iv:C,name:l},I,new TextEncoder().encode(w)))}else return L.dispatch(Error("Trying to send without valid destination")),!1;return T.send(w1(X,B1)),!0},G0=(W)=>Z&&Z===G&&S(W,{server:!0}),C1=(W,j)=>j&&S(W,{receiver:j}),U0=(W,j=6)=>{if(!F0.has(W))return!1;let w=F0.get(W),X="";for(let k=0;k<j;k++){let C=w[k]%T0.length;X+=T0[C]}return X};return{onConnection:t0,onError:L,onMessage:n0,onRoomJoin:o0,onRoomLeave:i0,onUserJoin:s0,onUserLeave:r0,onUserVerified:Y0,onUserVerificationCode:a0,messageRoom:(W)=>S(W),messageServer:G0,messageUser:C1,closeRoom:()=>G0({type:X1}),createRoom:async(W={})=>{if(N&&N!==c)return;if(E(C0),W.publicData)f=W.publicData;if(W.verifyPublicData)p=W.verifyPublicData;try{await new Promise((k,C)=>{let K=new Worker(URL.createObjectURL(new Blob([k1],{type:"text/javascript"})));K.addEventListener("message",(D)=>{if(D.data.success)I=D.data.sharedKey,k();else C(Error(D.data.error));K.terminate()}),K.addEventListener("error",(D)=>{C(D),K.terminate()}),K.postMessage({type:"SHARED_KEY"})})}catch(k){E(c),L.dispatch({error:k});return}let j=new URL(r+J);if(W.limit)j.searchParams.append("limit",W.limit);let w=await fetch(j.toString(),{method:"GET",headers:{Accept:q}});if(!w.ok)throw Error("Failed to create room");let X=await w.text();return X=$(X),Z=X.userId,q1(X.roomCode,X.creatorSecret),X},joinRoom:(W,j={})=>{if(j.publicData)f=j.publicData;if(j.verifyPublicData)p=j.verifyPublicData;q1(W)},leaveRoom:o,kickUser:V0,getVerificationCode:U0,verifyUser:async(W,j)=>{if(Z!==G||!j)return!1;let w=U0(W,j.length);if(!w||!j||w!==j)return!1;if(O0.set(W,!0),!n.get(W))return!1;return S({type:K0,privateData:P},{receiver:W}),!0}}};var A=(x)=>{if(x&&typeof x==="object"){let q=Array.isArray(x)?[]:{};for(let $ in x)q[$]=A(x[$]);return q}return x};var c0=(x,q,$)=>{let Q=x;for(let J=0;J<q.length-1;J++){let Y=q[J];if(!(Y in Q))Q[Y]={};Q=Q[Y]}Q[q[q.length-1]]=A($)},U1=(x,q)=>{let $=x;for(let Q=0;Q<q.length-1;Q++)if($=$[q[Q]],!$)return;if(Array.isArray($))$.splice(parseInt(q[q.length-1]),1);else delete $[q[q.length-1]]},H0=(x,q,$=[])=>{let Q=[];for(let J in x){let Y=[...$,J];if(!(J in q))Q.unshift({type:"delete",path:Y,old:A(x[J])});else if(typeof x[J]==="object"&&typeof q[J]==="object")Q.unshift(...H0(x[J],q[J],Y));else if(x[J]!==q[J])Q.unshift({type:"set",path:Y,old:A(x[J]),new:A(q[J])})}for(let J in q)if(!(J in x))Q.unshift({type:"set",path:[...$,J],new:A(q[J])});return Q},k0=(x,q)=>{for(let $ of q)if($.type==="set")c0(x,$.path,$.new);else if($.type==="delete")U1(x,$.path);return x},d0=(x,q)=>{for(let $ of q)if($.type==="set")if($.old===void 0)U1(x,$.path);else c0(x,$.path,$.old);else if($.type==="delete")c0(x,$.path,$.old);return x};var P1=(x={},q={},$={})=>{let Q=M0(x),{messageRoom:J}=Q,{windowPerUser:Y=16,synchronisationInterval:r=60000}=x,M=[],a,t=0,N=0,G=Y,b=(Z)=>{let B=V1(),H=Z.length>0?Z[0].identifier:null;if(M.unshift({identifier:B,previous:H,sender:q.userId,stateDelta:Z,time:{adjusted:Date.now()+t-N}}),M.length>G)M.splice(G);J({identifier:B,previous:H,stateDelta:Z,type:b0}),g()},y=()=>{if(q.previousState){let Z=H0(q.previousState,$);if(Z.length>0)b(Z)}},d=()=>{if(q.users.length>1)J({type:g0,state:A($)})},g=()=>{q.previousState=A($)};return Q.onMessage.addListener(({data:Z,time:B})=>{if(Z.sender===q.userId||Z.receiver&&Z.receiver!==q.userId)return;if(t=(t+B.delay)/2,N=(N+B.offset)/2,Z.type===g0){let H=0;for(;H<M.length;H++)if(M[H].time.adjusted>=B.adjusted)break;M.splice(0,H);for(let F in $)delete $[F];for(let F in Z.state)$[F]=Z.state[F];for(let F=0;F<M.length;F++)k0($,M[F].stateDelta);g()}else if(Z.type===b0){let H=!0;for(let F=0;F<M.length;F++){let P=M[F];if(P.identifier===Z.previous||P.previous===Z.previous&&P.time.adjusted<B.adjusted){M.splice(F,0,{...Z,time:B}),H=!1;break}}if(H)M.unshift({...Z,time:B});for(let F=0;F<M.length;F++){let P=M[F];if(P.identifier===Z.identifier)break;d0($,P.stateDelta)}for(let F=0;F<M.length;F++){let P=M[F];if(k0($,P.stateDelta),P.identifier===Z.identifier)break}g()}}),Q.onConnection.addListener(({state:Z})=>{q.connectionState=Z}),Q.onRoomJoin.addListener(({creatorId:Z,roomCode:B,userId:H,users:F})=>{if(q.creatorId=Z,q.roomCode=B,q.userId=H,q.users=F,q.verifiedUsers=[],q.previousState=A($),H===Z)q.verifiedUsers.push(H),a=setInterval(d,r)}),Q.onRoomLeave.addListener(()=>{for(let Z in q)delete q[Z];if(a)clearInterval(a)}),Q.onUserJoin.addListener(({userId:Z})=>{q.users.push(Z),G=Y+Y*q.users.length}),Q.onUserVerificationCode.addListener((Z)=>{if(Z.userId===q.creatorId)q.verificationCode=Z.code}),Q.onUserVerified.addListener(({userId:Z})=>{if(q.verifiedUsers.push(Z),G=Y+Y*q.users.length,q.userId===q.creatorId)d()}),Q.onUserLeave.addListener(({userId:Z})=>{for(let B=0;B<q.users.length;B++)if(q.users[B]===Z){q.users.splice(B,1);break}for(let B=0;B<q.verifiedUsers.length;B++)if(q.verifiedUsers[B]===Z){q.verifiedUsers.splice(B,1);break}G=Y+Y*q.users.length}),Object.assign({privateState:q,publicState:$,sendUpdate:y},Q)};J1(["roupn"],{createClientConnector:M0,createClientSynchronizer:P1});})();

//# debugId=E9E758FA2FEF796964756E2164756E21
