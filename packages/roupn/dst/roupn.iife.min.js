(()=>{var wr=Object.defineProperty,Kr=Object.defineProperties;var Ur=Object.getOwnPropertyDescriptors;var ir=Object.getOwnPropertySymbols;var Sr=Object.prototype.hasOwnProperty,Pr=Object.prototype.propertyIsEnumerable;var cr=(t,e,r)=>e in t?wr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ae=(t,e)=>{for(var r in e||(e={}))Sr.call(e,r)&&cr(t,r,e[r]);if(ir)for(var r of ir(e))Pr.call(e,r)&&cr(t,r,e[r]);return t},le=(t,e)=>Kr(t,Ur(e));var z=(t,e,r)=>new Promise((n,o)=>{var l=A=>{try{E(r.next(A))}catch(H){o(H)}},j=A=>{try{E(r.throw(A))}catch(H){o(H)}},E=A=>A.done?n(A.value):Promise.resolve(A.value).then(l,j);E((r=r.apply(t,e)).next())});var ar=(t,e)=>{let r=window;for(let n=0;n<t.length-1;n++)(typeof r[t[n]]!="object"||!Array.isArray(r[t[n]]))&&(r[t[n]]={}),r=r[t[n]];r[t[t.length-1]]=e};var xe="CONNECTED",Te="CONNECTING",W="DISCONNECTED",Oe="DISCONNECTING",lr="PENDING_VERIFICATION";var De="_X0",he="_X1",we="_X2",Ke="_X3",Ue="_X4",ur="_RC",dr="_RJ";var Se="_SU",Pe="_SS",pr="_UJ",fr="_UK",yr="_UL",Le="_UV";var Lr="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",ve="ABCDEFGHKMNPQRSTUVWXYZ23456789",Er=(t=24,e=Lr)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var R=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},mr=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},_r=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let l=e.subarray(o,o+n);r+=String.fromCharCode(...l)}return btoa(r)},I=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let l=e.subarray(o,o+n);r+=String.fromCharCode(...l)}return btoa(r)};var L=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var gr="|",hr=":",Rr=(t,e)=>{let r=[];for(let n in t){let o=t[n];o!=null&&r.push(n+hr+e(String(o)))}return r.join(gr)},Ir=(t,e)=>{let r={},n=t.split(gr);for(let o of n){let l=o.indexOf(hr);if(l>0){let j=o.substring(0,l),E=o.substring(l+1);r[j]=e(E)}}return r};var Nr=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let l=t-r;return{delay:0,offset:l,adjusted:r+l}}let n=r-e,o=(t-e+(t-r))/2;return{delay:n,offset:o,adjusted:r-n+o}};var ue="ECDH",He="P-256",de="raw",$="SHA-256",pe="spki",v="AES-GCM";var fe="RSA-OAEP",G="RSASSA-PKCS1-v1_5",Cr="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,o])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:o})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",Ar="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Me="S",br="T",ke="E",Ge="I",Ye="U",Ve="D",Fe="V",je="K",Xe="P",Be="G";var Re=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:o="/create-room",joinRoomEndpoint:l="/join-room",httpUrl:j="http://localhost:3000",wsUrl:E="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:H=60*1e3}=t,x=W,d,w,X,Q,K,s,y,_,u,b,ee,M,B,ye,Y,U=[],S,Z=new Map,re=new Map,te=new Map,Ee=new Map,Ce=new Map,J=()=>(!w&&!X&&(X=new Promise((c,a)=>{let g=new Worker(URL.createObjectURL(new Blob([Cr],{type:"text/javascript"})));g.addEventListener("message",p=>{if(p.data.success)Q=p.data.myEncryptKeys,u=p.data.mySignKeys,K=p.data.myExchangeKeys,y=p.data.myPublicEncryptKey,_=p.data.myPublicSignKey,w=!0,X=null,c();else{let m=new Error(p.data.error);N.dispatch({error:m}),a(m)}g.terminate()}),g.addEventListener("error",p=>{N.dispatch({error:p}),a(p),g.terminate()}),g.postMessage({type:"USER_KEYS"})})),X);J();let N=L(),We=L(),Qe=L(),Ze=L(),qe=L(),$e=L(),me=L(),er=L(),rr=L(),V=c=>{x!==c&&(x=c,rr.dispatch({state:c}))},tr=c=>z(null,null,function*(){let a=Z.get(c);a&&(Ee.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest($,new TextEncoder().encode(ye+I(yield crypto.subtle.exportKey("raw",a))))))),er.dispatch({userId:c,code:be(c)}))}),q=()=>{x===W||x===Oe||(V(Oe),S&&S.close(),d=w=X=s=Q=K=y=_=u=b=ee=M=B=Y=U=S=null,Z.clear(),re.clear(),te.clear(),Ee.clear(),Ce.clear(),J(),V(W))},Ae=c=>_e({type:fr,userId:c}),nr=(c,a=null)=>{if(!a&&x&&x!==W)return;V(Te),ye=c;let g=new URL(E+l);g.searchParams.append("code",ye),a&&g.searchParams.append("creator",a),S=new WebSocket(g.toString()),S.addEventListener("close",p=>{Ze.dispatch({event:p}),q()}),S.addEventListener("error",p=>{N.dispatch({event:p}),q()}),S.addEventListener("message",p=>z(null,null,function*(){sr(Ir(p.data,mr),p.data)}))},sr=(c,a,g=!1)=>z(null,null,function*(){let{[Me]:p,[br]:m,[Ge]:h,[ke]:P,[Ve]:C,[Fe]:O,[je]:ne,[Xe]:se,[Be]:or,[Ye]:oe}=c,i,ie,ge;if(p?ge=p:C?ge=C:ge=a,P){if(!Y||!g&&U.length>0){U.push({time:Date.now(),parts:c,raw:a}),U.length>A&&U.shift();return}if(!h){N.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:R(h),name:v},Y,R(P)),i=new TextDecoder().decode(i)}else if(se){if(!or||!ne||!O){N.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}w||(yield J());let f=R(se),D=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:R(O),name:v},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:fe},Q.privateKey,R(ne)),{name:v},!0,["encrypt","decrypt"]),f)));if(D.type===he)ie=D;else{let k=D.sender;if(!k){N.dispatch({error:new Error("Message from unknown sender")});return}let ce=te.get(k);if(!ce){N.dispatch({error:new Error("No public key for "+k)});return}if(!(yield crypto.subtle.verify(G,ce,R(or),f))){N.dispatch({error:new Error("Invalid signature from "+k)});return}ie=D}}else i=ge;if(!ie)try{ie=r(i)}catch(f){N.dispatch({error:new Error("Failed to parse message "+a)});return}switch(i=ie,i.type){case dr:if(d=i.creatorId,s=i.userId,Qe.dispatch({creatorId:i.creatorId,roomCode:ye,userId:i.userId,users:i.users}),s===d)V(xe);else{V(lr),w||(yield J());let f=yield crypto.subtle.exportKey(de,K.publicKey);F({type:De,publicData:typeof M=="function"?M():M,publicEncryptKey:I(y),publicExchangeKey:I(f),publicSignKey:I(_),signature:I(yield crypto.subtle.sign(G,u.privateKey,f))},{allowUnencrypted:!0,receiver:d})}break;case De:if(oe===d&&s===d){let f=i.sender;if(B&&!B({data:i.publicData,userId:f})){Ae(f);return}re.set(f,yield crypto.subtle.importKey(pe,R(i.publicEncryptKey),{hash:$,name:fe},!0,["encrypt"]));let D=yield crypto.subtle.importKey(pe,R(i.publicSignKey),{hash:$,name:G},!0,["verify"]),k=R(i.publicExchangeKey);if(!(yield crypto.subtle.verify(G,D,R(i.signature),k))){N.dispatch({error:new Error("Invalid signature for exchange from "+f)});return}te.set(f,D),w||(yield J()),Z.set(f,yield crypto.subtle.deriveKey({name:ue,public:yield crypto.subtle.importKey(de,k,{name:ue,namedCurve:He},!0,[])},K.privateKey,{length:256,name:v},!0,["encrypt","decrypt"]));let ce=yield crypto.subtle.exportKey(de,K.publicKey);F({type:he,publicData:typeof M=="function"?M():M,publicEncryptKey:I(y),publicExchangeKey:I(ce),publicSignKey:I(_),signature:I(yield crypto.subtle.sign(G,u.privateKey,ce))},{receiver:f}),tr(f)}break;case he:if(oe===s&&i.sender===d){if(B&&!B({data:i.publicData,userId:d})){q();return}let f=yield crypto.subtle.importKey(pe,R(i.publicSignKey),{hash:$,name:G},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(G,f,R(i.signature),R(i.publicExchangeKey)))){N.dispatch({error:new Error("Invalid signature for exchange from "+d)}),q();return}te.set(d,f),re.set(d,yield crypto.subtle.importKey(pe,R(i.publicEncryptKey),{hash:$,name:fe},!0,["encrypt"])),w||(yield J()),Z.set(d,yield crypto.subtle.deriveKey({name:ue,public:yield crypto.subtle.importKey(de,R(i.publicExchangeKey),{name:ue,namedCurve:He},!0,[])},K.privateKey,{length:256,name:v},!0,["encrypt","decrypt"])),tr(d)}break;case we:if(oe===s&&i.sender===d){if(ee&&!ee({data:i.privateData,userId:d})){q();return}F({type:Ke,privateData:b},{receiver:d})}break;case Ke:if(oe===d&&s===d){let f=i.sender;if(!Ce.get(f)||ee&&!ee({data:i.privateData,userId:f})){Ae(f);return}F({type:Ue,sharedKey:I(yield crypto.subtle.exportKey("raw",Y))},{receiver:f}),me.dispatch({userId:f}),_e({type:Le,userId:f})}break;case Ue:if(oe===s&&i.sender===d){if(Y=yield crypto.subtle.importKey("raw",R(i.sharedKey),{name:v},!0,["encrypt","decrypt"]),me.dispatch({userId:s}),U.length>0){let f=Date.now();for(U=U.filter(D=>f-D.time<H);U.length>0;){let{parts:D,raw:k}=U.shift();sr(D,k,!0)}}V(xe)}break;case yr:$e.dispatch({userId:i.userId}),Z.delete(i.userId),re.delete(i.userId),te.delete(i.userId);break;case pr:qe.dispatch({userId:i.userId});break;case Le:me.dispatch({userId:i.userId});break;default:We.dispatch({data:i,time:Nr(m,i==null?void 0:i.senderTime)});break}}),F=(g,...p)=>z(null,[g,...p],function*(c,a={}){if(!S||S.readyState!==WebSocket.OPEN)return N.dispatch({error:new Error("No open socket")}),!1;let m=n(le(ae({},c),{sender:s,senderTime:Date.now()})),h={},P=a.receiver;if(P){let C=re.get(P);if(C){let O=yield crypto.subtle.generateKey({name:v,length:256},!0,["encrypt","decrypt"]),ne=crypto.getRandomValues(new Uint8Array(12)),se=yield crypto.subtle.encrypt({iv:ne,name:v},O,new TextEncoder().encode(m));w||(yield J()),h[Fe]=I(ne),h[je]=I(yield crypto.subtle.encrypt({name:fe},C,yield crypto.subtle.exportKey("raw",O))),h[Xe]=I(se),h[Be]=I(yield crypto.subtle.sign(G,u.privateKey,se))}else if(a.allowUnencrypted)h[Ve]=m;else return N.dispatch({error:new Error("No public key for "+P)}),!1;h[Ye]=P}else if(a.server)h[Me]=m;else if(Y){let C=crypto.getRandomValues(new Uint8Array(12));h[Ge]=I(C),h[ke]=I(yield crypto.subtle.encrypt({iv:C,name:v},Y,new TextEncoder().encode(m)))}else return N.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(Rr(h,_r)),!0}),_e=c=>s&&s===d&&F(c,{server:!0}),Dr=(c,a)=>a&&F(c,{receiver:a}),be=(c,a=6)=>{if(!Ee.has(c))return!1;let g=Ee.get(c),p="";for(let m=0;m<a;m++){let h=g[m]%ve.length;p+=ve[h]}return p};return{onConnection:rr,onError:N,onMessage:We,onRoomJoin:Qe,onRoomLeave:Ze,onUserJoin:qe,onUserLeave:$e,onUserVerified:me,onUserVerificationCode:er,messageRoom:c=>F(c),messageServer:_e,messageUser:Dr,closeRoom:()=>_e({type:ur}),createRoom:(...a)=>z(null,[...a],function*(c={}){if(x&&x!==W)return;V(Te),c.publicData&&(M=c.publicData),c.verifyPublicData&&(B=c.verifyPublicData);try{yield new Promise((h,P)=>{let C=new Worker(URL.createObjectURL(new Blob([Ar],{type:"text/javascript"})));C.addEventListener("message",O=>{O.data.success?(Y=O.data.sharedKey,h()):P(new Error(O.data.error)),C.terminate()}),C.addEventListener("error",O=>{P(O),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(h){V(W),N.dispatch({error:h});return}let g=new URL(j+o);c.limit&&g.searchParams.append("limit",c.limit);let p=yield fetch(g.toString(),{method:"GET",headers:{Accept:e}});if(!p.ok)throw new Error("Failed to create room");let m=yield p.text();return m=r(m),s=m.userId,nr(m.roomCode,m.creatorSecret),m}),joinRoom:(c,a={})=>{a.publicData&&(M=a.publicData),a.verifyPublicData&&(B=a.verifyPublicData),nr(c)},leaveRoom:q,kickUser:Ae,getVerificationCode:be,verifyUser:(c,a)=>z(null,null,function*(){if(s!==d||!a)return!1;let g=be(c,a.length);return!g||!a||g!==a||(Ce.set(c,!0),!Z.get(c))?!1:(F({type:we,privateData:b},{receiver:c}),!0)})}};var T=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=T(t[r]);return e}return t};var Je=(t,e,r)=>{let n=t;for(let o=0;o<e.length-1;o++){let l=e[o];l in n||(n[l]={}),n=n[l]}n[e[e.length-1]]=T(r)},Tr=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},Ie=(t,e,r=[])=>{let n=[];for(let o in t){let l=[...r,o];o in e?typeof t[o]=="object"&&typeof e[o]=="object"?n.unshift(...Ie(t[o],e[o],l)):t[o]!==e[o]&&n.unshift({type:"set",path:l,old:T(t[o]),new:T(e[o])}):n.unshift({type:"delete",path:l,old:T(t[o])})}for(let o in e)o in t||n.unshift({type:"set",path:[...r,o],new:T(e[o])});return n},Ne=(t,e)=>{for(let r of e)r.type==="set"?Je(t,r.path,r.new):r.type==="delete"&&Tr(t,r.path);return t},ze=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?Tr(t,r.path):Je(t,r.path,r.old):r.type==="delete"&&Je(t,r.path,r.old);return t};var Or=(t={},e={},r={})=>{let n=Re(t),{messageRoom:o}=n,{windowPerUser:l=16,synchronisationInterval:j=60*1e3}=t,E=[],A,H=0,x=0,d=l,w=s=>{let y=Er(),_=s.length>0?s[0].identifier:null;E.unshift({identifier:y,previous:_,sender:e.userId,stateDelta:s,time:{adjusted:Date.now()+H-x}}),E.length>d&&E.splice(d),o({identifier:y,previous:_,stateDelta:s,type:Se}),K()},X=()=>{if(e.previousState){let s=Ie(e.previousState,r);s.length>0&&w(s)}},Q=()=>{e.users.length>1&&o({type:Pe,state:T(r)})},K=()=>{e.previousState=T(r)};return n.onMessage.addListener(({data:s,time:y})=>{if(!(s.sender===e.userId||s.receiver&&s.receiver!==e.userId)){if(H=(H+y.delay)/2,x=(x+y.offset)/2,s.type===Pe){let _=0;for(;_<E.length&&!(E[_].time.adjusted>=y.adjusted);_++);E.splice(0,_);for(let u in r)delete r[u];for(let u in s.state)r[u]=s.state[u];for(let u=0;u<E.length;u++)Ne(r,E[u].stateDelta);K()}else if(s.type===Se){let _=!0;for(let u=0;u<E.length;u++){let b=E[u];if(b.identifier===s.previous||b.previous===s.previous&&b.time.adjusted<y.adjusted){E.splice(u,0,le(ae({},s),{time:y})),_=!1;break}}_&&E.unshift(le(ae({},s),{time:y}));for(let u=0;u<E.length;u++){let b=E[u];if(b.identifier===s.identifier)break;ze(r,b.stateDelta)}for(let u=0;u<E.length;u++){let b=E[u];if(Ne(r,b.stateDelta),b.identifier===s.identifier)break}K()}}}),n.onConnection.addListener(({state:s})=>{e.connectionState=s}),n.onRoomJoin.addListener(({creatorId:s,roomCode:y,userId:_,users:u})=>{e.creatorId=s,e.roomCode=y,e.userId=_,e.users=u,e.verifiedUsers=[],e.previousState=T(r),_===s&&(e.verifiedUsers.push(_),A=setInterval(Q,j))}),n.onRoomLeave.addListener(()=>{for(let s in e)delete e[s];A&&clearInterval(A)}),n.onUserJoin.addListener(({userId:s})=>{e.users.push(s),d=l+l*e.users.length}),n.onUserVerificationCode.addListener(s=>{s.userId===e.creatorId&&(e.verificationCode=s.code)}),n.onUserVerified.addListener(({userId:s})=>{e.verifiedUsers.push(s),d=l+l*e.users.length,e.userId===e.creatorId&&Q()}),n.onUserLeave.addListener(({userId:s})=>{for(let y=0;y<e.users.length;y++)if(e.users[y]===s){e.users.splice(y,1);break}for(let y=0;y<e.verifiedUsers.length;y++)if(e.verifiedUsers[y]===s){e.verifiedUsers.splice(y,1);break}d=l+l*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:X},n)};ar(["roupn"],{createClientConnector:Re,createClientSynchronizer:Or});})();
