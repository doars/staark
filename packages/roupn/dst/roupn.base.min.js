var Ux="CONNECTED",Bx="CONNECTING",R="DISCONNECTED",Lx="DISCONNECTING",tx="PENDING_VERIFICATION";var Mx="_X0",zx="_X1",Px="_X2",Hx="_X3",hx="_X4",sx="_RC",ax="_RJ";var rx="_UJ",ex="_UK",x0="_UL",Dx="_UV";var Ox="ABCDEFGHKMNPQRSTUVWXYZ23456789";var k=(W)=>{let Z=atob(W);return Uint8Array.from(Z,(J)=>J.charCodeAt(0)).buffer},q0=(W)=>{let Z=atob(W),J=Uint8Array.from(Z,(j)=>j.charCodeAt(0));return new TextDecoder().decode(J)},$0=(W)=>{let Z=new TextEncoder().encode(W);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let J="",j=65536;for(let z=0;z<Z.length;z+=j){let L=Z.subarray(z,z+j);J+=String.fromCharCode(...L)}return btoa(J)},G=(W)=>{let Z=new Uint8Array(W);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let J="",j=65536;for(let z=0;z<Z.length;z+=j){let L=Z.subarray(z,z+j);J+=String.fromCharCode(...L)}return btoa(J)};var O=()=>{let W=new Map;return{addListener:(Z,J)=>{if(!W.has(Z))W.set(Z,J)},removeListener:(Z)=>{W.delete(Z)},dispatch:(Z)=>{for(let[J,j]of W.entries())if(J(Z),j&&j.once)W.delete(J)}}};var Q0=(W,Z)=>{let J=[];for(let j in W){let z=W[j];if(z!==null&&z!==void 0)J.push(j+":"+Z(String(z)))}return J.join("|")},W0=(W,Z)=>{let J={},j=W.split("|");for(let z of j){let L=z.indexOf(":");if(L>0){let Fx=z.substring(0,L),Yx=z.substring(L+1);J[Fx]=Z(Yx)}}return J};var Z0=(W,Z)=>{let J=Date.now();if(!W)return{delay:0,offset:0,adjusted:J};if(!Z){let L=W-J;return{delay:0,offset:L,adjusted:J+L}}let j=J-Z,z=(W-Z+(W-J))/2;return{delay:j,offset:z,adjusted:J-j+z}};var t="ECDH",Cx="P-256",s="raw",E="SHA-256",a="spki",C="AES-GCM",Nx=256,r="RSA-OAEP",p="RSASSA-PKCS1-v1_5",J0="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([W,Z,J])=>{Promise.all([crypto.subtle.exportKey("spki",W.publicKey),crypto.subtle.exportKey("spki",Z.publicKey)]).then(([j,z])=>{self.postMessage({success:!0,myEncryptKeys:W,mySignKeys:Z,myExchangeKeys:J,myPublicEncryptKey:j,myPublicSignKey:z})}).catch((j)=>{self.postMessage({success:!1,error:j.message})})}).catch((W)=>{self.postMessage({success:!1,error:W.message})})}).toString()+")",X0="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then((W)=>{self.postMessage({success:!0,sharedKey:W})}).catch((W)=>{self.postMessage({success:!1,error:W.message})})}).toString()+")";var Ax="S",j0="T",vx="E",Sx="I",bx="U",mx="D",Kx="V",px="K",gx="P",lx="G";var v0=(W={})=>{let{contentType:Z="application/json",deserializeMessage:J=JSON.parse,serializeMessage:j=JSON.stringify,createRoomEndpoint:z="/create-room",joinRoomEndpoint:L="/join-room",httpUrl:Fx="http://localhost:3000",wsUrl:Yx="http://localhost:3000",messageBufferMaxCount:z0=50,messageBufferMaxDuration:F0=60000}=W,v=R,V,S,c,Vx,f,U,e,xx,qx,wx,y,N,g,$x,b,h=[],D,T=new Map,d=new Map,_=new Map,Qx=new Map,kx=new Map,l=()=>{if(!S&&!c)c=new Promise((x,Q)=>{let F=new Worker(URL.createObjectURL(new Blob([J0],{type:"text/javascript"})));F.addEventListener("message",(q)=>{if(q.data.success)Vx=q.data.myEncryptKeys,qx=q.data.mySignKeys,f=q.data.myExchangeKeys,e=q.data.myPublicEncryptKey,xx=q.data.myPublicSignKey,S=!0,c=null,x();else{let w=Error(q.data.error);Y.dispatch({error:w}),Q(w)}F.terminate()}),F.addEventListener("error",(q)=>{Y.dispatch({error:q}),Q(q),F.terminate()}),F.postMessage({type:"USER_KEYS"})});return c};l();let Y=O(),Rx=O(),fx=O(),Tx=O(),ux=O(),Ix=O(),Wx=O(),Ex=O(),cx=O(),m=(x)=>{if(v!==x)v=x,cx.dispatch({state:x})},yx=async(x)=>{let Q=T.get(x);if(!Q)return;Qx.set(x,Array.from(new Uint8Array(await crypto.subtle.digest(E,new TextEncoder().encode($x+G(await crypto.subtle.exportKey("raw",Q))))))),Ex.dispatch({userId:x,code:Gx(x)})},u=()=>{if(v===R||v===Lx)return;if(m(Lx),D)D.close();V=S=c=U=Vx=f=e=xx=qx=wx=y=N=g=b=h=D=null,T.clear(),d.clear(),_.clear(),Qx.clear(),kx.clear(),l(),m(R)},Zx=(x)=>Jx({type:ex,userId:x}),dx=(x,Q=null)=>{if(!Q&&v&&v!==R)return;m(Bx),$x=x;let F=new URL(Yx+L);if(F.searchParams.append("code",$x),Q)F.searchParams.append("creator",Q);D=new WebSocket(F.toString()),D.addEventListener("close",(q)=>{Tx.dispatch({event:q}),u()}),D.addEventListener("error",(q)=>{Y.dispatch({event:q}),u()}),D.addEventListener("message",async(q)=>{_x(W0(q.data,q0),q.data)})},_x=async(x,Q,F=!1)=>{let{[Ax]:q,[j0]:w,[Sx]:B,[vx]:M,[mx]:P,[Kx]:n,[px]:nx,[gx]:ix,[lx]:ox,[bx]:i}=x,$,o,Xx,I;if(q)Xx=q;else if(P)Xx=P;else Xx=Q;if(M){if(!b||!F&&h.length>0){if(h.push({time:Date.now(),parts:x,raw:Q}),h.length>z0)h.shift();return}if(!B){Y.dispatch(Error("Missing IV to decrypt message"));return}$=await crypto.subtle.decrypt({iv:k(B),name:C},b,k(M)),$=new TextDecoder().decode($),I=!0}else if(ix){if(!nx||!n){Y.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!S)await l();let X=k(ix),H=J(new TextDecoder().decode(await crypto.subtle.decrypt({iv:k(n),name:C},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:r},Vx.privateKey,k(nx)),{name:C},!0,["encrypt","decrypt"]),X)));if(I=!0,H.type===zx)o=H;else if(ox){let A=H.sender;if(!A){Y.dispatch({error:Error("Message from unknown sender")});return}let jx=_.get(A);if(!jx){Y.dispatch({error:Error("No public key for "+A)});return}if(!await crypto.subtle.verify(p,jx,k(ox),X)){Y.dispatch({error:Error("Invalid signature from "+A)});return}o=H}else{Y.dispatch({error:Error("Missing encryption signature")});return}}else $=Xx;if(!o)try{o=J($)}catch(X){Y.dispatch({error:Error("Failed to parse message "+Q)});return}switch($=o,$.type){case ax:if(V=$.creatorId,U=$.userId,fx.dispatch({creatorId:$.creatorId,roomCode:$x,userId:$.userId,users:$.users}),U===V)m(Ux);else{if(m(tx),!S)await l();let X=await crypto.subtle.exportKey(s,f.publicKey);K({type:Mx,publicData:typeof N==="function"?N():N,publicEncryptKey:G(e),publicExchangeKey:G(X),publicSignKey:G(xx),signature:G(await crypto.subtle.sign(p,qx.privateKey,X))},{allowUnencrypted:!0,receiver:V})}break;case Mx:if(i===V&&U===V){let X=$.sender;if(g&&!g({data:$.publicData,userId:X})){Zx(X);return}d.set(X,await crypto.subtle.importKey(a,k($.publicEncryptKey),{hash:E,name:r},!0,["encrypt"]));let H=await crypto.subtle.importKey(a,k($.publicSignKey),{hash:E,name:p},!0,["verify"]),A=k($.publicExchangeKey);if(!await crypto.subtle.verify(p,H,k($.signature),A)){Y.dispatch({error:Error("Invalid signature for exchange from "+X)});return}if(_.set(X,H),!S)await l();T.set(X,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,A,{name:t,namedCurve:Cx},!0,[])},f.privateKey,{length:Nx,name:C},!0,["encrypt","decrypt"]));let jx=await crypto.subtle.exportKey(s,f.publicKey);K({type:zx,publicData:typeof N==="function"?N():N,publicEncryptKey:G(e),publicExchangeKey:G(jx),publicSignKey:G(xx)},{receiver:X}),yx(X)}break;case zx:if(i===U&&$.sender===V){if(g&&!g({data:$.publicData,userId:V})){u();return}let X=await crypto.subtle.importKey(a,k($.publicSignKey),{hash:E,name:p},!0,["verify"]);if($.publicExchangeKey&&$.signature){if(!await crypto.subtle.verify(p,X,k($.signature),k($.publicExchangeKey))){Y.dispatch({error:Error("Invalid signature for exchange from "+V)}),u();return}}if(_.set(V,X),d.set(V,await crypto.subtle.importKey(a,k($.publicEncryptKey),{hash:E,name:r},!0,["encrypt"])),!S)await l();T.set(V,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,k($.publicExchangeKey),{name:t,namedCurve:Cx},!0,[])},f.privateKey,{length:Nx,name:C},!0,["encrypt","decrypt"])),yx(V)}break;case Px:if(i===U&&$.sender===V){if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}if(y&&!y({data:$.privateData,userId:V})){u();return}K({type:Hx,privateData:wx},{receiver:V})}break;case Hx:if(i===V&&U===V){if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}let X=$.sender;if(!kx.get(X)){Y.dispatch({error:Error("User not verified")}),Zx(X);return}if(y&&!y({data:$.privateData,userId:X})){Zx(X);return}K({type:hx,sharedKey:G(await crypto.subtle.exportKey("raw",b))},{receiver:X}),Wx.dispatch({userId:X}),Jx({type:Dx,userId:X})}break;case hx:if(i===U&&$.sender===V){if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}if(b=await crypto.subtle.importKey("raw",k($.sharedKey),{name:C},!0,["encrypt","decrypt"]),Wx.dispatch({userId:U}),h.length>0){let X=Date.now();h=h.filter((H)=>X-H.time<F0);while(h.length>0){let{parts:H,raw:A}=h.shift();_x(H,A,!0)}}m(Ux)}break;case x0:Ix.dispatch({userId:$.userId}),T.delete($.userId),d.delete($.userId),_.delete($.userId);break;case rx:ux.dispatch({userId:$.userId});break;case Dx:Wx.dispatch({userId:$.userId});break;default:if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}Rx.dispatch({data:$,time:Z0(w,$?.senderTime)});break}},K=async(x,Q={})=>{if(!D||D.readyState!==WebSocket.OPEN)return Y.dispatch({error:Error("No open socket")}),!1;let F=j({...x,sender:U,senderTime:Date.now()}),q={},w=Q.receiver;if(w){let B=d.get(w);if(B){let M=await crypto.subtle.generateKey({name:C,length:256},!0,["encrypt","decrypt"]),P=crypto.getRandomValues(new Uint8Array(12)),n=await crypto.subtle.encrypt({iv:P,name:C},M,new TextEncoder().encode(F));if(!S)await l();q[Kx]=G(P),q[px]=G(await crypto.subtle.encrypt({name:r},B,await crypto.subtle.exportKey("raw",M))),q[gx]=G(n),q[lx]=G(await crypto.subtle.sign(p,qx.privateKey,n))}else if(!Q.allowUnencrypted)return Y.dispatch({error:Error("No public key for "+w)}),!1;else q[mx]=F;q[bx]=w}else if(Q.server)q[Ax]=F;else if(b){let B=crypto.getRandomValues(new Uint8Array(12));q[Sx]=G(B),q[vx]=G(await crypto.subtle.encrypt({iv:B,name:C},b,new TextEncoder().encode(F)))}else return Y.dispatch(Error("Trying to send without valid destination")),!1;return D.send(Q0(q,$0)),!0},Jx=(x)=>U&&U===V&&K(x,{server:!0}),Y0=(x,Q)=>Q&&K(x,{receiver:Q}),Gx=(x,Q=6)=>{if(!Qx.has(x))return!1;let F=Qx.get(x),q="";for(let w=0;w<Q;w++){let B=F[w]%Ox.length;q+=Ox[B]}return q};return{onConnection:cx,onError:Y,onMessage:Rx,onRoomJoin:fx,onRoomLeave:Tx,onUserJoin:ux,onUserLeave:Ix,onUserVerified:Wx,onUserVerificationCode:Ex,messageRoom:(x)=>K(x),messageServer:Jx,messageUser:Y0,closeRoom:()=>Jx({type:sx}),createRoom:async(x={})=>{if(v&&v!==R)return;if(m(Bx),x.publicData)N=x.publicData;if(x.verifyPublicData)g=x.verifyPublicData;try{await new Promise((w,B)=>{let M=new Worker(URL.createObjectURL(new Blob([X0],{type:"text/javascript"})));M.addEventListener("message",(P)=>{if(P.data.success)b=P.data.sharedKey,w();else B(Error(P.data.error));M.terminate()}),M.addEventListener("error",(P)=>{B(P),M.terminate()}),M.postMessage({type:"SHARED_KEY"})})}catch(w){m(R),Y.dispatch({error:w});return}let Q=new URL(Fx+z);if(x.limit)Q.searchParams.append("limit",x.limit);let F=await fetch(Q.toString(),{method:"GET",headers:{Accept:Z}});if(!F.ok)throw Error("Failed to create room");let q=await F.text();return q=J(q),U=q.userId,dx(q.roomCode,q.creatorSecret),q},joinRoom:(x,Q={})=>{if(Q.publicData)N=Q.publicData;if(Q.verifyPublicData)g=Q.verifyPublicData;dx(x)},leaveRoom:u,kickUser:Zx,getVerificationCode:Gx,verifyUser:async(x,Q)=>{if(U!==V||!Q)return!1;let F=Gx(x,Q.length);if(!F||!Q||F!==Q)return!1;if(kx.set(x,!0),!T.get(x))return!1;return K({type:Px,privateData:wx},{receiver:x}),!0}}};export{v0 as createClientConnector};

//# debugId=3D2DE4CCD951995064756E2164756E21
