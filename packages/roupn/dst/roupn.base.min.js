var pt=Object.defineProperty,Et=Object.defineProperties;var yt=Object.getOwnPropertyDescriptors;var Ge=Object.getOwnPropertySymbols;var ut=Object.prototype.hasOwnProperty,dt=Object.prototype.propertyIsEnumerable;var Fe=(r,t,e)=>t in r?pt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,ke=(r,t)=>{for(var e in t||(t={}))ut.call(t,e)&&Fe(r,e,t[e]);if(Ge)for(var e of Ge(t))dt.call(t,e)&&Fe(r,e,t[e]);return r},Ve=(r,t)=>Et(r,yt(t));var M=(r,t,e)=>new Promise((i,c)=>{var R=b=>{try{P(e.next(b))}catch(V){c(V)}},k=b=>{try{P(e.throw(b))}catch(V){c(V)}},P=b=>b.done?i(b.value):Promise.resolve(b.value).then(R,k);P((e=e.apply(r,t)).next())});var ue="CONNECTED",de="CONNECTING",H="DISCONNECTED",le="DISCONNECTING",Be="PENDING_VERIFICATION";var Q="_KA",fe="_KO",je="_RC",Je="_RJ";var Xe="_UJ",ze="_UK",We="_UL",_e="_UV";var d=r=>{let t=atob(r);return Uint8Array.from(t,e=>e.charCodeAt(0)).buffer},Qe=r=>{let t=atob(r),e=Uint8Array.from(t,i=>i.charCodeAt(0));return new TextDecoder().decode(e)},Ze=r=>{let t=new TextEncoder().encode(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",i=65536;for(let c=0;c<t.length;c+=i){let R=t.subarray(c,c+i);e+=String.fromCharCode(...R)}return btoa(e)},l=r=>{let t=new Uint8Array(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",i=65536;for(let c=0;c<t.length;c+=i){let R=t.subarray(c,c+i);e+=String.fromCharCode(...R)}return btoa(e)};var O=()=>{let r=new Map;return{addListener:(t,e)=>{r.has(t)||r.set(t,e)},removeListener:t=>{r.delete(t)},dispatch:t=>{for(let[e,i]of r.entries())e(t),i&&i.once&&r.delete(e)}}};var qe="|",$e=":",et=(r,t)=>{let e=[];for(let i in r){let c=r[i];c!=null&&e.push(i+$e+t(String(c)))}return e.join(qe)},tt=(r,t)=>{let e={},i=r.split(qe);for(let c of i){let R=c.indexOf($e);if(R>0){let k=c.substring(0,R),P=c.substring(R+1);e[k]=t(P)}}return e};var rt=(r,t)=>{let e=Date.now();if(!r)return{delay:0,offset:0,adjusted:e};if(!t){let R=r-e;return{delay:0,offset:R,adjusted:e+R}}let i=e-t,c=(r-t+(r-e))/2;return{delay:i,offset:c,adjusted:e-i+c}};var Re="ABCDEFGHKMNPQRSTUVWXYZ23456789";var Z="ECDH",me="P-256",q="raw",F="SHA-256",$="spki",m="AES-GCM";var ee="RSA-OAEP",T="RSASSA-PKCS1-v1_5",ot="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([r,t,e])=>{Promise.all([crypto.subtle.exportKey("spki",r.publicKey),crypto.subtle.exportKey("spki",t.publicKey)]).then(([i,c])=>{self.postMessage({success:!0,myEncryptKeys:r,mySignKeys:t,myExchangeKeys:e,myPublicEncryptKey:i,myPublicSignKey:c})}).catch(i=>{self.postMessage({success:!1,error:i.message})})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")",nt="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(r=>{self.postMessage({success:!0,sharedKey:r})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")";var Ne="S",st="T",Ie="E",ge="I",he="U",Ce="D",Se="V",Oe="K",be="P",Ae="G";var xt=(r={})=>{let{contentType:t="application/json",deserializeMessage:e=JSON.parse,serializeMessage:i=JSON.stringify,createRoomEndpoint:c="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:k="http://localhost:3000",wsUrl:P="http://localhost:3000",messageBufferMaxCount:b=50,messageBufferMaxDuration:V=60*1e3}=r,_,w,B,N,Ee,Y,te,re,j,x,C=[],S,oe,L=new Map,J=new Map,X=new Map,ne=new Map,D=H,v=()=>(!w&&!B&&(B=new Promise((n,s)=>{let y=new Worker(URL.createObjectURL(new Blob([ot],{type:"text/javascript"})));y.addEventListener("message",a=>{if(a.data.success)Ee=a.data.myEncryptKeys,j=a.data.mySignKeys,Y=a.data.myExchangeKeys,te=a.data.myPublicEncryptKey,re=a.data.myPublicSignKey,w=!0,B=null,n();else{let p=new Error(a.data.error);f.dispatch({error:p}),s(p)}y.terminate()}),y.addEventListener("error",a=>{f.dispatch({error:a}),s(a),y.terminate()}),y.postMessage({type:"USER_KEYS"})})),B);v();let f=O(),Ke=O(),Te=O(),we=O(),xe=O(),De=O(),se=O(),Ue=O(),Pe=O(),U=n=>{D!==n&&(D=n,Pe.dispatch({state:n}))},Le=n=>M(null,null,function*(){let s=L.get(n);s&&(ne.set(n,Array.from(new Uint8Array(yield crypto.subtle.digest(F,new TextEncoder().encode(oe+l(yield crypto.subtle.exportKey("raw",s))))))),Ue.dispatch({userId:n,code:ye(n)}))}),ae=()=>{D===H||D===le||(U(le),S&&S.close(),_=w=B=N=Ee=Y=te=re=j=x=C=S=null,L.clear(),J.clear(),X.clear(),ne.clear(),v(),U(H))},ve=(n,s=null)=>{if(!s&&D&&D!==H)return;U(de),oe=n;let y=new URL(P+R);y.searchParams.append("code",oe),s&&y.searchParams.append("creator",s),S=new WebSocket(y.toString()),S.addEventListener("close",a=>{we.dispatch({event:a}),ae()}),S.addEventListener("error",a=>{f.dispatch({event:a}),ae()}),S.addEventListener("message",a=>M(null,null,function*(){Me(tt(a.data,Qe),a.data)}))},Me=(n,s,y=!1)=>M(null,null,function*(){let{[Ne]:a,[st]:p,[ge]:u,[Ie]:I,[Ce]:g,[Se]:h,[Oe]:z,[be]:He,[Ae]:Ye,[he]:it}=n,o,W,ie;if(a?ie=a:g?ie=g:ie=s,I){if(!x||!y&&C.length>0){C.push({time:Date.now(),parts:n,raw:s}),C.length>b&&C.shift();return}if(!u){f.dispatch(new Error("Missing IV to decrypt message"));return}o=yield crypto.subtle.decrypt({iv:d(u),name:m},x,d(I)),o=new TextDecoder().decode(o)}else if(He){if(!Ye||!z||!h)return;w||(yield v());let E=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:d(h),name:m},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ee},Ee.privateKey,d(z)),{name:m},!0,["encrypt","decrypt"]),d(He))));if(E.type===Q)W=E;else{let A=E.sender;if(!A){f.dispatch({error:new Error("Message from unknown sender")});return}let K=X.get(A);if(!K){f.dispatch({error:new Error("No public key for "+A)});return}if(!(yield crypto.subtle.verify(T,K,d(Ye),dataBuffer))){f.dispatch({error:new Error("Invalid signature from "+A)});return}W=E}}else o=ie;if(!W)try{W=e(o)}catch(E){f.dispatch({error:new Error("Failed to parse message "+s)});return}switch(o=W,o.type){case fe:if(N===_){let E=o.sender;J.set(E,yield crypto.subtle.importKey($,d(o.publicEncryptKey),{hash:F,name:ee},!0,["encrypt"]));let A=yield crypto.subtle.importKey($,d(o.publicSignKey),{hash:F,name:T},!0,["verify"]),K=d(o.publicExchangeKey);if(!(yield crypto.subtle.verify(T,A,d(o.signature),K))){f.dispatch({error:new Error("Invalid signature for exchange from "+E)});return}X.set(E,A),w||(yield v()),L.set(E,yield crypto.subtle.deriveKey({name:Z,public:yield crypto.subtle.importKey(q,K,{name:Z,namedCurve:me},!0,[])},Y.privateKey,{length:256,name:m},!0,["encrypt","decrypt"]));let pe=yield crypto.subtle.exportKey(q,Y.publicKey);G({type:Q,publicEncryptKey:l(te),publicExchangeKey:l(pe),publicSignKey:l(re),signature:l(yield crypto.subtle.sign(T,j.privateKey,pe))},{receiver:E}),Le(E)}break;case Q:if(it===N&&o.sender===_){if(o.publicSignKey){let E=yield crypto.subtle.importKey($,d(o.publicSignKey),{hash:F,name:T},!0,["verify"]);if(o.publicExchangeKey&&o.signature&&!(yield crypto.subtle.verify(T,E,d(o.signature),d(o.publicExchangeKey)))){f.dispatch({error:new Error("Invalid signature for exchange from "+_)}),ae();return}X.set(_,E)}if(o.publicEncryptKey&&J.set(_,yield crypto.subtle.importKey($,d(o.publicEncryptKey),{hash:F,name:ee},!0,["encrypt"])),o.publicExchangeKey&&(w||(yield v()),L.set(_,yield crypto.subtle.deriveKey({name:Z,public:yield crypto.subtle.importKey(q,d(o.publicExchangeKey),{name:Z,namedCurve:me},!0,[])},Y.privateKey,{length:256,name:m},!0,["encrypt","decrypt"]))),o.sharedKey&&o.sharedKeyIv){let E=L.get(_);if(!E){f.dispatch({error:new Error("No derived key for host "+_)});return}if(x=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:d(o.sharedKeyIv),name:m},E,d(o.sharedKey)),{name:m},!0,["encrypt","decrypt"]),se.dispatch({userId:N}),C.length>0){let A=Date.now();for(C=C.filter(K=>A-K.time<V);C.length>0;){let{parts:K,raw:pe}=C.shift();Me(K,pe,!0)}}U(ue)}else Le(_)}break;case Je:if(_=o.creatorId,N=o.userId,Te.dispatch({creatorId:o.creatorId,roomCode:oe,userId:o.userId,users:o.users}),N!==_){U(Be),w||(yield v());let E=yield crypto.subtle.exportKey(q,Y.publicKey);G({type:fe,publicEncryptKey:l(te),publicExchangeKey:l(E),publicSignKey:l(re),signature:l(yield crypto.subtle.sign(T,j.privateKey,E))},{allowUnencrypted:!0,receiver:_})}else U(ue);break;case We:De.dispatch({userId:o.userId}),L.delete(o.userId),J.delete(o.userId),X.delete(o.userId);break;case Xe:xe.dispatch({userId:o.userId});break;case _e:se.dispatch({userId:o.userId});break;default:Ke.dispatch({data:o,time:rt(p,o==null?void 0:o.senderTime)});break}}),G=(y,...a)=>M(null,[y,...a],function*(n,s={}){if(!S||S.readyState!==WebSocket.OPEN)return f.dispatch({error:new Error("No open socket")}),!1;let p=i(Ve(ke({},n),{sender:N,senderTime:Date.now()})),u={};if(s.receiver){let I=J.get(s.receiver);if(I){let g=yield crypto.subtle.generateKey({name:m,length:256},!0,["encrypt","decrypt"]),h=crypto.getRandomValues(new Uint8Array(12)),z=yield crypto.subtle.encrypt({iv:h,name:m},g,new TextEncoder().encode(p));w||(yield v()),u[Ae]=l(yield crypto.subtle.sign(T,j.privateKey,z)),u[Oe]=l(yield crypto.subtle.encrypt({name:ee},I,yield crypto.subtle.exportKey("raw",g))),u[be]=l(z),u[Se]=l(h)}else if(s.allowUnencrypted)u[Ce]=p;else return f.dispatch({error:new Error("No public key for "+s.receiver)}),!1;u[he]=s.receiver}else if(s.server)u[Ne]=p;else if(x){let I=crypto.getRandomValues(new Uint8Array(12));u[ge]=l(I),u[Ie]=l(yield crypto.subtle.encrypt({iv:I,name:m},x,new TextEncoder().encode(p)))}else return f.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(et(u,Ze)),!0}),ce=n=>N&&N===_&&G(n,{server:!0}),ct=(n,s)=>s&&G(n,{receiver:s}),ye=(n,s=6)=>{if(!ne.has(n))return!1;let y=ne.get(n),a="";for(let p=0;p<s;p++){let u=y[p]%Re.length;a+=Re[u]}return a};return{onConnection:Pe,onError:f,onMessage:Ke,onRoomJoin:Te,onRoomLeave:we,onUserJoin:xe,onUserLeave:De,onUserVerified:se,onUserVerificationCode:Ue,messageRoom:n=>G(n),messageServer:ce,messageUser:ct,closeRoom:()=>ce({type:je}),createRoom:(...s)=>M(null,[...s],function*(n={}){if(D&&D!==H)return;U(de);try{yield new Promise((u,I)=>{let g=new Worker(URL.createObjectURL(new Blob([nt],{type:"text/javascript"})));g.addEventListener("message",h=>{h.data.success?(x=h.data.sharedKey,u()):I(new Error(h.data.error)),g.terminate()}),g.addEventListener("error",h=>{I(h),g.terminate()}),g.postMessage({type:"SHARED_KEY"})})}catch(u){U(H),f.dispatch({error:u});return}let y=new URL(k+c);n.limit&&y.searchParams.append("limit",n.limit);let a=yield fetch(y.toString(),{method:"GET",headers:{Accept:t}});if(!a.ok)throw new Error("Failed to create room");let p=yield a.text();return p=e(p),N=p.userId,ve(p.roomCode,p.creatorSecret),p}),joinRoom:n=>ve(n),leaveRoom:ae,kickUser:n=>ce({type:ze,userId:n}),getVerificationCode:ye,verifyUser:(n,s)=>M(null,null,function*(){if(N!==_||!s)return!1;let y=ye(n,s.length);if(!y||!s||y!==s)return!1;let a=L.get(n);if(!a)return!1;let p=crypto.getRandomValues(new Uint8Array(12));return G({type:Q,sharedKey:l(yield crypto.subtle.encrypt({iv:p,name:m},a,yield crypto.subtle.exportKey("raw",x))),sharedKeyIv:l(p)},{receiver:n}),se.dispatch({userId:n}),ce({type:_e,userId:n}),!0})}};export{xt as createClientConnector};
