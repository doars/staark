var Nt=Object.defineProperty,mt=Object.defineProperties;var It=Object.getOwnPropertyDescriptors;var Qe=Object.getOwnPropertySymbols;var gt=Object.prototype.hasOwnProperty,Ct=Object.prototype.propertyIsEnumerable;var Ze=(r,t,e)=>t in r?Nt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,qe=(r,t)=>{for(var e in t||(t={}))gt.call(t,e)&&Ze(r,e,t[e]);if(Qe)for(var e of Qe(t))Ct.call(t,e)&&Ze(r,e,t[e]);return r},$e=(r,t)=>mt(r,It(t));var G=(r,t,e)=>new Promise((p,a)=>{var R=O=>{try{L(e.next(O))}catch(j){a(j)}},B=O=>{try{L(e.throw(O))}catch(j){a(j)}},L=O=>O.done?p(O.value):Promise.resolve(O.value).then(R,B);L((e=e.apply(r,t)).next())});var Ie="CONNECTED",ge="CONNECTING",Y="DISCONNECTED",Ce="DISCONNECTING",et="PENDING_VERIFICATION";var be="_X0",le="_X1",he="_X2",Se="_X3",Ae="_X4",tt="_RC",rt="_RJ";var st="_UJ",nt="_UK",ot="_UL",Oe="_UV";var Te="ABCDEFGHKMNPQRSTUVWXYZ23456789";var l=r=>{let t=atob(r);return Uint8Array.from(t,e=>e.charCodeAt(0)).buffer},at=r=>{let t=atob(r),e=Uint8Array.from(t,p=>p.charCodeAt(0));return new TextDecoder().decode(e)},ct=r=>{let t=new TextEncoder().encode(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",p=65536;for(let a=0;a<t.length;a+=p){let R=t.subarray(a,a+p);e+=String.fromCharCode(...R)}return btoa(e)},f=r=>{let t=new Uint8Array(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",p=65536;for(let a=0;a<t.length;a+=p){let R=t.subarray(a,a+p);e+=String.fromCharCode(...R)}return btoa(e)};var S=()=>{let r=new Map;return{addListener:(t,e)=>{r.has(t)||r.set(t,e)},removeListener:t=>{r.delete(t)},dispatch:t=>{for(let[e,p]of r.entries())e(t),p&&p.once&&r.delete(e)}}};var it="|",pt=":",Et=(r,t)=>{let e=[];for(let p in r){let a=r[p];a!=null&&e.push(p+pt+t(String(a)))}return e.join(it)},yt=(r,t)=>{let e={},p=r.split(it);for(let a of p){let R=a.indexOf(pt);if(R>0){let B=a.substring(0,R),L=a.substring(R+1);e[B]=t(L)}}return e};var ut=(r,t)=>{let e=Date.now();if(!r)return{delay:0,offset:0,adjusted:e};if(!t){let R=r-e;return{delay:0,offset:R,adjusted:e+R}}let p=e-t,a=(r-t+(r-e))/2;return{delay:p,offset:a,adjusted:e-p+a}};var se="ECDH",we="P-256",ne="raw",X="SHA-256",oe="spki",A="AES-GCM";var ae="RSA-OAEP",K="RSASSA-PKCS1-v1_5",dt="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([r,t,e])=>{Promise.all([crypto.subtle.exportKey("spki",r.publicKey),crypto.subtle.exportKey("spki",t.publicKey)]).then(([p,a])=>{self.postMessage({success:!0,myEncryptKeys:r,mySignKeys:t,myExchangeKeys:e,myPublicEncryptKey:p,myPublicSignKey:a})}).catch(p=>{self.postMessage({success:!1,error:p.message})})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")",lt="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(r=>{self.postMessage({success:!0,sharedKey:r})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")";var Ke="S",ft="T",xe="E",De="I",Pe="U",Ue="D",ve="V",Le="K",Me="P",He="G";var Yt=(r={})=>{let{contentType:t="application/json",deserializeMessage:e=JSON.parse,serializeMessage:p=JSON.stringify,createRoomEndpoint:a="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:B="http://localhost:3000",wsUrl:L="http://localhost:3000",messageBufferMaxCount:O=50,messageBufferMaxDuration:j=60*1e3}=r,x=Y,E,D,J,fe,k,N,ce,ie,z,_e,W,T,M,pe,P,C=[],b,V=new Map,Q=new Map,Z=new Map,Ee=new Map,Re=new Map,H=()=>(!D&&!J&&(J=new Promise((n,o)=>{let u=new Worker(URL.createObjectURL(new Blob([dt],{type:"text/javascript"})));u.addEventListener("message",c=>{if(c.data.success)fe=c.data.myEncryptKeys,z=c.data.mySignKeys,k=c.data.myExchangeKeys,ce=c.data.myPublicEncryptKey,ie=c.data.myPublicSignKey,D=!0,J=null,n();else{let y=new Error(c.data.error);_.dispatch({error:y}),o(y)}u.terminate()}),u.addEventListener("error",c=>{_.dispatch({error:c}),o(c),u.terminate()}),u.postMessage({type:"USER_KEYS"})})),J);H();let _=S(),Ge=S(),Ye=S(),ke=S(),Ve=S(),Fe=S(),ye=S(),Xe=S(),Be=S(),U=n=>{x!==n&&(x=n,Be.dispatch({state:n}))},je=n=>G(null,null,function*(){let o=V.get(n);o&&(Ee.set(n,Array.from(new Uint8Array(yield crypto.subtle.digest(X,new TextEncoder().encode(pe+f(yield crypto.subtle.exportKey("raw",o))))))),Xe.dispatch({userId:n,code:me(n)}))}),F=()=>{x===Y||x===Ce||(U(Ce),b&&b.close(),E=D=J=N=fe=k=ce=ie=z=_e=W=T=M=P=C=b=null,V.clear(),Q.clear(),Z.clear(),Ee.clear(),Re.clear(),H(),U(Y))},Ne=n=>ue({type:nt,userId:n}),Je=(n,o=null)=>{if(!o&&x&&x!==Y)return;U(ge),pe=n;let u=new URL(L+R);u.searchParams.append("code",pe),o&&u.searchParams.append("creator",o),b=new WebSocket(u.toString()),b.addEventListener("close",c=>{ke.dispatch({event:c}),F()}),b.addEventListener("error",c=>{_.dispatch({event:c}),F()}),b.addEventListener("message",c=>G(null,null,function*(){ze(yt(c.data,at),c.data)}))},ze=(n,o,u=!1)=>G(null,null,function*(){let{[Ke]:c,[ft]:y,[De]:d,[xe]:h,[Ue]:m,[ve]:I,[Le]:q,[Me]:$,[He]:We,[Pe]:ee}=n,s,te,de;if(c?de=c:m?de=m:de=o,h){if(!P||!u&&C.length>0){C.push({time:Date.now(),parts:n,raw:o}),C.length>O&&C.shift();return}if(!d){_.dispatch(new Error("Missing IV to decrypt message"));return}s=yield crypto.subtle.decrypt({iv:l(d),name:A},P,l(h)),s=new TextDecoder().decode(s)}else if($){if(!We||!q||!I){_.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}D||(yield H());let i=l($),g=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:l(I),name:A},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ae},fe.privateKey,l(q)),{name:A},!0,["encrypt","decrypt"]),i)));if(g.type===le)te=g;else{let w=g.sender;if(!w){_.dispatch({error:new Error("Message from unknown sender")});return}let re=Z.get(w);if(!re){_.dispatch({error:new Error("No public key for "+w)});return}if(!(yield crypto.subtle.verify(K,re,l(We),i))){_.dispatch({error:new Error("Invalid signature from "+w)});return}te=g}}else s=de;if(!te)try{te=e(s)}catch(i){_.dispatch({error:new Error("Failed to parse message "+o)});return}switch(s=te,s.type){case rt:if(E=s.creatorId,N=s.userId,Ye.dispatch({creatorId:s.creatorId,roomCode:pe,userId:s.userId,users:s.users}),N===E)U(Ie);else{U(et),D||(yield H());let i=yield crypto.subtle.exportKey(ne,k.publicKey);v({type:be,publicData:typeof T=="function"?T():T,publicEncryptKey:f(ce),publicExchangeKey:f(i),publicSignKey:f(ie),signature:f(yield crypto.subtle.sign(K,z.privateKey,i))},{allowUnencrypted:!0,receiver:E})}break;case be:if(ee===E&&N===E){let i=s.sender;if(M&&!M({data:s.publicData,userId:i})){Ne(i);return}Q.set(i,yield crypto.subtle.importKey(oe,l(s.publicEncryptKey),{hash:X,name:ae},!0,["encrypt"]));let g=yield crypto.subtle.importKey(oe,l(s.publicSignKey),{hash:X,name:K},!0,["verify"]),w=l(s.publicExchangeKey);if(!(yield crypto.subtle.verify(K,g,l(s.signature),w))){_.dispatch({error:new Error("Invalid signature for exchange from "+i)});return}Z.set(i,g),D||(yield H()),V.set(i,yield crypto.subtle.deriveKey({name:se,public:yield crypto.subtle.importKey(ne,w,{name:se,namedCurve:we},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"]));let re=yield crypto.subtle.exportKey(ne,k.publicKey);v({type:le,publicData:typeof T=="function"?T():T,publicEncryptKey:f(ce),publicExchangeKey:f(re),publicSignKey:f(ie),signature:f(yield crypto.subtle.sign(K,z.privateKey,re))},{receiver:i}),je(i)}break;case le:if(ee===N&&s.sender===E){if(M&&!M({data:s.publicData,userId:E})){F();return}let i=yield crypto.subtle.importKey(oe,l(s.publicSignKey),{hash:X,name:K},!0,["verify"]);if(s.publicExchangeKey&&s.signature&&!(yield crypto.subtle.verify(K,i,l(s.signature),l(s.publicExchangeKey)))){_.dispatch({error:new Error("Invalid signature for exchange from "+E)}),F();return}Z.set(E,i),Q.set(E,yield crypto.subtle.importKey(oe,l(s.publicEncryptKey),{hash:X,name:ae},!0,["encrypt"])),D||(yield H()),V.set(E,yield crypto.subtle.deriveKey({name:se,public:yield crypto.subtle.importKey(ne,l(s.publicExchangeKey),{name:se,namedCurve:we},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"])),je(E)}break;case he:if(ee===N&&s.sender===E){if(W&&!W({data:s.privateData,userId:E})){F();return}v({type:Se,privateData:_e},{receiver:E})}break;case Se:if(ee===E&&N===E){let i=s.sender;if(!Re.get(i)||W&&!W({data:s.privateData,userId:i})){Ne(i);return}v({type:Ae,sharedKey:f(yield crypto.subtle.exportKey("raw",P))},{receiver:i}),ye.dispatch({userId:i}),ue({type:Oe,userId:i})}break;case Ae:if(ee===N&&s.sender===E){if(P=yield crypto.subtle.importKey("raw",l(s.sharedKey),{name:A},!0,["encrypt","decrypt"]),ye.dispatch({userId:N}),C.length>0){let i=Date.now();for(C=C.filter(g=>i-g.time<j);C.length>0;){let{parts:g,raw:w}=C.shift();ze(g,w,!0)}}U(Ie)}break;case ot:Fe.dispatch({userId:s.userId}),V.delete(s.userId),Q.delete(s.userId),Z.delete(s.userId);break;case st:Ve.dispatch({userId:s.userId});break;case Oe:ye.dispatch({userId:s.userId});break;default:Ge.dispatch({data:s,time:ut(y,s==null?void 0:s.senderTime)});break}}),v=(u,...c)=>G(null,[u,...c],function*(n,o={}){if(!b||b.readyState!==WebSocket.OPEN)return _.dispatch({error:new Error("No open socket")}),!1;let y=p($e(qe({},n),{sender:N,senderTime:Date.now()})),d={},h=o.receiver;if(h){let m=Q.get(h);if(m){let I=yield crypto.subtle.generateKey({name:A,length:256},!0,["encrypt","decrypt"]),q=crypto.getRandomValues(new Uint8Array(12)),$=yield crypto.subtle.encrypt({iv:q,name:A},I,new TextEncoder().encode(y));D||(yield H()),d[ve]=f(q),d[Le]=f(yield crypto.subtle.encrypt({name:ae},m,yield crypto.subtle.exportKey("raw",I))),d[Me]=f($),d[He]=f(yield crypto.subtle.sign(K,z.privateKey,$))}else if(o.allowUnencrypted)d[Ue]=y;else return _.dispatch({error:new Error("No public key for "+h)}),!1;d[Pe]=h}else if(o.server)d[Ke]=y;else if(P){let m=crypto.getRandomValues(new Uint8Array(12));d[De]=f(m),d[xe]=f(yield crypto.subtle.encrypt({iv:m,name:A},P,new TextEncoder().encode(y)))}else return _.dispatch(new Error("Trying to send without valid destination")),!1;return b.send(Et(d,ct)),!0}),ue=n=>N&&N===E&&v(n,{server:!0}),Rt=(n,o)=>o&&v(n,{receiver:o}),me=(n,o=6)=>{if(!Ee.has(n))return!1;let u=Ee.get(n),c="";for(let y=0;y<o;y++){let d=u[y]%Te.length;c+=Te[d]}return c};return{onConnection:Be,onError:_,onMessage:Ge,onRoomJoin:Ye,onRoomLeave:ke,onUserJoin:Ve,onUserLeave:Fe,onUserVerified:ye,onUserVerificationCode:Xe,messageRoom:n=>v(n),messageServer:ue,messageUser:Rt,closeRoom:()=>ue({type:tt}),createRoom:(...o)=>G(null,[...o],function*(n={}){if(x&&x!==Y)return;U(ge),n.publicData&&(T=n.publicData),n.verifyPublicData&&(M=n.verifyPublicData);try{yield new Promise((d,h)=>{let m=new Worker(URL.createObjectURL(new Blob([lt],{type:"text/javascript"})));m.addEventListener("message",I=>{I.data.success?(P=I.data.sharedKey,d()):h(new Error(I.data.error)),m.terminate()}),m.addEventListener("error",I=>{h(I),m.terminate()}),m.postMessage({type:"SHARED_KEY"})})}catch(d){U(Y),_.dispatch({error:d});return}let u=new URL(B+a);n.limit&&u.searchParams.append("limit",n.limit);let c=yield fetch(u.toString(),{method:"GET",headers:{Accept:t}});if(!c.ok)throw new Error("Failed to create room");let y=yield c.text();return y=e(y),N=y.userId,Je(y.roomCode,y.creatorSecret),y}),joinRoom:(n,o={})=>{o.publicData&&(T=o.publicData),o.verifyPublicData&&(M=o.verifyPublicData),Je(n)},leaveRoom:F,kickUser:Ne,getVerificationCode:me,verifyUser:(n,o)=>G(null,null,function*(){if(N!==E||!o)return!1;let u=me(n,o.length);return!u||!o||u!==o||(Re.set(n,!0),!V.get(n))?!1:(v({type:he,privateData:_e},{receiver:n}),!0)})}};export{Yt as createClientConnector};
