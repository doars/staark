var yt=Object.defineProperty,ut=Object.defineProperties;var dt=Object.getOwnPropertyDescriptors;var ve=Object.getOwnPropertySymbols;var lt=Object.prototype.hasOwnProperty,ft=Object.prototype.propertyIsEnumerable;var He=(r,t,e)=>t in r?yt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,Ge=(r,t)=>{for(var e in t||(t={}))lt.call(t,e)&&He(r,e,t[e]);if(ve)for(var e of ve(t))ft.call(t,e)&&He(r,e,t[e]);return r},Ye=(r,t)=>ut(r,dt(t));var H=(r,t,e)=>new Promise((p,a)=>{var R=T=>{try{M(e.next(T))}catch(J){a(J)}},j=T=>{try{M(e.throw(T))}catch(J){a(J)}},M=T=>T.done?p(T.value):Promise.resolve(T.value).then(R,j);M((e=e.apply(r,t)).next())});var me="CONNECTED",ge="CONNECTING",G="DISCONNECTED",he="DISCONNECTING",ke="PENDING_VERIFICATION";var Ce="ABCDEFGHKMNPQRSTUVWXYZ23456789";var f=r=>{let t=atob(r);return Uint8Array.from(t,e=>e.charCodeAt(0)).buffer},Fe=r=>{let t=atob(r),e=Uint8Array.from(t,p=>p.charCodeAt(0));return new TextDecoder().decode(e)},Ve=r=>{let t=new TextEncoder().encode(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",p=65536;for(let a=0;a<t.length;a+=p){let R=t.subarray(a,a+p);e+=String.fromCharCode(...R)}return btoa(e)},_=r=>{let t=new Uint8Array(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",p=65536;for(let a=0;a<t.length;a+=p){let R=t.subarray(a,a+p);e+=String.fromCharCode(...R)}return btoa(e)};var S=()=>{let r=new Map;return{addListener:(t,e)=>{r.has(t)||r.set(t,e)},removeListener:t=>{r.delete(t)},dispatch:t=>{for(let[e,p]of r.entries())e(t),p&&p.once&&r.delete(e)}}};var Xe=(r,t)=>{let e=[];for(let p in r){let a=r[p];a!=null&&e.push(p+":"+t(String(a)))}return e.join("|")},Be=(r,t)=>{let e={},p=r.split("|");for(let a of p){let R=a.indexOf(":");if(R>0){let j=a.substring(0,R),M=a.substring(R+1);e[j]=t(M)}}return e};var je=(r,t)=>{let e=Date.now();if(!r)return{delay:0,offset:0,adjusted:e};if(!t){let R=r-e;return{delay:0,offset:R,adjusted:e+R}}let p=e-t,a=(r-t+(r-e))/2;return{delay:p,offset:a,adjusted:e-p+a}};var re="ECDH",be="P-256";var B="SHA-256",ne="spki",A="AES-GCM";var se="RSA-OAEP",Y="RSASSA-PKCS1-v1_5",Je="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([r,t,e])=>{Promise.all([crypto.subtle.exportKey("spki",r.publicKey),crypto.subtle.exportKey("spki",t.publicKey)]).then(([p,a])=>{self.postMessage({success:!0,myEncryptKeys:r,mySignKeys:t,myExchangeKeys:e,myPublicEncryptKey:p,myPublicSignKey:a})}).catch(p=>{self.postMessage({success:!1,error:p.message})})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")",ze="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(r=>{self.postMessage({success:!0,sharedKey:r})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")";var Gt=(r={})=>{let{contentType:t="application/json",deserializeMessage:e=JSON.parse,serializeMessage:p=JSON.stringify,createRoomEndpoint:a="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:j="http://localhost:3000",wsUrl:M="http://localhost:3000",messageBufferMaxCount:T=50,messageBufferMaxDuration:J=60*1e3}=r,K=G,y,x,z,fe,k,N,oe,ae,_e,Re,W,w,L,ce,D,h=[],C,F=new Map,Q=new Map,Z=new Map,ie=new Map,Ne=new Map,v=()=>(!x&&!z&&(z=new Promise((s,o)=>{let d=new Worker(URL.createObjectURL(new Blob([Je],{type:"text/javascript"})));d.addEventListener("message",c=>{if(c.data.success)fe=c.data.myEncryptKeys,_e=c.data.mySignKeys,k=c.data.myExchangeKeys,oe=c.data.myPublicEncryptKey,ae=c.data.myPublicSignKey,x=!0,z=null,s();else{let u=new Error(c.data.error);E.dispatch({error:u}),o(u)}d.terminate()}),d.addEventListener("error",c=>{E.dispatch({error:c}),o(c),d.terminate()}),d.postMessage({type:"USER_KEYS"})})),z);v();let E=S(),Ae=S(),Te=S(),we=S(),Oe=S(),Ke=S(),pe=S(),xe=S(),De=S(),P=s=>{K!==s&&(K=s,De.dispatch({state:s}))},Pe=s=>H(null,null,function*(){let o=F.get(s);o&&(ie.set(s,Array.from(new Uint8Array(yield crypto.subtle.digest(B,new TextEncoder().encode(ce+_(yield crypto.subtle.exportKey("raw",o))))))),xe.dispatch({userId:s,code:Ie(s)}))}),V=()=>{K===G||K===he||(P(he),C&&C.close(),y=x=z=N=fe=k=oe=ae=_e=Re=W=w=L=D=h=C=null,F.clear(),Q.clear(),Z.clear(),ie.clear(),Ne.clear(),v(),P(G))},Ee=s=>ye({type:"_UK",userId:s}),Ue=(s,o=null)=>{if(!o&&K&&K!==G)return;P(ge),ce=s;let d=new URL(M+R);d.searchParams.append("code",ce),o&&d.searchParams.append("creator",o),C=new WebSocket(d.toString()),C.addEventListener("close",c=>{we.dispatch({event:c}),V()}),C.addEventListener("error",c=>{E.dispatch({event:c}),V()}),C.addEventListener("message",c=>H(null,null,function*(){Me(Be(c.data,Fe),c.data)}))},Me=(s,o,d=!1)=>H(null,null,function*(){let{["S"]:c,["T"]:u,["I"]:l,["E"]:b,["D"]:I,["V"]:m,["K"]:q,["P"]:$,["G"]:Le,["U"]:ee}=s,n,te,ue,X;if(c?ue=c:I?ue=I:ue=o,b){if(!D||!d&&h.length>0){h.push({time:Date.now(),parts:s,raw:o}),h.length>T&&h.shift();return}if(!l){E.dispatch(new Error("Missing IV to decrypt message"));return}n=yield crypto.subtle.decrypt({iv:f(l),name:A},D,f(b)),n=new TextDecoder().decode(n),X=!0}else if($){if(!q||!m){E.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}x||(yield v());let i=f($),g=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:f(m),name:A},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:se},fe.privateKey,f(q)),{name:A},!0,["encrypt","decrypt"]),i)));if(X=!0,g.type==="_X1")te=g;else if(Le){let O=g.sender;if(!O){E.dispatch({error:new Error("Message from unknown sender")});return}let de=Z.get(O);if(!de){E.dispatch({error:new Error("No public key for "+O)});return}if(!(yield crypto.subtle.verify(Y,de,f(Le),i))){E.dispatch({error:new Error("Invalid signature from "+O)});return}te=g}else{E.dispatch({error:new Error("Missing encryption signature")});return}}else n=ue;if(!te)try{te=e(n)}catch(i){E.dispatch({error:new Error("Failed to parse message "+o)});return}switch(n=te,n.type){case"_RJ":if(y=n.creatorId,N=n.userId,Te.dispatch({creatorId:n.creatorId,roomCode:ce,userId:n.userId,users:n.users}),N===y)P(me);else{P(ke),x||(yield v());let i=yield crypto.subtle.exportKey("raw",k.publicKey);U({type:"_X0",publicData:typeof w=="function"?w():w,publicEncryptKey:_(oe),publicExchangeKey:_(i),publicSignKey:_(ae)},{allowUnencrypted:!0,receiver:y})}break;case"_X0":if(ee===y&&N===y){let i=n.sender;if(L&&!L({data:n.publicData,userId:i})){Ee(i);return}Q.set(i,yield crypto.subtle.importKey(ne,f(n.publicEncryptKey),{hash:B,name:se},!0,["encrypt"]));let g=yield crypto.subtle.importKey(ne,f(n.publicSignKey),{hash:B,name:Y},!0,["verify"]),O=f(n.publicExchangeKey);if(!(yield crypto.subtle.verify(Y,g,f(n.signature),O))){E.dispatch({error:new Error("Invalid signature for exchange from "+i)});return}Z.set(i,g),x||(yield v()),F.set(i,yield crypto.subtle.deriveKey({name:re,public:yield crypto.subtle.importKey("raw",O,{name:re,namedCurve:be},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"]));let de=yield crypto.subtle.exportKey("raw",k.publicKey);U({type:"_X1",publicData:typeof w=="function"?w():w,publicEncryptKey:_(oe),publicExchangeKey:_(de),publicSignKey:_(ae)},{receiver:i}),Pe(i)}break;case"_X1":if(ee===N&&n.sender===y){if(L&&!L({data:n.publicData,userId:y})){V();return}let i=yield crypto.subtle.importKey(ne,f(n.publicSignKey),{hash:B,name:Y},!0,["verify"]);if(n.publicExchangeKey&&n.signature&&!(yield crypto.subtle.verify(Y,i,f(n.signature),f(n.publicExchangeKey)))){E.dispatch({error:new Error("Invalid signature for exchange from "+y)}),V();return}Z.set(y,i),Q.set(y,yield crypto.subtle.importKey(ne,f(n.publicEncryptKey),{hash:B,name:se},!0,["encrypt"])),x||(yield v()),F.set(y,yield crypto.subtle.deriveKey({name:re,public:yield crypto.subtle.importKey("raw",f(n.publicExchangeKey),{name:re,namedCurve:be},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"])),Pe(y)}break;case"_X2":if(ee===N&&n.sender===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}if(W&&!W({data:n.privateData,userId:y})){V();return}U({type:"_X3",privateData:Re},{receiver:y})}break;case"_X3":if(ee===y&&N===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}let i=n.sender;if(!Ne.get(i)){E.dispatch({error:new Error("User not verified")}),Ee(i);return}if(W&&!W({data:n.privateData,userId:i})){Ee(i);return}U({type:"_X4",sharedKey:_(yield crypto.subtle.exportKey("raw",D))},{receiver:i}),pe.dispatch({userId:i}),ye({type:"_UV",userId:i})}break;case"_X4":if(ee===N&&n.sender===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}if(D=yield crypto.subtle.importKey("raw",f(n.sharedKey),{name:A},!0,["encrypt","decrypt"]),pe.dispatch({userId:N}),h.length>0){let i=Date.now();for(h=h.filter(g=>i-g.time<J);h.length>0;){let{parts:g,raw:O}=h.shift();Me(g,O,!0)}}P(me)}break;case"_UL":Ke.dispatch({userId:n.userId}),F.delete(n.userId),Q.delete(n.userId),Z.delete(n.userId);break;case"_UJ":Oe.dispatch({userId:n.userId});break;case"_UV":pe.dispatch({userId:n.userId});break;default:if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}Ae.dispatch({data:n,time:je(u,n==null?void 0:n.senderTime)});break}}),U=(d,...c)=>H(null,[d,...c],function*(s,o={}){if(!C||C.readyState!==WebSocket.OPEN)return E.dispatch({error:new Error("No open socket")}),!1;let u=p(Ye(Ge({},s),{sender:N,senderTime:Date.now()})),l={},b=o.receiver;if(b){let I=Q.get(b);if(I){let m=yield crypto.subtle.generateKey({name:A,length:256},!0,["encrypt","decrypt"]),q=crypto.getRandomValues(new Uint8Array(12)),$=yield crypto.subtle.encrypt({iv:q,name:A},m,new TextEncoder().encode(u));x||(yield v()),l["V"]=_(q),l["K"]=_(yield crypto.subtle.encrypt({name:se},I,yield crypto.subtle.exportKey("raw",m))),l["P"]=_($),l["G"]=_(yield crypto.subtle.sign(Y,_e.privateKey,$))}else if(o.allowUnencrypted)l["D"]=u;else return E.dispatch({error:new Error("No public key for "+b)}),!1;l["U"]=b}else if(o.server)l["S"]=u;else if(D){let I=crypto.getRandomValues(new Uint8Array(12));l["I"]=_(I),l["E"]=_(yield crypto.subtle.encrypt({iv:I,name:A},D,new TextEncoder().encode(u)))}else return E.dispatch(new Error("Trying to send without valid destination")),!1;return C.send(Xe(l,Ve)),!0}),ye=s=>N&&N===y&&U(s,{server:!0}),Et=(s,o)=>o&&U(s,{receiver:o}),Ie=(s,o=6)=>{if(!ie.has(s))return!1;let d=ie.get(s),c="";for(let u=0;u<o;u++){let l=d[u]%Ce.length;c+=Ce[l]}return c};return{onConnection:De,onError:E,onMessage:Ae,onRoomJoin:Te,onRoomLeave:we,onUserJoin:Oe,onUserLeave:Ke,onUserVerified:pe,onUserVerificationCode:xe,messageRoom:s=>U(s),messageServer:ye,messageUser:Et,closeRoom:()=>ye({type:"_RC"}),createRoom:(...o)=>H(null,[...o],function*(s={}){if(K&&K!==G)return;P(ge),s.publicData&&(w=s.publicData),s.verifyPublicData&&(L=s.verifyPublicData);try{yield new Promise((l,b)=>{let I=new Worker(URL.createObjectURL(new Blob([ze],{type:"text/javascript"})));I.addEventListener("message",m=>{m.data.success?(D=m.data.sharedKey,l()):b(new Error(m.data.error)),I.terminate()}),I.addEventListener("error",m=>{b(m),I.terminate()}),I.postMessage({type:"SHARED_KEY"})})}catch(l){P(G),E.dispatch({error:l});return}let d=new URL(j+a);s.limit&&d.searchParams.append("limit",s.limit);let c=yield fetch(d.toString(),{method:"GET",headers:{Accept:t}});if(!c.ok)throw new Error("Failed to create room");let u=yield c.text();return u=e(u),N=u.userId,Ue(u.roomCode,u.creatorSecret),u}),joinRoom:(s,o={})=>{o.publicData&&(w=o.publicData),o.verifyPublicData&&(L=o.verifyPublicData),Ue(s)},leaveRoom:V,kickUser:Ee,getVerificationCode:Ie,verifyUser:(s,o)=>H(null,null,function*(){if(N!==y||!o)return!1;let d=Ie(s,o.length);return!d||!o||d!==o||(Ne.set(s,!0),!F.get(s))?!1:(U({type:"_X2",privateData:Re},{receiver:s}),!0)})}};export{Gt as createClientConnector};
