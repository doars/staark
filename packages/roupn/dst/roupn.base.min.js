var Ux="CONNECTED",Bx="CONNECTING",l="DISCONNECTED",Gx="DISCONNECTING",tx="PENDING_VERIFICATION";var bx="_X0",jx="_X1",Lx="_X2",Mx="_X3",Px="_X4",sx="_RC",ax="_RJ";var rx="_UJ",ex="_UK",x6="_UL",Hx="_UV";var Cx="ABCDEFGHKMNPQRSTUVWXYZ23456789";var k=(W)=>{let Z=atob(W);return Uint8Array.from(Z,(J)=>J.charCodeAt(0)).buffer},q6=(W)=>{let Z=atob(W),J=Uint8Array.from(Z,(X)=>X.charCodeAt(0));return new TextDecoder().decode(J)},$6=(W)=>{let Z=new TextEncoder().encode(W);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let J="",X=65536;for(let j=0;j<Z.length;j+=X){let G=Z.subarray(j,j+X);J+=String.fromCharCode(...G)}return btoa(J)},h=(W)=>{let Z=new Uint8Array(W);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let J="",X=65536;for(let j=0;j<Z.length;j+=X){let G=Z.subarray(j,j+X);J+=String.fromCharCode(...G)}return btoa(J)};var C=()=>{let W=new Map;return{addListener:(Z,J)=>{if(!W.has(Z))W.set(Z,J)},removeListener:(Z)=>{W.delete(Z)},dispatch:(Z)=>{for(let[J,X]of W.entries())if(J(Z),X&&X.once)W.delete(J)}}};var Q6=(W,Z)=>{let J=[];for(let X in W){let j=W[X];if(j!==null&&j!==void 0)J.push(X+":"+Z(String(j)))}return J.join("|")},W6=(W,Z)=>{let J={},X=W.split("|");for(let j of X){let G=j.indexOf(":");if(G>0){let Fx=j.substring(0,G),Yx=j.substring(G+1);J[Fx]=Z(Yx)}}return J};var Z6=(W,Z)=>{let J=Date.now();if(!W)return{delay:0,offset:0,adjusted:J};if(!Z){let G=W-J;return{delay:0,offset:G,adjusted:J+G}}let X=J-Z,j=(W-Z+(W-J))/2;return{delay:X,offset:j,adjusted:J-X+j}};var t="ECDH",Dx="P-256",s="raw",c="SHA-256",a="spki",D="AES-GCM",Ox=256,r="RSA-OAEP",m="RSASSA-PKCS1-v1_5",J6="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([W,Z,J])=>{Promise.all([crypto.subtle.exportKey("spki",W.publicKey),crypto.subtle.exportKey("spki",Z.publicKey)]).then(([X,j])=>{self.postMessage({success:!0,myEncryptKeys:W,mySignKeys:Z,myExchangeKeys:J,myPublicEncryptKey:X,myPublicSignKey:j})}).catch((X)=>{self.postMessage({success:!1,error:X.message})})}).catch((W)=>{self.postMessage({success:!1,error:W.message})})}).toString()+")",z6="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then((W)=>{self.postMessage({success:!0,sharedKey:W})}).catch((W)=>{self.postMessage({success:!1,error:W.message})})}).toString()+")";var fx="S",X6="T",Ax="E",Sx="I",vx="U",Nx="D",gx="V",mx="K",px="P",Kx="G";var A6=(W={})=>{let{contentType:Z="application/json",deserializeMessage:J=JSON.parse,serializeMessage:X=JSON.stringify,createRoomEndpoint:j="/create-room",joinRoomEndpoint:G="/join-room",httpUrl:Fx="http://localhost:3000",wsUrl:Yx="http://localhost:3000",messageBufferMaxCount:j6=50,messageBufferMaxDuration:F6=60000}=W,A=l,w,S,E,wx,T,U,e,xx,qx,Vx,y,O,p,$x,v,P=[],H,R=new Map,d=new Map,n=new Map,Qx=new Map,kx=new Map,K=()=>{if(!S&&!E)E=new Promise((x,Q)=>{let F=new Worker(URL.createObjectURL(new Blob([J6],{type:"text/javascript"})));F.addEventListener("message",(q)=>{if(q.data.success)wx=q.data.myEncryptKeys,qx=q.data.mySignKeys,T=q.data.myExchangeKeys,e=q.data.myPublicEncryptKey,xx=q.data.myPublicSignKey,S=!0,E=null,x();else{let V=Error(q.data.error);Y.dispatch({error:V}),Q(V)}F.terminate()}),F.addEventListener("error",(q)=>{Y.dispatch({error:q}),Q(q),F.terminate()}),F.postMessage({type:"USER_KEYS"})});return E};K();let Y=C(),lx=C(),Tx=C(),Rx=C(),ux=C(),Ix=C(),Wx=C(),cx=C(),Ex=C(),N=(x)=>{if(A!==x)A=x,Ex.dispatch({state:x})},yx=async(x)=>{let Q=R.get(x);if(!Q)return;Qx.set(x,Array.from(new Uint8Array(await crypto.subtle.digest(c,new TextEncoder().encode($x+h(await crypto.subtle.exportKey("raw",Q))))))),cx.dispatch({userId:x,code:hx(x)})},u=()=>{if(A===l||A===Gx)return;if(N(Gx),H)H.close();w=S=E=U=wx=T=e=xx=qx=Vx=y=O=p=v=P=H=null,R.clear(),d.clear(),n.clear(),Qx.clear(),kx.clear(),K(),N(l)},Zx=(x)=>Jx({type:ex,userId:x}),dx=(x,Q=null)=>{if(!Q&&A&&A!==l)return;N(Bx),$x=x;let F=new URL(Yx+G);if(F.searchParams.append("code",$x),Q)F.searchParams.append("creator",Q);H=new WebSocket(F.toString()),H.addEventListener("close",(q)=>{Rx.dispatch({event:q}),u()}),H.addEventListener("error",(q)=>{Y.dispatch({event:q}),u()}),H.addEventListener("message",async(q)=>{nx(W6(q.data,q6),q.data)})},nx=async(x,Q,F=!1)=>{let{[fx]:q,[X6]:V,[Sx]:B,[Ax]:b,[Nx]:L,[gx]:_,[mx]:_x,[px]:ix,[Kx]:ox,[vx]:i}=x,$,o,zx,I;if(q)zx=q;else if(L)zx=L;else zx=Q;if(b){if(!v||!F&&P.length>0){if(P.push({time:Date.now(),parts:x,raw:Q}),P.length>j6)P.shift();return}if(!B){Y.dispatch(Error("Missing IV to decrypt message"));return}$=await crypto.subtle.decrypt({iv:k(B),name:D},v,k(b)),$=new TextDecoder().decode($),I=!0}else if(ix){if(!_x||!_){Y.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!S)await K();let z=k(ix),M=J(new TextDecoder().decode(await crypto.subtle.decrypt({iv:k(_),name:D},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:r},wx.privateKey,k(_x)),{name:D},!0,["encrypt","decrypt"]),z)));if(I=!0,M.type===jx)o=M;else if(ox){let f=M.sender;if(!f){Y.dispatch({error:Error("Message from unknown sender")});return}let Xx=n.get(f);if(!Xx){Y.dispatch({error:Error("No public key for "+f)});return}if(!await crypto.subtle.verify(m,Xx,k(ox),z)){Y.dispatch({error:Error("Invalid signature from "+f)});return}o=M}else{Y.dispatch({error:Error("Missing encryption signature")});return}}else $=zx;if(!o)try{o=J($)}catch(z){Y.dispatch({error:Error("Failed to parse message "+Q)});return}switch($=o,$.type){case ax:if(w=$.creatorId,U=$.userId,Tx.dispatch({creatorId:$.creatorId,roomCode:$x,userId:$.userId,users:$.users}),U===w)N(Ux);else{if(N(tx),!S)await K();let z=await crypto.subtle.exportKey(s,T.publicKey);g({type:bx,publicData:typeof O==="function"?O():O,publicEncryptKey:h(e),publicExchangeKey:h(z),publicSignKey:h(xx),signature:h(await crypto.subtle.sign(m,qx.privateKey,z))},{allowUnencrypted:!0,receiver:w})}break;case bx:if(i===w&&U===w){let z=$.sender;if(p&&!p({data:$.publicData,userId:z})){Zx(z);return}d.set(z,await crypto.subtle.importKey(a,k($.publicEncryptKey),{hash:c,name:r},!0,["encrypt"]));let M=await crypto.subtle.importKey(a,k($.publicSignKey),{hash:c,name:m},!0,["verify"]),f=k($.publicExchangeKey);if(!await crypto.subtle.verify(m,M,k($.signature),f)){Y.dispatch({error:Error("Invalid signature for exchange from "+z)});return}if(n.set(z,M),!S)await K();R.set(z,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,f,{name:t,namedCurve:Dx},!0,[])},T.privateKey,{length:Ox,name:D},!0,["encrypt","decrypt"]));let Xx=await crypto.subtle.exportKey(s,T.publicKey);g({type:jx,publicData:typeof O==="function"?O():O,publicEncryptKey:h(e),publicExchangeKey:h(Xx),publicSignKey:h(xx)},{receiver:z}),yx(z)}break;case jx:if(i===U&&$.sender===w){if(p&&!p({data:$.publicData,userId:w})){u();return}let z=await crypto.subtle.importKey(a,k($.publicSignKey),{hash:c,name:m},!0,["verify"]);if($.publicExchangeKey&&$.signature){if(!await crypto.subtle.verify(m,z,k($.signature),k($.publicExchangeKey))){Y.dispatch({error:Error("Invalid signature for exchange from "+w)}),u();return}}if(n.set(w,z),d.set(w,await crypto.subtle.importKey(a,k($.publicEncryptKey),{hash:c,name:r},!0,["encrypt"])),!S)await K();R.set(w,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,k($.publicExchangeKey),{name:t,namedCurve:Dx},!0,[])},T.privateKey,{length:Ox,name:D},!0,["encrypt","decrypt"])),yx(w)}break;case Lx:if(i===U&&$.sender===w){if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}if(y&&!y({data:$.privateData,userId:w})){u();return}g({type:Mx,privateData:Vx},{receiver:w})}break;case Mx:if(i===w&&U===w){if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}let z=$.sender;if(!kx.get(z)){Y.dispatch({error:Error("User not verified")}),Zx(z);return}if(y&&!y({data:$.privateData,userId:z})){Zx(z);return}g({type:Px,sharedKey:h(await crypto.subtle.exportKey("raw",v))},{receiver:z}),Wx.dispatch({userId:z}),Jx({type:Hx,userId:z})}break;case Px:if(i===U&&$.sender===w){if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}if(v=await crypto.subtle.importKey("raw",k($.sharedKey),{name:D},!0,["encrypt","decrypt"]),Wx.dispatch({userId:U}),P.length>0){let z=Date.now();P=P.filter((M)=>z-M.time<F6);while(P.length>0){let{parts:M,raw:f}=P.shift();nx(M,f,!0)}}N(Ux)}break;case x6:Ix.dispatch({userId:$.userId}),R.delete($.userId),d.delete($.userId),n.delete($.userId);break;case rx:ux.dispatch({userId:$.userId});break;case Hx:Wx.dispatch({userId:$.userId});break;default:if(!I){Y.dispatch({error:Error("Message was not encrypted")});return}lx.dispatch({data:$,time:Z6(V,$?.senderTime)});break}},g=async(x,Q={})=>{if(!H||H.readyState!==WebSocket.OPEN)return Y.dispatch({error:Error("No open socket")}),!1;let F=X({...x,sender:U,senderTime:Date.now()}),q={},V=Q.receiver;if(V){let B=d.get(V);if(B){let b=await crypto.subtle.generateKey({name:D,length:256},!0,["encrypt","decrypt"]),L=crypto.getRandomValues(new Uint8Array(12)),_=await crypto.subtle.encrypt({iv:L,name:D},b,new TextEncoder().encode(F));if(!S)await K();q[gx]=h(L),q[mx]=h(await crypto.subtle.encrypt({name:r},B,await crypto.subtle.exportKey("raw",b))),q[px]=h(_),q[Kx]=h(await crypto.subtle.sign(m,qx.privateKey,_))}else if(!Q.allowUnencrypted)return Y.dispatch({error:Error("No public key for "+V)}),!1;else q[Nx]=F;q[vx]=V}else if(Q.server)q[fx]=F;else if(v){let B=crypto.getRandomValues(new Uint8Array(12));q[Sx]=h(B),q[Ax]=h(await crypto.subtle.encrypt({iv:B,name:D},v,new TextEncoder().encode(F)))}else return Y.dispatch(Error("Trying to send without valid destination")),!1;return H.send(Q6(q,$6)),!0},Jx=(x)=>U&&U===w&&g(x,{server:!0}),Y6=(x,Q)=>Q&&g(x,{receiver:Q}),hx=(x,Q=6)=>{if(!Qx.has(x))return!1;let F=Qx.get(x),q="";for(let V=0;V<Q;V++){let B=F[V]%Cx.length;q+=Cx[B]}return q};return{onConnection:Ex,onError:Y,onMessage:lx,onRoomJoin:Tx,onRoomLeave:Rx,onUserJoin:ux,onUserLeave:Ix,onUserVerified:Wx,onUserVerificationCode:cx,messageRoom:(x)=>g(x),messageServer:Jx,messageUser:Y6,closeRoom:()=>Jx({type:sx}),createRoom:async(x={})=>{if(A&&A!==l)return;if(N(Bx),x.publicData)O=x.publicData;if(x.verifyPublicData)p=x.verifyPublicData;try{await new Promise((V,B)=>{let b=new Worker(URL.createObjectURL(new Blob([z6],{type:"text/javascript"})));b.addEventListener("message",(L)=>{if(L.data.success)v=L.data.sharedKey,V();else B(Error(L.data.error));b.terminate()}),b.addEventListener("error",(L)=>{B(L),b.terminate()}),b.postMessage({type:"SHARED_KEY"})})}catch(V){N(l),Y.dispatch({error:V});return}let Q=new URL(Fx+j);if(x.limit)Q.searchParams.append("limit",x.limit);let F=await fetch(Q.toString(),{method:"GET",headers:{Accept:Z}});if(!F.ok)throw Error("Failed to create room");let q=await F.text();return q=J(q),U=q.userId,dx(q.roomCode,q.creatorSecret),q},joinRoom:(x,Q={})=>{if(Q.publicData)O=Q.publicData;if(Q.verifyPublicData)p=Q.verifyPublicData;dx(x)},leaveRoom:u,kickUser:Zx,getVerificationCode:hx,verifyUser:async(x,Q)=>{if(U!==w||!Q)return!1;let F=hx(x,Q.length);if(!F||!Q||F!==Q)return!1;if(kx.set(x,!0),!R.get(x))return!1;return g({type:Lx,privateData:Vx},{receiver:x}),!0}}};export{A6 as createClientConnector};

//# debugId=69BE55DB331C796C64756E2164756E21
