var lt=Object.defineProperty,dt=Object.defineProperties;var ft=Object.getOwnPropertyDescriptors;var Xe=Object.getOwnPropertySymbols;var _t=Object.prototype.hasOwnProperty,Rt=Object.prototype.propertyIsEnumerable;var je=(r,t,e)=>t in r?lt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,Je=(r,t)=>{for(var e in t||(t={}))_t.call(t,e)&&je(r,e,t[e]);if(Xe)for(var e of Xe(t))Rt.call(t,e)&&je(r,e,t[e]);return r},ze=(r,t)=>dt(r,ft(t));var Y=(r,t,e)=>new Promise((i,c)=>{var R=A=>{try{v(e.next(A))}catch(X){c(X)}},B=A=>{try{v(e.throw(A))}catch(X){c(X)}},v=A=>A.done?i(A.value):Promise.resolve(A.value).then(R,B);v((e=e.apply(r,t)).next())});var de="CONNECTED",fe="CONNECTING",G="DISCONNECTED",_e="DISCONNECTING",We="PENDING_VERIFICATION";var ye="_KA",Re="_KO",Ne="_KT",Qe="_RC",Ze="_RJ";var qe="_UJ",$e="_UK",et="_UL",me="_UV";var Ie="ABCDEFGHKMNPQRSTUVWXYZ23456789";var l=r=>{let t=atob(r);return Uint8Array.from(t,e=>e.charCodeAt(0)).buffer},tt=r=>{let t=atob(r),e=Uint8Array.from(t,i=>i.charCodeAt(0));return new TextDecoder().decode(e)},rt=r=>{let t=new TextEncoder().encode(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",i=65536;for(let c=0;c<t.length;c+=i){let R=t.subarray(c,c+i);e+=String.fromCharCode(...R)}return btoa(e)},d=r=>{let t=new Uint8Array(r);if(t.length<65536)return btoa(String.fromCharCode(...t));let e="",i=65536;for(let c=0;c<t.length;c+=i){let R=t.subarray(c,c+i);e+=String.fromCharCode(...R)}return btoa(e)};var S=()=>{let r=new Map;return{addListener:(t,e)=>{r.has(t)||r.set(t,e)},removeListener:t=>{r.delete(t)},dispatch:t=>{for(let[e,i]of r.entries())e(t),i&&i.once&&r.delete(e)}}};var nt="|",ot=":",st=(r,t)=>{let e=[];for(let i in r){let c=r[i];c!=null&&e.push(i+ot+t(String(c)))}return e.join(nt)},at=(r,t)=>{let e={},i=r.split(nt);for(let c of i){let R=c.indexOf(ot);if(R>0){let B=c.substring(0,R),v=c.substring(R+1);e[B]=t(v)}}return e};var ct=(r,t)=>{let e=Date.now();if(!r)return{delay:0,offset:0,adjusted:e};if(!t){let R=r-e;return{delay:0,offset:R,adjusted:e+R}}let i=e-t,c=(r-t+(r-e))/2;return{delay:i,offset:c,adjusted:e-i+c}};var $="ECDH",Ce="P-256",ee="raw",V="SHA-256",te="spki",m="AES-GCM";var re="RSA-OAEP",w="RSASSA-PKCS1-v1_5",it="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([r,t,e])=>{Promise.all([crypto.subtle.exportKey("spki",r.publicKey),crypto.subtle.exportKey("spki",t.publicKey)]).then(([i,c])=>{self.postMessage({success:!0,myEncryptKeys:r,mySignKeys:t,myExchangeKeys:e,myPublicEncryptKey:i,myPublicSignKey:c})}).catch(i=>{self.postMessage({success:!1,error:i.message})})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")",pt="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(r=>{self.postMessage({success:!0,sharedKey:r})}).catch(r=>{self.postMessage({success:!1,error:r.message})})}).toString()+")";var ge="S",Et="T",be="E",he="I",Se="U",Ae="D",Te="V",Oe="K",Ke="P",we="G";var vt=(r={})=>{let{contentType:t="application/json",deserializeMessage:e=JSON.parse,serializeMessage:i=JSON.stringify,createRoomEndpoint:c="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:B="http://localhost:3000",wsUrl:v="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:X=60*1e3}=r,x=G,f,D,T,L,j,ue,F,N,ne,oe,J,se,P,b=[],h,M=new Map,z=new Map,W=new Map,ae=new Map,H=()=>(!D&&!j&&(j=new Promise((n,s)=>{let y=new Worker(URL.createObjectURL(new Blob([it],{type:"text/javascript"})));y.addEventListener("message",a=>{if(a.data.success)ue=a.data.myEncryptKeys,J=a.data.mySignKeys,F=a.data.myExchangeKeys,ne=a.data.myPublicEncryptKey,oe=a.data.myPublicSignKey,D=!0,j=null,n();else{let E=new Error(a.data.error);_.dispatch({error:E}),s(E)}y.terminate()}),y.addEventListener("error",a=>{_.dispatch({error:a}),s(a),y.terminate()}),y.postMessage({type:"USER_KEYS"})})),j);H();let _=S(),xe=S(),De=S(),Pe=S(),Ue=S(),ve=S(),ce=S(),Le=S(),Me=S(),U=n=>{x!==n&&(x=n,Me.dispatch({state:n}))},He=n=>Y(null,null,function*(){let s=M.get(n);s&&(ae.set(n,Array.from(new Uint8Array(yield crypto.subtle.digest(V,new TextEncoder().encode(se+d(yield crypto.subtle.exportKey("raw",s))))))),Le.dispatch({userId:n,code:le(n)}))}),Q=()=>{x===G||x===_e||(U(_e),h&&h.close(),f=D=T=L=j=N=ue=F=ne=oe=J=P=b=h=null,M.clear(),z.clear(),W.clear(),ae.clear(),H(),U(G))},Ye=n=>ie({type:$e,userId:n}),Ge=(n,s=null)=>{if(!s&&x&&x!==G)return;U(fe),se=n;let y=new URL(v+R);y.searchParams.append("code",se),s&&y.searchParams.append("creator",s),h=new WebSocket(y.toString()),h.addEventListener("close",a=>{Pe.dispatch({event:a}),Q()}),h.addEventListener("error",a=>{_.dispatch({event:a}),Q()}),h.addEventListener("message",a=>Y(null,null,function*(){Fe(at(a.data,tt),a.data)}))},Fe=(n,s,y=!1)=>Y(null,null,function*(){let{[ge]:a,[Et]:E,[he]:u,[be]:I,[Ae]:C,[Te]:g,[Oe]:Z,[Ke]:ke,[we]:Ve,[Se]:Be}=n,o,q,pe;if(a?pe=a:C?pe=C:pe=s,I){if(!P||!y&&b.length>0){b.push({time:Date.now(),parts:n,raw:s}),b.length>A&&b.shift();return}if(!u){_.dispatch(new Error("Missing IV to decrypt message"));return}o=yield crypto.subtle.decrypt({iv:l(u),name:m},P,l(I)),o=new TextDecoder().decode(o)}else if(ke){if(!Ve||!Z||!g)return;D||(yield H());let p=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:l(g),name:m},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:re},ue.privateKey,l(Z)),{name:m},!0,["encrypt","decrypt"]),l(ke))));if(p.type===ye)q=p;else{let O=p.sender;if(!O){_.dispatch({error:new Error("Message from unknown sender")});return}let K=W.get(O);if(!K){_.dispatch({error:new Error("No public key for "+O)});return}if(!(yield crypto.subtle.verify(w,K,l(Ve),new TextEncoder().encode(p.payload)))){_.dispatch({error:new Error("Invalid signature from "+O)});return}q=p}}else o=pe;if(!q)try{q=e(o)}catch(p){_.dispatch({error:new Error("Failed to parse message "+s)});return}switch(o=q,o.type){case Ze:if(f=o.creatorId,N=o.userId,De.dispatch({creatorId:o.creatorId,roomCode:se,userId:o.userId,users:o.users}),N===f)U(de);else{U(We),D||(yield H());let p=yield crypto.subtle.exportKey(ee,F.publicKey);k({type:Re,publicData:typeof T=="function"?T():T,publicEncryptKey:d(ne),publicExchangeKey:d(p),publicSignKey:d(oe),signature:d(yield crypto.subtle.sign(w,J.privateKey,p))},{allowUnencrypted:!0,receiver:f})}break;case Re:if(N===f){let p=o.sender;if(L&&!L({data:o.publicData,userId:p})){Ye(p);return}z.set(p,yield crypto.subtle.importKey(te,l(o.publicEncryptKey),{hash:V,name:re},!0,["encrypt"]));let O=yield crypto.subtle.importKey(te,l(o.publicSignKey),{hash:V,name:w},!0,["verify"]),K=l(o.publicExchangeKey);if(!(yield crypto.subtle.verify(w,O,l(o.signature),K))){_.dispatch({error:new Error("Invalid signature for exchange from "+p)});return}W.set(p,O),D||(yield H()),M.set(p,yield crypto.subtle.deriveKey({name:$,public:yield crypto.subtle.importKey(ee,K,{name:$,namedCurve:Ce},!0,[])},F.privateKey,{length:256,name:m},!0,["encrypt","decrypt"]));let Ee=yield crypto.subtle.exportKey(ee,F.publicKey);k({type:ye,publicData:typeof T=="function"?T():T,publicEncryptKey:d(ne),publicExchangeKey:d(Ee),publicSignKey:d(oe),signature:d(yield crypto.subtle.sign(w,J.privateKey,Ee))},{receiver:p}),He(p)}break;case ye:if(Be===N&&o.sender===f){if(L&&!L({data:o.publicData,userId:f})){Q();return}let p=yield crypto.subtle.importKey(te,l(o.publicSignKey),{hash:V,name:w},!0,["verify"]);if(o.publicExchangeKey&&o.signature&&!(yield crypto.subtle.verify(w,p,l(o.signature),l(o.publicExchangeKey)))){_.dispatch({error:new Error("Invalid signature for exchange from "+f)}),Q();return}W.set(f,p),z.set(f,yield crypto.subtle.importKey(te,l(o.publicEncryptKey),{hash:V,name:re},!0,["encrypt"])),D||(yield H()),M.set(f,yield crypto.subtle.deriveKey({name:$,public:yield crypto.subtle.importKey(ee,l(o.publicExchangeKey),{name:$,namedCurve:Ce},!0,[])},F.privateKey,{length:256,name:m},!0,["encrypt","decrypt"])),He(f)}break;case Ne:if(Be===N&&o.sender===f){let p=M.get(f);if(!p){_.dispatch({error:new Error("No derived key for host "+f)});return}if(P=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:l(o.sharedKeyIv),name:m},p,l(o.sharedKey)),{name:m},!0,["encrypt","decrypt"]),ce.dispatch({userId:N}),b.length>0){let O=Date.now();for(b=b.filter(K=>O-K.time<X);b.length>0;){let{parts:K,raw:Ee}=b.shift();Fe(K,Ee,!0)}}U(de)}break;case et:ve.dispatch({userId:o.userId}),M.delete(o.userId),z.delete(o.userId),W.delete(o.userId);break;case qe:Ue.dispatch({userId:o.userId});break;case me:ce.dispatch({userId:o.userId});break;default:xe.dispatch({data:o,time:ct(E,o==null?void 0:o.senderTime)});break}}),k=(y,...a)=>Y(null,[y,...a],function*(n,s={}){if(!h||h.readyState!==WebSocket.OPEN)return _.dispatch({error:new Error("No open socket")}),!1;let E=i(ze(Je({},n),{sender:N,senderTime:Date.now()})),u={};if(s.receiver){let I=z.get(s.receiver);if(I){let C=yield crypto.subtle.generateKey({name:m,length:256},!0,["encrypt","decrypt"]),g=crypto.getRandomValues(new Uint8Array(12)),Z=yield crypto.subtle.encrypt({iv:g,name:m},C,new TextEncoder().encode(E));D||(yield H()),u[we]=d(yield crypto.subtle.sign(w,J.privateKey,Z)),u[Oe]=d(yield crypto.subtle.encrypt({name:re},I,yield crypto.subtle.exportKey("raw",C))),u[Ke]=d(Z),u[Te]=d(g)}else if(s.allowUnencrypted)u[Ae]=E;else return _.dispatch({error:new Error("No public key for "+s.receiver)}),!1;u[Se]=s.receiver}else if(s.server)u[ge]=E;else if(P){let I=crypto.getRandomValues(new Uint8Array(12));u[he]=d(I),u[be]=d(yield crypto.subtle.encrypt({iv:I,name:m},P,new TextEncoder().encode(E)))}else return _.dispatch(new Error("Trying to send without valid destination")),!1;return h.send(st(u,rt)),!0}),ie=n=>N&&N===f&&k(n,{server:!0}),ut=(n,s)=>s&&k(n,{receiver:s}),le=(n,s=6)=>{if(!ae.has(n))return!1;let y=ae.get(n),a="";for(let E=0;E<s;E++){let u=y[E]%Ie.length;a+=Ie[u]}return a};return{onConnection:Me,onError:_,onMessage:xe,onRoomJoin:De,onRoomLeave:Pe,onUserJoin:Ue,onUserLeave:ve,onUserVerified:ce,onUserVerificationCode:Le,messageRoom:n=>k(n),messageServer:ie,messageUser:ut,closeRoom:()=>ie({type:Qe}),createRoom:(...s)=>Y(null,[...s],function*(n={}){if(x&&x!==G)return;U(fe),n.publicData&&(T=n.publicData),n.verifyPublicData&&(L=n.verifyPublicData);try{yield new Promise((u,I)=>{let C=new Worker(URL.createObjectURL(new Blob([pt],{type:"text/javascript"})));C.addEventListener("message",g=>{g.data.success?(P=g.data.sharedKey,u()):I(new Error(g.data.error)),C.terminate()}),C.addEventListener("error",g=>{I(g),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(u){U(G),_.dispatch({error:u});return}let y=new URL(B+c);n.limit&&y.searchParams.append("limit",n.limit);let a=yield fetch(y.toString(),{method:"GET",headers:{Accept:t}});if(!a.ok)throw new Error("Failed to create room");let E=yield a.text();return E=e(E),N=E.userId,Ge(E.roomCode,E.creatorSecret),E}),joinRoom:(n,s={})=>{s.publicData&&(T=s.publicData),s.verifyPublicData&&(L=s.verifyPublicData),Ge(n)},leaveRoom:Q,kickUser:Ye,getVerificationCode:le,verifyUser:(n,s)=>Y(null,null,function*(){if(N!==f||!s)return!1;let y=le(n,s.length);if(!y||!s||y!==s)return!1;let a=M.get(n);if(!a)return!1;let E=crypto.getRandomValues(new Uint8Array(12));return k({type:Ne,sharedKey:d(yield crypto.subtle.encrypt({iv:E,name:m},a,yield crypto.subtle.exportKey("raw",P))),sharedKeyIv:d(E)},{receiver:n}),ce.dispatch({userId:n}),ie({type:me,userId:n}),!0})}};export{vt as createClientConnector};
