{
  "version": 3,
  "sources": ["../src/library/message-types.js", "../src/utilities/code.js", "../src/utilities/encoding-client.js", "../src/utilities/event.js", "../src/utilities/protocol.js", "../src/utilities/time.js", "../src/library/key-generator.js", "../src/library/payload-keys.js", "../src/library/client-connector.js"],
  "sourcesContent": [
    "export const CONNECTION_CONNECTED = 'CONNECTED'\nexport const CONNECTION_CONNECTING = 'CONNECTING'\nexport const CONNECTION_DISCONNECTED = 'DISCONNECTED'\nexport const CONNECTION_DISCONNECTING = 'DISCONNECTING'\nexport const CONNECTION_PENDING_VERIFICATION = 'PENDING_VERIFICATION'\n\nexport const ERROR = '_ER'\nexport const MESSAGE = '_MS'\n\nexport const EXCHANGE_0 = '_X0'\nexport const EXCHANGE_1 = '_X1'\nexport const EXCHANGE_2 = '_X2'\nexport const EXCHANGE_3 = '_X3'\nexport const EXCHANGE_4 = '_X4'\n\nexport const ROOM_CLOSED = '_RC'\nexport const ROOM_JOINED = '_RJ'\nexport const ROOM_LEFT = '_RL'\nexport const ROOM_REMOVED = '_RR'\n\nexport const STATE_UPDATE = '_SU'\nexport const STATE_SYNCH = '_SS'\n\nexport const USER_JOINED = '_UJ'\nexport const USER_KICK = '_UK'\nexport const USER_LEFT = '_UL'\nexport const USER_VERIFIED = '_UV'\n",
    "/**\n * A string containing the allowed characters for generating identifiers.\n * @type {string}\n */\nexport const ALPHANUMERIC_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n/**\n * A string containing the allowed characters for generating codes. Excludes easily confused characters such as 'I', 'O', 'L', '1', and '0'.\n * @type {string}\n */\nexport const IDENTIFIABLE_CHARACTERS = 'ABCDEFGHKMNPQRSTUVWXYZ23456789'\n\n/**\n * Generates a random code string of the specified length.\n *\n * @param {number} [length=6] - The length of the code to generate.\n * @param {string} [characters='ABCDEFGHKMNPQRSTUVWXYZ23456789'] - The characters the code can consist of.\n * @returns {string} A randomly generated code.\n */\nexport const generateCode = (\n  length = 24,\n  characters = ALPHANUMERIC_CHARACTERS,\n) => {\n  let code = ''\n  for (let i = 0; i < length; i++) {\n    code += characters.charAt(\n      Math.floor(\n        Math.random()\n        * characters.length\n      ),\n    )\n  }\n  return code\n}\n",
    "/**\n * Converts a base64-encoded string to an ArrayBuffer.\n *\n * @param {string} base64 - The base64-encoded string to convert.\n * @returns {ArrayBuffer} The decoded ArrayBuffer.\n */\nexport const base64ToBuffer = (\n  base64,\n) => {\n  const binary = atob(base64)\n  return Uint8Array.from(\n    binary,\n    character => character.charCodeAt(0),\n  ).buffer\n}\n\n/**\n * Converts a base64-encoded string to a UTF-8 string.\n *\n * @param {string} base64 - The base64-encoded string to convert.\n * @returns {string} The decoded UTF-8 string.\n */\nexport const base64ToString = (\n  base64,\n) => {\n  const binary = atob(base64)\n  const bytes = Uint8Array.from(\n    binary,\n    character => character.charCodeAt(0)\n  )\n  return new TextDecoder().decode(bytes)\n}\n\n/**\n * Converts a UTF-8 string to a base64-encoded string.\n *\n * @param {string} string - The UTF-8 string to encode.\n * @returns {string} The base64-encoded string.\n */\nexport const stringToBase64 = (\n  string,\n) => {\n  const bytes = new TextEncoder().encode(string)\n\n  if (bytes.length < 65536) {\n    return btoa(\n      String.fromCharCode(...bytes),\n    )\n  }\n\n  let binary = ''\n  const chunkSize = 65536\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode(...chunk)\n  }\n  return btoa(binary)\n}\n\n/**\n * Converts an ArrayBuffer to a base64-encoded string.\n *\n * @param {ArrayBuffer} buffer - The ArrayBuffer to encode.\n * @returns {string} The base64-encoded string.\n */\nexport const bufferToBase64 = (\n  buffer,\n) => {\n  const bytes = new Uint8Array(buffer)\n\n  if (bytes.length < 65536) {\n    return btoa(\n      String.fromCharCode(...bytes),\n    )\n  }\n\n  let binary = ''\n  const chunkSize = 65536\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode(...chunk)\n  }\n  return btoa(binary)\n}\n",
    "/**\n * Type definition for event listener options.\n * @typedef {Object} EventListenerOptions\n * @property {boolean} [once] - If true, the listener will be removed after the first call.\n */\n\n/**\n * Type definition for an event listener callback.\n * @typedef {(data: any) => void} EventListenerCallback\n */\n\n/**\n * Type definition for the event object returned by createEvent.\n * @typedef {Object} Event\n * @property {(callback: EventListenerCallback, options?: EventListenerOptions) => void} addListener\n * @property {(callback: EventListenerCallback) => void} removeListener\n * @property {(data: any) => void} dispatch\n */\n\n/**\n * Creates a custom event system with add, remove, and dispatch capabilities.\n *\n * @returns {Event} An event object with methods to manage listeners.\n */\nexport const createEvent = (\n) => {\n  /** @type {Map<EventListenerCallback, EventListenerOptions | undefined>} */\n  const listeners = new Map()\n\n  return {\n    /**\n     * Adds a listener callback for the event.\n     * @param {EventListenerCallback} callback - The listener function to add.\n     * @param {EventListenerOptions} [options] - Optional options for the listener (e.g., { once: true }).\n     */\n    addListener: (\n      callback,\n      options,\n    ) => {\n      if (!listeners.has(callback)) {\n        listeners.set(callback, options)\n      }\n    },\n\n    /**\n     * Removes a listener callback from the event.\n     * @param {EventListenerCallback} callback - The listener function to remove.\n     */\n    removeListener: (\n      callback,\n    ) => {\n      listeners.delete(callback)\n    },\n\n    /**\n     * Dispatches the event to all registered listeners.\n     * @param {any} data - Data to pass to each listener callback.\n     */\n    dispatch: (\n      data,\n    ) => {\n      for (const [listener, options] of listeners.entries()) {\n        listener(data)\n        if (\n          options\n          && options.once\n        ) {\n          listeners.delete(listener)\n        }\n      }\n    },\n  }\n}\n",
    "const DELIMITER = '|'\nconst INFIX = ':'\n\nexport const encode = (\n  parts,\n  stringToBase64,\n) => {\n  const segments = []\n  for (const key in parts) {\n    const value = parts[key]\n    if (\n      value !== null\n      && value !== undefined\n    ) {\n      segments.push(key + INFIX + stringToBase64(\n        String(value)),\n      )\n    }\n  }\n  return segments.join(DELIMITER)\n}\n\nexport const decode = (\n  message,\n  base64ToString,\n) => {\n  const parts = {}\n  const segments = message.split(DELIMITER)\n  for (const segment of segments) {\n    const index = segment.indexOf(INFIX)\n    if (index > 0) {\n      const key = segment.substring(0, index)\n      const value = segment.substring(index + 1)\n      parts[key] = base64ToString(value)\n    }\n  }\n  return parts\n}\n",
    "\n/**\n * Calculates time synchronization values based on provided server and sender times.\n *\n * @param {string} serverTime - The date and time the server broadcasted the data.\n * @param {string} senderTime - The date and time the sender send the data.\n * @returns {{\n *   delay: number,\n *   offset: number,\n *   adjusted: number,\n * }} An object containing the calculated delay, offset, and adjusted time.\n */\nexport const calculateTime = (\n  serverTime,\n  senderTime,\n) => {\n  const receiverTime = Date.now()\n\n  if (!serverTime) {\n    return {\n      delay: 0,\n      offset: 0,\n      adjusted: receiverTime,\n    }\n  }\n\n  if (!senderTime) {\n    const offset = serverTime - receiverTime\n    return {\n      delay: 0,\n      offset: offset,\n      adjusted: (\n        receiverTime\n        + offset\n      ),\n    }\n  }\n\n  const delay = receiverTime - senderTime\n  const offset = (\n    (serverTime - senderTime)\n    + (serverTime - receiverTime)\n  ) / 2\n  return {\n    delay: delay,\n    offset: offset,\n    adjusted: (\n      receiverTime\n      - delay\n      + offset\n    ),\n  }\n}\n",
    "export const DIFFIE_HELLMAN_ALGORITHM = 'ECDH'\nexport const DIFFIE_HELLMAN_CURVE = 'P-256'\nexport const DIFFIE_HELLMAN_EXPORT_FORMAT = 'raw'\nexport const HASH_ALGORITHM = 'SHA-256'\nexport const PUBLIC_KEY_EXPORT_FORMAT = 'spki'\nexport const SHARED_ENCRYPTION_ALGORITHM = 'AES-GCM'\nexport const SHARED_KEY_LENGTH = 256\nexport const USER_ENCRYPTION_ALGORITHM = 'RSA-OAEP'\nexport const USER_SIGNATURE_ALGORITHM = 'RSASSA-PKCS1-v1_5'\n\n// Values are inlined because of the string generated by the toString call will not have the same context. It is not written in a string in order to allow the build tool to minify and post-process the function's contents.\n\nexport const USER_KEY_GENERATOR = 'self.addEventListener(\\'message\\',' + ((\n) => {\n  Promise.all([\n    crypto.subtle.generateKey({\n      name: 'RSA-OAEP',\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: { name: 'SHA-256', },\n    }, true, ['encrypt', 'decrypt',]),\n    crypto.subtle.generateKey({\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: { name: 'SHA-256', },\n    }, true, ['sign', 'verify',]),\n    crypto.subtle.generateKey({\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    }, true, ['deriveKey',]),\n  ])\n    .then(([\n      myEncryptKeys,\n      mySignKeys,\n      myExchangeKeys,\n    ]) => {\n      Promise.all([\n        crypto.subtle.exportKey(\n          'spki',\n          myEncryptKeys.publicKey,\n        ),\n        crypto.subtle.exportKey(\n          'spki',\n          mySignKeys.publicKey,\n        ),\n      ])\n        .then(([\n          myPublicEncryptKey,\n          myPublicSignKey,\n        ]) => {\n          self.postMessage({\n            success: true,\n            myEncryptKeys,\n            mySignKeys,\n            myExchangeKeys,\n            myPublicEncryptKey,\n            myPublicSignKey,\n          })\n        })\n        .catch((error) => {\n          self.postMessage({\n            success: false,\n            error: error.message,\n          })\n        })\n    })\n    .catch((error) => {\n      self.postMessage({\n        success: false,\n        error: error.message,\n      })\n    })\n}).toString() + ')'\n\nexport const SHARED_KEY_GENERATOR = 'self.addEventListener(\\'message\\',' + ((\n) => {\n  crypto.subtle.generateKey({\n    length: 256,\n    name: 'AES-GCM',\n  }, true, ['encrypt', 'decrypt'])\n    .then(sharedKey => {\n      self.postMessage({\n        success: true,\n        sharedKey,\n      })\n    })\n    .catch(error => {\n      self.postMessage({\n        success: false,\n        error: error.message,\n      })\n    })\n}).toString() + ')'\n",
    "export const SERVER_PAYLOAD = 'S'\nexport const SERVER_TIME = 'T'\n\nexport const SHARED_ENCRYPTION_PAYLOAD = 'E'\nexport const SHARED_ENCRYPTION_IV = 'I'\n\nexport const USER = 'U'\nexport const USER_DIRECT_PAYLOAD = 'D'\nexport const USER_ENCRYPTION_IV = 'V'\nexport const USER_ENCRYPTION_KEY = 'K'\nexport const USER_ENCRYPTION_PAYLOAD = 'P'\nexport const USER_ENCRYPTION_SIGNATURE = 'G'\n",
    "import {\n    CONNECTION_CONNECTED,\n    CONNECTION_CONNECTING,\n    CONNECTION_DISCONNECTED,\n    CONNECTION_DISCONNECTING,\n    CONNECTION_PENDING_VERIFICATION,\n\n    EXCHANGE_0,\n    EXCHANGE_1,\n    EXCHANGE_2,\n    EXCHANGE_3,\n    EXCHANGE_4,\n\n    ROOM_CLOSED,\n    ROOM_JOINED,\n\n    USER_JOINED,\n    USER_KICK,\n    USER_LEFT,\n    USER_VERIFIED,\n} from './message-types.js'\n\nimport {\n    IDENTIFIABLE_CHARACTERS,\n} from '../utilities/code.js'\nimport {\n    base64ToBuffer,\n    base64ToString,\n    bufferToBase64,\n    stringToBase64,\n} from '../utilities/encoding-client.js'\nimport {\n    createEvent,\n} from '../utilities/event.js'\nimport {\n    decode,\n    encode,\n} from '../utilities/protocol.js'\nimport {\n    calculateTime,\n} from '../utilities/time.js'\nimport {\n    DIFFIE_HELLMAN_ALGORITHM,\n    DIFFIE_HELLMAN_CURVE,\n    DIFFIE_HELLMAN_EXPORT_FORMAT,\n    HASH_ALGORITHM,\n    PUBLIC_KEY_EXPORT_FORMAT,\n    SHARED_ENCRYPTION_ALGORITHM,\n    SHARED_KEY_GENERATOR,\n    SHARED_KEY_LENGTH,\n    USER_ENCRYPTION_ALGORITHM,\n    USER_KEY_GENERATOR,\n    USER_SIGNATURE_ALGORITHM,\n} from './key-generator.js'\nimport {\n    SERVER_PAYLOAD,\n    SERVER_TIME,\n\n    SHARED_ENCRYPTION_IV,\n    SHARED_ENCRYPTION_PAYLOAD,\n    USER,\n    USER_DIRECT_PAYLOAD,\n\n    USER_ENCRYPTION_IV,\n    USER_ENCRYPTION_KEY,\n    USER_ENCRYPTION_PAYLOAD,\n    USER_ENCRYPTION_SIGNATURE\n} from './payload-keys.js'\n\n/**\n * @typedef {import('../utilities/event.js').Event} Event\n */\n\n/**\n * @typedef {Object} ConnectorOptions\n *\n * @property {string} [createRoomEndpoint='/create-room'] - HTTP endpoint for creating a room.\n * @property {string} [joinRoomEndpoint='/join-room'] - WebSocket endpoint for joining a room.\n *\n * @property {string} [contentType='application/json'] - Content-Type for HTTP requests.\n * @property {Function} [deserializeMessage=JSON.parse] - Function to deserialize incoming messages.\n * @property {Function} [serializeMessage=JSON.stringify] - Function to serialize outgoing messages.\n *\n * @property {string} [httpUrl='http://localhost:3000'] - Base HTTP URL for API requests.\n * @property {string} [wsUrl='http://localhost:3000'] - Base WebSocket URL for room connections.\n *\n * @property {any} [publicData={}] - Public data to be shared with other clients in the room.\n * @property {Function} [verifyPublicData] - Callback for verifying the public data of other users.\n * @property {any} [privateData={}] - Private data to be shared with other clients in the room.\n * @property {Function} [verifyPrivateData] - Callback for verifying the private data of other users.\n *\n * @property {number} [messageBufferMaxCount=50] - The maximum number of messages to store in the buffer.\n * @property {number} [messageBufferMaxDuration=60000] - The maximum duration in milliseconds to store a message in the buffer.\n */\n\n/**\n * @typedef {Object} ConnectorAPI\n *\n * @property {Event} onConnection - Event for connection state change notifications.\n * @property {Event} onError - Event for error handling.\n * @property {Event} onMessage - Event for receiving messages.\n * @property {Event} onRoomJoin - Event for room join notifications.\n * @property {Event} onRoomLeave - Event for room leave notifications.\n * @property {Event} onUserJoin - Event for user join notifications.\n * @property {Event} onUserLeave - Event for user leave notifications.\n * @property {Event} onUserVerified - Event for user verified notifications.\n *\n * @property {Function} createRoom - Creates a new room and joins it.\n * @property {Function} closeRoom - Closes the room for all. Only allowed by the creator.\n * @property {Function} joinRoom - Joins an existing room.\n * @property {Function} leaveRoom - Leaves the current room.\n * @property {Function} messageRoom - Sends a message to the current room.\n *\n * @property {Function} kickUser - Removes a player's connection. Only allowed by the creator.\n */\n\n/**\n * Creates a connector for managing room-based WebSocket communication.\n *\n * @param {ConnectorOptions} [options={}] - Configuration options for the connector.\n * @returns {ConnectorAPI} Connector API with event handlers and room management methods.\n */\nexport const createClientConnector = (\n  options = {},\n) => {\n  const {\n    contentType = 'application/json',\n    deserializeMessage = JSON.parse,\n    serializeMessage = JSON.stringify,\n\n    createRoomEndpoint = '/create-room',\n    joinRoomEndpoint = '/join-room',\n\n    httpUrl = 'http://localhost:3000',\n    wsUrl = 'http://localhost:3000',\n\n    messageBufferMaxCount = 50,\n    messageBufferMaxDuration = 60 * 1000,\n  } = options\n\n  let _connectionState = CONNECTION_DISCONNECTED,\n    _creatorId,\n    _generatedKeys,\n    _keyGenerationPromise,\n    _myEncryptKeys,\n    _myExchangeKeys,\n    _myId,\n    _myPublicEncryptKey,\n    _myPublicSignKey,\n    _mySignKeys,\n    _privateData,\n    _privateDataVerify,\n    _publicData,\n    _publicDataVerify,\n    _roomCode,\n    _sharedKey,\n    _sharedMessagesBuffer = [],\n    _socket,\n    _userDerivedKeys = new Map(),\n    _userEncryptKeys = new Map(),\n    _userSignKeys = new Map(),\n    _userVerification = new Map(),\n    _userVerified = new Map()\n  /**\n   * Generates cryptographic keys for the user using a Web Worker if not already generated.\n   *\n   * @returns {Promise<void>|null} A promise that resolves when keys are generated, or null if already generated.\n   */\n  const _generateMyKeys = (\n  ) => {\n    if (\n      !_generatedKeys\n      && !_keyGenerationPromise\n    ) {\n      _keyGenerationPromise = new Promise((\n        resolve,\n        reject,\n      ) => {\n        const worker = new Worker(\n          URL.createObjectURL(\n            new Blob([USER_KEY_GENERATOR,], {\n              type: 'text/javascript',\n            }),\n          ),\n        )\n\n        worker.addEventListener('message', (\n          event,\n        ) => {\n          if (event.data.success) {\n            _myEncryptKeys = event.data.myEncryptKeys\n            _mySignKeys = event.data.mySignKeys\n            _myExchangeKeys = event.data.myExchangeKeys\n            _myPublicEncryptKey = event.data.myPublicEncryptKey\n            _myPublicSignKey = event.data.myPublicSignKey\n\n            _generatedKeys = true\n            _keyGenerationPromise = null\n            resolve()\n          } else {\n            const error = new Error(event.data.error)\n            onError.dispatch({\n              error,\n            })\n            reject(error)\n          }\n          worker.terminate()\n        })\n\n        worker.addEventListener('error', (\n          error,\n        ) => {\n          onError.dispatch({\n            error,\n          })\n          reject(error)\n          worker.terminate()\n        })\n\n        worker.postMessage({\n          type: 'USER_KEYS',\n        })\n      })\n    }\n    return _keyGenerationPromise\n  }\n  // Start generating new keys.\n  _generateMyKeys()\n\n  const onError = createEvent()\n  const onMessage = createEvent()\n  const onRoomJoin = createEvent()\n  const onRoomLeave = createEvent()\n  const onUserJoin = createEvent()\n  const onUserLeave = createEvent()\n  const onUserVerified = createEvent()\n  const onUserVerificationCode = createEvent()\n  const onConnection = createEvent()\n\n  /**\n   * Sets the current connection state and dispatches a connection event if the state has changed.\n   *\n   * @param {number} state - The new connection state.\n   */\n  const _setConnectionState = (\n    state,\n  ) => {\n    if (_connectionState !== state) {\n      _connectionState = state\n      onConnection.dispatch({\n        state,\n      })\n    }\n  }\n\n  /**\n   * Generates a verification code for the specified user ID using the room code and derived key.\n   *\n   * @param {string} userId - The ID of the user to generate the code for.\n   */\n  const _generateVerificationCode = async (\n    userId,\n  ) => {\n    const derivedKey = _userDerivedKeys.get(userId)\n    if (!derivedKey) {\n      return\n    }\n\n    _userVerification.set(\n      userId,\n      Array.from(\n        new Uint8Array(\n          await crypto.subtle.digest(\n            HASH_ALGORITHM,\n            new TextEncoder().encode(\n              _roomCode\n              + bufferToBase64(\n                await crypto.subtle.exportKey(\n                  'raw',\n                  derivedKey,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    )\n\n    onUserVerificationCode.dispatch({\n      userId,\n      code: getVerificationCode(userId),\n    })\n  }\n\n  /**\n   * Closes the current socket connection and resets the socket reference. This function should be called when leaving a room to ensure that the socket connection is properly closed and the state is cleaned up.\n   */\n  const leaveRoom = (\n  ) => {\n    if (\n      _connectionState === CONNECTION_DISCONNECTED\n      || _connectionState === CONNECTION_DISCONNECTING\n    ) {\n      return\n    }\n    _setConnectionState(CONNECTION_DISCONNECTING)\n\n    if (_socket) {\n      _socket.close()\n    }\n\n    _creatorId = _generatedKeys = _keyGenerationPromise = _myId = _myEncryptKeys = _myExchangeKeys = _myPublicEncryptKey = _myPublicSignKey = _mySignKeys = _privateData = _privateDataVerify = _publicData = _publicDataVerify = _sharedKey = _sharedMessagesBuffer = _socket = null\n    _userDerivedKeys.clear()\n    _userEncryptKeys.clear()\n    _userSignKeys.clear()\n    _userVerification.clear()\n    _userVerified.clear()\n\n    // Setup new keys right away.\n    _generateMyKeys()\n\n    _setConnectionState(CONNECTION_DISCONNECTED)\n  }\n  /**\n   * Sends a message to kick the specified user from the room. Only allowed by the room creator.\n   *\n   * @param {string} userId - The ID of the user to kick.\n   * @returns {boolean} True if the message was sent successfully, false otherwise.\n   */\n  const kickUser = (\n    userId,\n  ) => messageServer({\n    type: USER_KICK,\n    userId,\n  })\n\n  /**\n   * Joins a WebSocket room with the specified room code and optional credentials. Establishes a WebSocket connection to the server, appending the room code, password, and creator secret (if provided) as query parameters. Sets up event listeners for 'close', 'error', and 'message' events to handle room leave, errors, and incoming messages.\n   *\n   * @param {string} roomCode - The code of the room to join.\n   * @param {string|null} [password=null] - Optional password for the room.\n   * @param {string|null} [creatorSecret=null] - Optional creator secret for verifying this user is the creator of the room.\n   */\n  const _joinRoom = (\n    roomCode,\n    creatorSecret = null,\n  ) => {\n    if (\n      !creatorSecret\n      && _connectionState\n      && _connectionState !== CONNECTION_DISCONNECTED\n    ) {\n      return\n    }\n    _setConnectionState(CONNECTION_CONNECTING)\n\n    _roomCode = roomCode\n\n    const url = new URL(\n      wsUrl + joinRoomEndpoint,\n    )\n    url.searchParams.append(\n      'code',\n      _roomCode,\n    )\n    if (creatorSecret) {\n      url.searchParams.append(\n        'creator',\n        creatorSecret,\n      )\n    }\n\n    _socket = new WebSocket(\n      url.toString(),\n    )\n\n    _socket.addEventListener('close', (\n      event,\n    ) => {\n      onRoomLeave.dispatch({\n        event,\n      })\n\n      leaveRoom()\n    })\n\n    _socket.addEventListener('error', (\n      event,\n    ) => {\n      onError.dispatch({\n        event,\n      })\n      leaveRoom()\n    })\n\n    _socket.addEventListener('message', async (\n      event,\n    ) => {\n      _processMessage(\n        decode(\n          event.data,\n          base64ToString,\n        ),\n        event.data,\n      )\n    })\n  }\n\n  /**\n   * Processes an incoming message, decrypts it if necessary, and handles the message based on its type.\n   *\n   * @param {Object<string, any>} parts - The parsed message parts.\n   * @param {string} raw - The raw message string.\n   * @param {boolean} [isBuffered=false] - Whether this message was buffered.\n   */\n  const _processMessage = async (\n    parts,\n    raw,\n    isBuffered = false,\n  ) => {\n    const {\n      [SERVER_PAYLOAD]: serverPayload,\n      [SERVER_TIME]: serverTime,\n\n      [SHARED_ENCRYPTION_IV]: sharedEncryptionIv,\n      [SHARED_ENCRYPTION_PAYLOAD]: sharedEncryptionPayload,\n\n      [USER_DIRECT_PAYLOAD]: userDirectPayload,\n      [USER_ENCRYPTION_IV]: userEncryptionIv,\n      [USER_ENCRYPTION_KEY]: userEncryptionKey,\n      [USER_ENCRYPTION_PAYLOAD]: userEncryptionPayload,\n      [USER_ENCRYPTION_SIGNATURE]: userEncryptionSignature,\n      [USER]: userReceiver,\n    } = parts\n\n    let data,\n      deserializedData,\n      payload,\n      wasEncrypted\n\n    if (serverPayload) {\n      payload = serverPayload\n    } else if (userDirectPayload) {\n      payload = userDirectPayload\n    } else {\n      payload = raw\n    }\n\n    if (sharedEncryptionPayload) {\n      if (\n        !_sharedKey\n        || (\n          !isBuffered\n          && _sharedMessagesBuffer.length > 0\n        )\n      ) {\n        // Can't decrypt without the key, store the messages for later.\n        _sharedMessagesBuffer.push({\n          time: Date.now(),\n          parts,\n          raw,\n        })\n\n        // Remove oldest message if buffer is full.\n        if (_sharedMessagesBuffer.length > messageBufferMaxCount) {\n          _sharedMessagesBuffer.shift()\n        }\n        return\n      }\n      if (!sharedEncryptionIv) {\n        onError.dispatch(\n          new Error('Missing IV to decrypt message')\n        )\n        return\n      }\n\n      data = await crypto.subtle.decrypt(\n        {\n          iv: base64ToBuffer(sharedEncryptionIv),\n          name: SHARED_ENCRYPTION_ALGORITHM,\n        },\n        _sharedKey,\n        base64ToBuffer(sharedEncryptionPayload),\n      )\n      data = new TextDecoder().decode(data)\n      wasEncrypted = true\n    } else if (userEncryptionPayload) {\n      if (\n        !userEncryptionKey\n        || !userEncryptionIv\n      ) {\n        // Assume the message is not encrypted just send as a user specific message.\n        onError.dispatch({\n          error: new Error('Missing signature or IV to decrypt message.'),\n        })\n        return\n      }\n      if (!_generatedKeys) {\n        await _generateMyKeys()\n      }\n\n      const encryptedPayload = base64ToBuffer(userEncryptionPayload)\n      const payloadData = deserializeMessage(\n        new TextDecoder()\n          .decode(\n            await crypto.subtle.decrypt(\n              {\n                iv: base64ToBuffer(userEncryptionIv),\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              await crypto.subtle.importKey(\n                'raw',\n                await crypto.subtle.decrypt(\n                  {\n                    name: USER_ENCRYPTION_ALGORITHM,\n                  },\n                  _myEncryptKeys.privateKey,\n                  base64ToBuffer(userEncryptionKey),\n                ),\n                {\n                  name: SHARED_ENCRYPTION_ALGORITHM,\n                },\n                true,\n                ['encrypt', 'decrypt',],\n              ),\n              encryptedPayload\n            ),\n          ),\n      )\n      wasEncrypted = true\n\n      if (payloadData.type === EXCHANGE_1) {\n        // We can't check the signature because we don't have the sender's public key yet.\n        deserializedData = payloadData\n      } else if (userEncryptionSignature) {\n        const senderId = payloadData.sender\n\n        if (!senderId) {\n          onError.dispatch({\n            error: new Error('Message from unknown sender'),\n          })\n          return\n        }\n\n        const senderPublicKey = _userSignKeys.get(senderId)\n        if (!senderPublicKey) {\n          onError.dispatch({\n            error: new Error('No public key for ' + senderId),\n          })\n          return\n        }\n\n        if (\n          !(await crypto.subtle.verify(\n            USER_SIGNATURE_ALGORITHM,\n            senderPublicKey,\n            base64ToBuffer(userEncryptionSignature),\n            encryptedPayload,\n          ))\n        ) {\n          onError.dispatch({\n            error: new Error('Invalid signature from ' + senderId),\n          })\n          return\n        }\n\n        deserializedData = payloadData\n      } else {\n        onError.dispatch({\n          error: new Error('Missing encryption signature'),\n        })\n        return\n      }\n    } else {\n      data = payload\n    }\n\n    if (!deserializedData) {\n      try {\n        deserializedData = deserializeMessage(data)\n      } catch (error) {\n        onError.dispatch({\n          error: new Error('Failed to parse message ' + raw),\n        })\n        return\n      }\n    }\n    data = deserializedData\n\n    switch (data.type) {\n      case ROOM_JOINED:\n        _creatorId = data.creatorId\n        _myId = data.userId\n\n        onRoomJoin.dispatch({\n          creatorId: data.creatorId,\n          roomCode: _roomCode,\n          userId: data.userId,\n          users: data.users,\n        })\n\n        if (_myId === _creatorId) {\n          _setConnectionState(CONNECTION_CONNECTED)\n        } else {\n          _setConnectionState(CONNECTION_PENDING_VERIFICATION)\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          const myPublicExchangeKey = await crypto.subtle.exportKey(\n            DIFFIE_HELLMAN_EXPORT_FORMAT,\n            _myExchangeKeys.publicKey,\n          )\n\n          _message({\n            type: EXCHANGE_0,\n            publicData: (\n              typeof(_publicData) === 'function'\n                ? _publicData()\n                : _publicData\n            ),\n            publicEncryptKey: bufferToBase64(_myPublicEncryptKey),\n            publicExchangeKey: bufferToBase64(myPublicExchangeKey),\n            publicSignKey: bufferToBase64(_myPublicSignKey),\n            // Explicitly add signature manually.\n            signature: bufferToBase64(\n              await crypto.subtle.sign(\n                USER_SIGNATURE_ALGORITHM,\n                _mySignKeys.privateKey,\n                myPublicExchangeKey,\n              ),\n            ),\n          }, {\n            allowUnencrypted: true,\n            receiver: _creatorId,\n          })\n        }\n        break\n\n      case EXCHANGE_0:\n        if (\n          userReceiver === _creatorId\n          && _myId === _creatorId\n        ) {\n          const newUserId = data.sender\n\n          if (\n            _publicDataVerify\n            && !_publicDataVerify({\n              data: data.publicData,\n              userId: newUserId,\n            })\n          ) {\n            kickUser(newUserId)\n            return\n          }\n\n          _userEncryptKeys.set(\n            newUserId,\n            await crypto.subtle.importKey(\n              PUBLIC_KEY_EXPORT_FORMAT,\n              base64ToBuffer(data.publicEncryptKey),\n              {\n                hash: HASH_ALGORITHM,\n                name: USER_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt',],\n            ),\n          )\n\n          const publicSignKey = await crypto.subtle.importKey(\n            PUBLIC_KEY_EXPORT_FORMAT,\n            base64ToBuffer(data.publicSignKey),\n            {\n              hash: HASH_ALGORITHM,\n              name: USER_SIGNATURE_ALGORITHM,\n            },\n            true,\n            ['verify',],\n          )\n\n          const publicExchangeKeyData = base64ToBuffer(\n            data.publicExchangeKey,\n          )\n          if (!(await crypto.subtle.verify(\n            USER_SIGNATURE_ALGORITHM,\n            publicSignKey,\n            base64ToBuffer(data.signature),\n            publicExchangeKeyData,\n          ))) {\n            onError.dispatch({\n              error: new Error('Invalid signature for exchange from ' + newUserId),\n            })\n            return\n          }\n\n          _userSignKeys.set(newUserId, publicSignKey)\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          _userDerivedKeys.set(\n            newUserId,\n            await crypto.subtle.deriveKey(\n              {\n                name: DIFFIE_HELLMAN_ALGORITHM,\n                public: await crypto.subtle.importKey(\n                  DIFFIE_HELLMAN_EXPORT_FORMAT,\n                  publicExchangeKeyData,\n                  {\n                    name: DIFFIE_HELLMAN_ALGORITHM,\n                    namedCurve: DIFFIE_HELLMAN_CURVE,\n                  },\n                  true,\n                  [],\n                ),\n              },\n              _myExchangeKeys.privateKey,\n              {\n                length: SHARED_KEY_LENGTH,\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt', 'decrypt',],\n            ),\n          )\n\n          const myPublicExchangeKey = await crypto.subtle.exportKey(\n            DIFFIE_HELLMAN_EXPORT_FORMAT,\n            _myExchangeKeys.publicKey,\n          )\n          _message({\n            type: EXCHANGE_1,\n            publicData: (\n              typeof(_publicData) === 'function'\n                ? _publicData()\n                : _publicData\n            ),\n            publicEncryptKey: bufferToBase64(_myPublicEncryptKey),\n            publicExchangeKey: bufferToBase64(myPublicExchangeKey),\n            publicSignKey: bufferToBase64(_myPublicSignKey),\n          }, {\n            receiver: newUserId,\n          })\n\n          _generateVerificationCode(newUserId)\n        }\n        break\n\n      case EXCHANGE_1:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (\n            _publicDataVerify\n            && !_publicDataVerify({\n              data: data.publicData,\n              userId: _creatorId,\n            })\n          ) {\n            leaveRoom()\n            return\n          }\n\n          const hostPublicSignKey = await crypto.subtle.importKey(\n            PUBLIC_KEY_EXPORT_FORMAT,\n            base64ToBuffer(data.publicSignKey),\n            {\n              hash: HASH_ALGORITHM,\n              name: USER_SIGNATURE_ALGORITHM,\n            },\n            true,\n            ['verify',],\n          )\n\n          if (\n            data.publicExchangeKey\n            && data.signature\n          ) {\n            if (!(await crypto.subtle.verify(\n              USER_SIGNATURE_ALGORITHM,\n              hostPublicSignKey,\n              base64ToBuffer(data.signature),\n              base64ToBuffer(data.publicExchangeKey),\n            ))) {\n              onError.dispatch({\n                error: new Error('Invalid signature for exchange from ' + _creatorId),\n              })\n              leaveRoom()\n              return\n            }\n          }\n          _userSignKeys.set(\n            _creatorId,\n            hostPublicSignKey,\n          )\n\n          _userEncryptKeys.set(\n            _creatorId,\n            await crypto.subtle.importKey(\n              PUBLIC_KEY_EXPORT_FORMAT,\n              base64ToBuffer(data.publicEncryptKey),\n              {\n                hash: HASH_ALGORITHM,\n                name: USER_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt',],\n            ),\n          )\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          _userDerivedKeys.set(\n            _creatorId,\n            await crypto.subtle.deriveKey(\n              {\n                name: DIFFIE_HELLMAN_ALGORITHM,\n                public: await crypto.subtle.importKey(\n                  DIFFIE_HELLMAN_EXPORT_FORMAT,\n                  base64ToBuffer(data.publicExchangeKey),\n                  {\n                    name: DIFFIE_HELLMAN_ALGORITHM,\n                    namedCurve: DIFFIE_HELLMAN_CURVE,\n                  },\n                  true,\n                  [],\n                ),\n              },\n              _myExchangeKeys.privateKey,\n              {\n                length: SHARED_KEY_LENGTH,\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt', 'decrypt',],\n            )\n          )\n\n          _generateVerificationCode(_creatorId)\n        }\n        break\n\n      case EXCHANGE_2:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (!wasEncrypted) {\n            onError.dispatch({\n              error: new Error('Message was not encrypted'),\n            })\n            return\n          }\n\n          if (\n            _privateDataVerify\n            && !_privateDataVerify({\n              data: data.privateData,\n              userId: _creatorId,\n            })\n          ) {\n            leaveRoom()\n            return\n          }\n\n          _message({\n            type: EXCHANGE_3,\n            privateData: _privateData,\n          }, {\n            receiver: _creatorId,\n          })\n        }\n        break\n\n      case EXCHANGE_3:\n        if (\n          userReceiver === _creatorId\n          && _myId === _creatorId\n        ) {\n          if (!wasEncrypted) {\n            onError.dispatch({\n              error: new Error('Message was not encrypted'),\n            })\n            return\n          }\n          const userId = data.sender\n\n          if (!_userVerified.get(userId)) {\n            onError.dispatch({\n              error: new Error('User not verified'),\n            })\n            kickUser(userId)\n            return\n          }\n\n          if (\n            _privateDataVerify\n            && !_privateDataVerify({\n              data: data.privateData,\n              userId,\n            })\n          ) {\n            kickUser(userId)\n            return\n          }\n\n          _message({\n            type: EXCHANGE_4,\n            sharedKey: bufferToBase64(\n              await crypto.subtle.exportKey(\n                'raw',\n                _sharedKey,\n              ),\n            ),\n          }, {\n            receiver: userId,\n          })\n\n          onUserVerified.dispatch({\n            userId,\n          })\n          messageServer({\n            type: USER_VERIFIED,\n            userId,\n          })\n        }\n        break\n\n      case EXCHANGE_4:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (!wasEncrypted) {\n            onError.dispatch({\n              error: new Error('Message was not encrypted'),\n            })\n            return\n          }\n\n          _sharedKey = await crypto.subtle.importKey(\n            'raw',\n            base64ToBuffer(\n              data.sharedKey,\n            ),\n            {\n              name: SHARED_ENCRYPTION_ALGORITHM,\n            },\n            true,\n            ['encrypt', 'decrypt',],\n          )\n\n          onUserVerified.dispatch({\n            userId: _myId,\n          })\n\n          // Replay stored messages to catch up.\n          if (_sharedMessagesBuffer.length > 0) {\n            const now = Date.now()\n            _sharedMessagesBuffer = _sharedMessagesBuffer.filter((item) => (\n              now - item.time < messageBufferMaxDuration\n            ))\n\n            while (_sharedMessagesBuffer.length > 0) {\n              const {\n                parts,\n                raw,\n              } = _sharedMessagesBuffer.shift()\n              _processMessage(\n                parts,\n                raw,\n                true,\n              )\n            }\n          }\n\n          _setConnectionState(CONNECTION_CONNECTED)\n        }\n      break\n\n      case USER_LEFT:\n        onUserLeave.dispatch({\n          userId: data.userId,\n        })\n        _userDerivedKeys.delete(data.userId)\n        _userEncryptKeys.delete(data.userId)\n        _userSignKeys.delete(data.userId)\n        break\n\n      case USER_JOINED:\n        onUserJoin.dispatch({\n          userId: data.userId,\n        })\n        break\n\n      case USER_VERIFIED:\n        onUserVerified.dispatch({\n          userId: data.userId,\n        })\n        break\n\n      default:\n        if (!wasEncrypted) {\n          onError.dispatch({\n            error: new Error('Message was not encrypted'),\n          })\n          return\n        }\n\n        onMessage.dispatch({\n          data,\n          time: calculateTime(\n            serverTime,\n            data?.senderTime,\n          ),\n        })\n        break\n    }\n  }\n\n  /**\n   * Sends a message to the server or a specific user, encrypting the message if necessary.\n   *\n   * @param {Object<string, any>} data - The message data to send.\n   * @param {Object<string, any>} [options={}] - Options for the message, such as receiver or server flag.\n   * @returns {boolean} True if the message was sent successfully, false otherwise.\n   */\n  const _message = async (\n    data,\n    options = {},\n  ) => {\n    if (\n      !_socket\n      || _socket.readyState !== WebSocket.OPEN\n    ) {\n      onError.dispatch({\n        error: new Error('No open socket'),\n      })\n      return false\n    }\n\n    const message = serializeMessage({\n      ...data,\n      sender: _myId,\n      senderTime: Date.now(),\n    })\n    const parts = {}\n\n    const receiver = options.receiver\n    if (receiver) {\n      const receiverPublicKey = _userEncryptKeys.get(receiver)\n      if (receiverPublicKey) {\n        // Create a temporary symmetric encryption key that is only used once since asymmetric encryption is slower.\n        const tempKey = await crypto.subtle.generateKey(\n          {\n            name: SHARED_ENCRYPTION_ALGORITHM,\n            length: 256,\n          },\n          true,\n          ['encrypt', 'decrypt',],\n        )\n        const iv = crypto.getRandomValues(\n          new Uint8Array(12),\n        )\n        const encryptedPayload = await crypto.subtle.encrypt(\n          {\n            iv,\n            name: SHARED_ENCRYPTION_ALGORITHM,\n          },\n          tempKey,\n          new TextEncoder().encode(message),\n        )\n\n        if (!_generatedKeys) {\n          await _generateMyKeys()\n        }\n\n        parts[USER_ENCRYPTION_IV] = bufferToBase64(iv)\n        parts[USER_ENCRYPTION_KEY] = bufferToBase64(\n          await crypto.subtle.encrypt(\n            {\n              name: USER_ENCRYPTION_ALGORITHM,\n            },\n            receiverPublicKey,\n            await crypto.subtle.exportKey(\n              'raw',\n              tempKey,\n            ),\n          ),\n        )\n        parts[USER_ENCRYPTION_PAYLOAD] = bufferToBase64(encryptedPayload)\n        parts[USER_ENCRYPTION_SIGNATURE] = bufferToBase64(\n          await crypto.subtle.sign(\n            USER_SIGNATURE_ALGORITHM,\n            _mySignKeys.privateKey,\n            encryptedPayload,\n          ),\n        )\n      } else if (!options.allowUnencrypted) {\n        onError.dispatch({\n          error: new Error('No public key for ' + receiver),\n        })\n        return false\n      } else {\n        parts[USER_DIRECT_PAYLOAD] = message\n      }\n\n      parts[USER] = receiver\n    } else if (options.server) {\n      parts[SERVER_PAYLOAD] = message\n    } else if (_sharedKey) {\n      const iv = crypto.getRandomValues(\n        new Uint8Array(12),\n      )\n\n      parts[SHARED_ENCRYPTION_IV] = bufferToBase64(iv)\n      parts[SHARED_ENCRYPTION_PAYLOAD] = bufferToBase64(\n        await crypto.subtle.encrypt(\n          {\n            iv,\n            name: SHARED_ENCRYPTION_ALGORITHM,\n          },\n          _sharedKey,\n          new TextEncoder().encode(message),\n        ),\n      )\n    } else {\n      onError.dispatch(\n        new Error('Trying to send without valid destination')\n      )\n      return false\n    }\n\n    _socket.send(\n      encode(\n        parts,\n        stringToBase64,\n      ),\n    )\n    return true\n  }\n\n  /**\n   * Sends a message to the server if the current user is the room creator.\n   *\n   * @param {Object<string, any>} data - The message data to send.\n   * @returns {boolean} True if the message was sent successfully, false otherwise.\n   */\n  const messageServer = (\n    data,\n  ) => (\n    _myId\n    && _myId === _creatorId\n    && _message(data, {\n      server: true,\n    })\n  )\n  /**\n   * Sends a message to a specific user.\n   *\n   * @param {Object<string, any>} data - The message data to send.\n   * @param {string} userId - The ID of the user to send the message to.\n   * @returns {boolean} True if the message was sent successfully, false otherwise.\n   */\n  const messageUser = (\n    data,\n    userId,\n  ) => (\n    userId\n    && _message(data, {\n      receiver: userId,\n    })\n  )\n\n  /**\n   * Generates a verification code string from the stored hash for the specified user.\n   *\n   * @param {string} userId - The ID of the user.\n   * @param {number} [codeLength=6] - The length of the verification code.\n   * @returns {string|boolean} The verification code string or false if no hash is stored.\n   */\n  const getVerificationCode = (\n    userId,\n    codeLength = 6,\n  ) => {\n    if (!_userVerification.has(userId)) {\n      return false\n    }\n    const hashArray = _userVerification.get(userId)\n    let code = ''\n    for (let i = 0; i < codeLength; i++) {\n      const index = hashArray[i] % IDENTIFIABLE_CHARACTERS.length\n      code += IDENTIFIABLE_CHARACTERS[index]\n    }\n    return code\n  }\n\n  return {\n    onConnection,\n    onError,\n    onMessage,\n\n    onRoomJoin,\n    onRoomLeave,\n\n    onUserJoin,\n    onUserLeave,\n    onUserVerified,\n    onUserVerificationCode,\n\n    messageRoom: (\n      data,\n    ) => _message(data),\n    messageServer,\n    messageUser,\n\n    closeRoom: (\n    ) => messageServer({\n      type: ROOM_CLOSED,\n    }),\n    /**\n     * Creates a new room and joins it.\n     *\n     * @param {Object<string, any>} [options={}] - Options for creating the room.\n     * @returns {Object<string, any>|undefined} Room creation data or undefined if failed.\n     */\n    createRoom: async (\n      options = {},\n    ) => {\n      if (\n        _connectionState\n        && _connectionState !== CONNECTION_DISCONNECTED\n      ) {\n        return\n      }\n      _setConnectionState(CONNECTION_CONNECTING)\n\n      if (options.publicData) {\n        _publicData = options.publicData\n      }\n      if (options.verifyPublicData) {\n        _publicDataVerify = options.verifyPublicData\n      }\n\n      try {\n        await new Promise((\n          resolve,\n          reject,\n        ) => {\n          const worker = new Worker(\n            URL.createObjectURL(\n              new Blob([SHARED_KEY_GENERATOR,], {\n                type: 'text/javascript',\n              }),\n            ),\n          )\n\n          worker.addEventListener('message', (\n            event,\n          ) => {\n            if (event.data.success) {\n              _sharedKey = event.data.sharedKey\n              resolve()\n            } else {\n              reject(\n                new Error(event.data.error)\n              )\n            }\n            worker.terminate()\n          })\n\n          worker.addEventListener('error', (\n            error,\n          ) => {\n            reject(error)\n            worker.terminate()\n          })\n\n          worker.postMessage({\n            type: 'SHARED_KEY',\n          })\n        })\n      } catch (error) {\n        _setConnectionState(CONNECTION_DISCONNECTED)\n        onError.dispatch({\n          error,\n        })\n        return\n      }\n\n      const url = new URL(\n        httpUrl\n        + createRoomEndpoint\n      )\n      if (options.limit) {\n        url.searchParams.append(\n          'limit',\n          options.limit,\n        )\n      }\n\n      const response = await fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          Accept: contentType,\n        },\n      })\n      if (!response.ok) {\n        throw new Error('Failed to create room')\n      }\n\n      let data = await response.text()\n      data = deserializeMessage(data)\n\n      _myId = data.userId\n\n      _joinRoom(\n        data.roomCode,\n        data.creatorSecret,\n      )\n\n      return data\n    },\n    /**\n     * Joins an existing room.\n     *\n     * @param {string} roomCode - The code of the room to join.\n     * @param {Object<string, any>} [options={}] - Options for joining the room.\n     */\n    joinRoom: (\n      roomCode,\n      options = {},\n    ) => {\n      if (options.publicData) {\n        _publicData = options.publicData\n      }\n      if (options.verifyPublicData) {\n        _publicDataVerify = options.verifyPublicData\n      }\n      _joinRoom(\n        roomCode,\n      )\n    },\n    leaveRoom,\n    kickUser,\n\n    getVerificationCode,\n    /**\n     * Verifies a user with the provided verification code.\n     *\n     * @param {string} userId - The ID of the user to verify.\n     * @param {string} code - The verification code.\n     * @returns {boolean} True if the verification was successful, false otherwise.\n     */\n    verifyUser: async (\n      userId,\n      code,\n    ) => {\n      if (\n        _myId !== _creatorId\n        || !code\n      ) {\n        return false\n      }\n\n      const expectedCode = getVerificationCode(\n        userId,\n        code.length,\n      )\n      if (\n        !expectedCode\n        || !code\n        || expectedCode !== code\n      ) {\n        return false\n      }\n      _userVerified.set(userId, true)\n\n      const derivedKey = _userDerivedKeys.get(userId)\n      if (!derivedKey) {\n        return false\n      }\n\n      _message({\n        type: EXCHANGE_2,\n        privateData: _privateData,\n      }, {\n        receiver: userId,\n      })\n\n      return true\n    },\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "3D2DE4CCD951995064756E2164756E21",
  "names": []
}