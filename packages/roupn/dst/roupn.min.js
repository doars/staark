var gr=Object.defineProperty,Rr=Object.defineProperties;var Ir=Object.getOwnPropertyDescriptors;var We=Object.getOwnPropertySymbols;var Nr=Object.prototype.hasOwnProperty,Cr=Object.prototype.propertyIsEnumerable;var Qe=(t,e,r)=>e in t?gr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ee=(t,e)=>{for(var r in e||(e={}))Nr.call(e,r)&&Qe(t,r,e[r]);if(We)for(var r of We(e))Cr.call(e,r)&&Qe(t,r,e[r]);return t},re=(t,e)=>Rr(t,Ir(e));var B=(t,e,r)=>new Promise((n,s)=>{var d=A=>{try{u(r.next(A))}catch(P){s(P)}},G=A=>{try{u(r.throw(A))}catch(P){s(P)}},u=A=>A.done?n(A.value):Promise.resolve(A.value).then(d,G);u((r=r.apply(t,e)).next())});var he="CONNECTED",_e="CONNECTING",J="DISCONNECTED",ge="DISCONNECTING",Ze="PENDING_VERIFICATION";var te="_KA",Re="_KO",qe="_RC",$e="_RJ";var Ie="_SU",Ne="_SS",er="_UJ",rr="_UK",tr="_UL",Ce="_UV";var I=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},nr=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},sr=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let s=0;s<e.length;s+=n){let d=e.subarray(s,s+n);r+=String.fromCharCode(...d)}return btoa(r)},N=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let s=0;s<e.length;s+=n){let d=e.subarray(s,s+n);r+=String.fromCharCode(...d)}return btoa(r)};var L=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var or="|",ir=":",cr=(t,e)=>{let r=[];for(let n in t){let s=t[n];s!=null&&r.push(n+ir+e(String(s)))}return r.join(or)},ar=(t,e)=>{let r={},n=t.split(or);for(let s of n){let d=s.indexOf(ir);if(d>0){let G=s.substring(0,d),u=s.substring(d+1);r[G]=e(u)}}return r};var dr=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,s=(t-e+(t-r))/2;return{delay:n,offset:s,adjusted:r-n+s}};var xr="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",xe="ABCDEFGHKMNPQRSTUVWXYZ23456789",lr=(t=24,e=xr)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var ne="ECDH",Ae="P-256",se="raw",W="SHA-256",oe="spki",O="AES-GCM";var ie="RSA-OAEP",H="RSASSA-PKCS1-v1_5",pr="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,s])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:s})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",yr="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Te="S",ur="T",Oe="E",Ke="I",be="U",we="D",Ue="V",De="K",Se="P",Le="G";var Er=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:s="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:G="http://localhost:3000",wsUrl:u="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:P=60*1e3}=t,_,x,F,T,X,D,o,y,m,a,h=[],S,ce,V=new Map,Q=new Map,Z=new Map,ae=new Map,k=J,j=()=>(!x&&!F&&(F=new Promise((c,l)=>{let g=new Worker(URL.createObjectURL(new Blob([pr],{type:"text/javascript"})));g.addEventListener("message",p=>{if(p.data.success)X=p.data.myEncryptKeys,m=p.data.mySignKeys,D=p.data.myExchangeKeys,o=p.data.myPublicEncryptKey,y=p.data.myPublicSignKey,x=!0,F=null,c();else{let f=new Error(p.data.error);C.dispatch({error:f}),l(f)}g.terminate()}),g.addEventListener("error",p=>{C.dispatch({error:p}),l(p),g.terminate()}),g.postMessage({type:"USER_KEYS"})})),F);j();let C=L(),Me=L(),He=L(),ke=L(),Ye=L(),Ge=L(),de=L(),Fe=L(),Ve=L(),Y=c=>{k!==c&&(k=c,Ve.dispatch({state:c}))},je=c=>B(null,null,function*(){let l=V.get(c);l&&(ae.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest(W,new TextEncoder().encode(ce+N(yield crypto.subtle.exportKey("raw",l))))))),Fe.dispatch({userId:c,code:me(c)}))}),le=()=>{k===J||k===ge||(Y(ge),S&&S.close(),_=x=F=T=X=D=o=y=m=a=h=S=null,V.clear(),Q.clear(),Z.clear(),ae.clear(),j(),Y(J))},Be=(c,l=null)=>{if(!l&&k&&k!==J)return;Y(_e),ce=c;let g=new URL(u+d);g.searchParams.append("code",ce),l&&g.searchParams.append("creator",l),S=new WebSocket(g.toString()),S.addEventListener("close",p=>{ke.dispatch({event:p}),le()}),S.addEventListener("error",p=>{C.dispatch({event:p}),le()}),S.addEventListener("message",p=>B(null,null,function*(){Je(ar(p.data,nr),p.data)}))},Je=(c,l,g=!1)=>B(null,null,function*(){let{[Te]:p,[ur]:f,[Ke]:R,[Oe]:b,[we]:w,[Ue]:U,[De]:q,[Se]:Xe,[Le]:ze,[be]:_r}=c,i,$,ye;if(p?ye=p:w?ye=w:ye=l,b){if(!a||!g&&h.length>0){h.push({time:Date.now(),parts:c,raw:l}),h.length>A&&h.shift();return}if(!R){C.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:I(R),name:O},a,I(b)),i=new TextDecoder().decode(i)}else if(Xe){if(!ze||!q||!U)return;x||(yield j());let E=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:I(U),name:O},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ie},X.privateKey,I(q)),{name:O},!0,["encrypt","decrypt"]),I(Xe))));if(E.type===te)$=E;else{let v=E.sender;if(!v){C.dispatch({error:new Error("Message from unknown sender")});return}let M=Z.get(v);if(!M){C.dispatch({error:new Error("No public key for "+v)});return}if(!(yield crypto.subtle.verify(H,M,I(ze),dataBuffer))){C.dispatch({error:new Error("Invalid signature from "+v)});return}$=E}}else i=ye;if(!$)try{$=r(i)}catch(E){C.dispatch({error:new Error("Failed to parse message "+l)});return}switch(i=$,i.type){case Re:if(T===_){let E=i.sender;Q.set(E,yield crypto.subtle.importKey(oe,I(i.publicEncryptKey),{hash:W,name:ie},!0,["encrypt"]));let v=yield crypto.subtle.importKey(oe,I(i.publicSignKey),{hash:W,name:H},!0,["verify"]),M=I(i.publicExchangeKey);if(!(yield crypto.subtle.verify(H,v,I(i.signature),M))){C.dispatch({error:new Error("Invalid signature for exchange from "+E)});return}Z.set(E,v),x||(yield j()),V.set(E,yield crypto.subtle.deriveKey({name:ne,public:yield crypto.subtle.importKey(se,M,{name:ne,namedCurve:Ae},!0,[])},D.privateKey,{length:256,name:O},!0,["encrypt","decrypt"]));let ue=yield crypto.subtle.exportKey(se,D.publicKey);z({type:te,publicEncryptKey:N(o),publicExchangeKey:N(ue),publicSignKey:N(y),signature:N(yield crypto.subtle.sign(H,m.privateKey,ue))},{receiver:E}),je(E)}break;case te:if(_r===T&&i.sender===_){if(i.publicSignKey){let E=yield crypto.subtle.importKey(oe,I(i.publicSignKey),{hash:W,name:H},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(H,E,I(i.signature),I(i.publicExchangeKey)))){C.dispatch({error:new Error("Invalid signature for exchange from "+_)}),le();return}Z.set(_,E)}if(i.publicEncryptKey&&Q.set(_,yield crypto.subtle.importKey(oe,I(i.publicEncryptKey),{hash:W,name:ie},!0,["encrypt"])),i.publicExchangeKey&&(x||(yield j()),V.set(_,yield crypto.subtle.deriveKey({name:ne,public:yield crypto.subtle.importKey(se,I(i.publicExchangeKey),{name:ne,namedCurve:Ae},!0,[])},D.privateKey,{length:256,name:O},!0,["encrypt","decrypt"]))),i.sharedKey&&i.sharedKeyIv){let E=V.get(_);if(!E){C.dispatch({error:new Error("No derived key for host "+_)});return}if(a=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:I(i.sharedKeyIv),name:O},E,I(i.sharedKey)),{name:O},!0,["encrypt","decrypt"]),de.dispatch({userId:T}),h.length>0){let v=Date.now();for(h=h.filter(M=>v-M.time<P);h.length>0;){let{parts:M,raw:ue}=h.shift();Je(M,ue,!0)}}Y(he)}else je(_)}break;case $e:if(_=i.creatorId,T=i.userId,He.dispatch({creatorId:i.creatorId,roomCode:ce,userId:i.userId,users:i.users}),T!==_){Y(Ze),x||(yield j());let E=yield crypto.subtle.exportKey(se,D.publicKey);z({type:Re,publicEncryptKey:N(o),publicExchangeKey:N(E),publicSignKey:N(y),signature:N(yield crypto.subtle.sign(H,m.privateKey,E))},{allowUnencrypted:!0,receiver:_})}else Y(he);break;case tr:Ge.dispatch({userId:i.userId}),V.delete(i.userId),Q.delete(i.userId),Z.delete(i.userId);break;case er:Ye.dispatch({userId:i.userId});break;case Ce:de.dispatch({userId:i.userId});break;default:Me.dispatch({data:i,time:dr(f,i==null?void 0:i.senderTime)});break}}),z=(g,...p)=>B(null,[g,...p],function*(c,l={}){if(!S||S.readyState!==WebSocket.OPEN)return C.dispatch({error:new Error("No open socket")}),!1;let f=n(re(ee({},c),{sender:T,senderTime:Date.now()})),R={};if(l.receiver){let b=Q.get(l.receiver);if(b){let w=yield crypto.subtle.generateKey({name:O,length:256},!0,["encrypt","decrypt"]),U=crypto.getRandomValues(new Uint8Array(12)),q=yield crypto.subtle.encrypt({iv:U,name:O},w,new TextEncoder().encode(f));x||(yield j()),R[Le]=N(yield crypto.subtle.sign(H,m.privateKey,q)),R[De]=N(yield crypto.subtle.encrypt({name:ie},b,yield crypto.subtle.exportKey("raw",w))),R[Se]=N(q),R[Ue]=N(U)}else if(l.allowUnencrypted)R[we]=f;else return C.dispatch({error:new Error("No public key for "+l.receiver)}),!1;R[be]=l.receiver}else if(l.server)R[Te]=f;else if(a){let b=crypto.getRandomValues(new Uint8Array(12));R[Ke]=N(b),R[Oe]=N(yield crypto.subtle.encrypt({iv:b,name:O},a,new TextEncoder().encode(f)))}else return C.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(cr(R,sr)),!0}),pe=c=>T&&T===_&&z(c,{server:!0}),hr=(c,l)=>l&&z(c,{receiver:l}),me=(c,l=6)=>{if(!ae.has(c))return!1;let g=ae.get(c),p="";for(let f=0;f<l;f++){let R=g[f]%xe.length;p+=xe[R]}return p};return{onConnection:Ve,onError:C,onMessage:Me,onRoomJoin:He,onRoomLeave:ke,onUserJoin:Ye,onUserLeave:Ge,onUserVerified:de,onUserVerificationCode:Fe,messageRoom:c=>z(c),messageServer:pe,messageUser:hr,closeRoom:()=>pe({type:qe}),createRoom:(...l)=>B(null,[...l],function*(c={}){if(k&&k!==J)return;Y(_e);try{yield new Promise((R,b)=>{let w=new Worker(URL.createObjectURL(new Blob([yr],{type:"text/javascript"})));w.addEventListener("message",U=>{U.data.success?(a=U.data.sharedKey,R()):b(new Error(U.data.error)),w.terminate()}),w.addEventListener("error",U=>{b(U),w.terminate()}),w.postMessage({type:"SHARED_KEY"})})}catch(R){Y(J),C.dispatch({error:R});return}let g=new URL(G+s);c.limit&&g.searchParams.append("limit",c.limit);let p=yield fetch(g.toString(),{method:"GET",headers:{Accept:e}});if(!p.ok)throw new Error("Failed to create room");let f=yield p.text();return f=r(f),T=f.userId,Be(f.roomCode,f.creatorSecret),f}),joinRoom:c=>Be(c),leaveRoom:le,kickUser:c=>pe({type:rr,userId:c}),getVerificationCode:me,verifyUser:(c,l)=>B(null,null,function*(){if(T!==_||!l)return!1;let g=me(c,l.length);if(!g||!l||g!==l)return!1;let p=V.get(c);if(!p)return!1;let f=crypto.getRandomValues(new Uint8Array(12));return z({type:te,sharedKey:N(yield crypto.subtle.encrypt({iv:f,name:O},p,yield crypto.subtle.exportKey("raw",a))),sharedKeyIv:N(f)},{receiver:c}),de.dispatch({userId:c}),pe({type:Ce,userId:c}),!0})}};var K=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=K(t[r]);return e}return t};var Pe=(t,e,r)=>{let n=t;for(let s=0;s<e.length-1;s++){let d=e[s];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=K(r)},mr=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},fe=(t,e,r=[])=>{let n=[];for(let s in t){let d=[...r,s];s in e?typeof t[s]=="object"&&typeof e[s]=="object"?n.unshift(...fe(t[s],e[s],d)):t[s]!==e[s]&&n.unshift({type:"set",path:d,old:K(t[s]),new:K(e[s])}):n.unshift({type:"delete",path:d,old:K(t[s])})}for(let s in e)s in t||n.unshift({type:"set",path:[...r,s],new:K(e[s])});return n},Ee=(t,e)=>{for(let r of e)r.type==="set"?Pe(t,r.path,r.new):r.type==="delete"&&mr(t,r.path);return t},ve=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?mr(t,r.path):Pe(t,r.path,r.old):r.type==="delete"&&Pe(t,r.path,r.old);return t};var st=(t={},e={},r={})=>{let n=Er(t),{messageRoom:s}=n,{windowPerUser:d=16,synchronisationInterval:G=60*1e3}=t,u=[],A,P=0,_=0,x=d,F=o=>{let y=lr(),m=o.length>0?o[0].identifier:null;u.unshift({identifier:y,previous:m,sender:e.userId,stateDelta:o,time:{adjusted:Date.now()+P-_}}),u.length>x&&u.splice(x),s({identifier:y,previous:m,stateDelta:o,type:Ie}),D()},T=()=>{if(e.previousState){let o=fe(e.previousState,r);o.length>0&&F(o)}},X=()=>{e.users.length>1&&s({type:Ne,state:K(r)})},D=()=>{e.previousState=K(r)};return n.onMessage.addListener(({data:o,time:y})=>{if(!(o.sender===e.userId||o.receiver&&o.receiver!==e.userId)){if(P=(P+y.delay)/2,_=(_+y.offset)/2,o.type===Ne){let m=0;for(;m<u.length&&!(u[m].time.adjusted>=y.adjusted);m++);u.splice(0,m);for(let a in r)delete r[a];for(let a in o.state)r[a]=o.state[a];for(let a=0;a<u.length;a++)Ee(r,u[a].stateDelta);D()}else if(o.type===Ie){let m=!0;for(let a=0;a<u.length;a++){let h=u[a];if(h.identifier===o.previous||h.previous===o.previous&&h.time.adjusted<y.adjusted){u.splice(a,0,re(ee({},o),{time:y})),m=!1;break}}m&&u.unshift(re(ee({},o),{time:y}));for(let a=0;a<u.length;a++){let h=u[a];if(h.identifier===o.identifier)break;ve(r,h.stateDelta)}for(let a=0;a<u.length;a++){let h=u[a];if(Ee(r,h.stateDelta),h.identifier===o.identifier)break}D()}}}),n.onConnection.addListener(({state:o})=>{e.connectionState=o}),n.onRoomJoin.addListener(({creatorId:o,roomCode:y,userId:m,users:a})=>{e.creatorId=o,e.roomCode=y,e.userId=m,e.users=a,e.verifiedUsers=[],e.previousState=K(r),m===o&&(e.verifiedUsers.push(m),A=setInterval(X,G))}),n.onRoomLeave.addListener(()=>{for(let o in e)delete e[o];A&&clearInterval(A)}),n.onUserJoin.addListener(({userId:o})=>{e.users.push(o),x=d+d*e.users.length}),n.onUserVerificationCode.addListener(o=>{o.userId===e.creatorId&&(e.verificationCode=o.code)}),n.onUserVerified.addListener(({userId:o})=>{e.verifiedUsers.push(o),x=d+d*e.users.length,e.userId===e.creatorId&&X()}),n.onUserLeave.addListener(({userId:o})=>{for(let y=0;y<e.users.length;y++)if(e.users[y]===o){e.users.splice(y,1);break}for(let y=0;y<e.verifiedUsers.length;y++)if(e.verifiedUsers[y]===o){e.verifiedUsers.splice(y,1);break}x=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:T},n)};export{Er as createClientConnector,st as createClientSynchronizer};
