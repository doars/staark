var Or=Object.defineProperty,Dr=Object.defineProperties;var wr=Object.getOwnPropertyDescriptors;var or=Object.getOwnPropertySymbols;var Kr=Object.prototype.hasOwnProperty,Ur=Object.prototype.propertyIsEnumerable;var ir=(t,e,r)=>e in t?Or(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ae=(t,e)=>{for(var r in e||(e={}))Kr.call(e,r)&&ir(t,r,e[r]);if(or)for(var r of or(e))Ur.call(e,r)&&ir(t,r,e[r]);return t},de=(t,e)=>Dr(t,wr(e));var z=(t,e,r)=>new Promise((n,o)=>{var d=x=>{try{E(r.next(x))}catch(H){o(H)}},j=x=>{try{E(r.throw(x))}catch(H){o(H)}},E=x=>x.done?n(x.value):Promise.resolve(x.value).then(d,j);E((r=r.apply(t,e)).next())});var Ae="CONNECTED",be="CONNECTING",W="DISCONNECTED",Te="DISCONNECTING",cr="PENDING_VERIFICATION";var Oe="_X0",ge="_X1",De="_X2",we="_X3",Ke="_X4",ar="_RC",dr="_RJ";var Ue="_SU",Se="_SS",pr="_UJ",ur="_UK",lr="_UL",Pe="_UV";var Sr="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",Le="ABCDEFGHKMNPQRSTUVWXYZ23456789",fr=(t=24,e=Sr)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var R=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},yr=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},Er=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)},I=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)};var L=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var mr="|",_r=":",hr=(t,e)=>{let r=[];for(let n in t){let o=t[n];o!=null&&r.push(n+_r+e(String(o)))}return r.join(mr)},gr=(t,e)=>{let r={},n=t.split(mr);for(let o of n){let d=o.indexOf(_r);if(d>0){let j=o.substring(0,d),E=o.substring(d+1);r[j]=e(E)}}return r};var Rr=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,o=(t-e+(t-r))/2;return{delay:n,offset:o,adjusted:r-n+o}};var pe="ECDH",ve="P-256",ue="raw",$="SHA-256",le="spki",v="AES-GCM";var fe="RSA-OAEP",G="RSASSA-PKCS1-v1_5",Ir="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,o])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:o})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",Nr="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var He="S",Cr="T",Me="E",ke="I",Ge="U",Ye="D",Ve="V",Fe="K",je="P",Xe="G";var Ar=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:o="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:j="http://localhost:3000",wsUrl:E="http://localhost:3000",messageBufferMaxCount:x=50,messageBufferMaxDuration:H=60*1e3}=t,b=W,u,w,X,Q,K,s,y,_,p,A,ee,M,B,ye,Y,U=[],S,Z=new Map,re=new Map,te=new Map,Ee=new Map,Ne=new Map,J=()=>(!w&&!X&&(X=new Promise((c,a)=>{let h=new Worker(URL.createObjectURL(new Blob([Ir],{type:"text/javascript"})));h.addEventListener("message",l=>{if(l.data.success)Q=l.data.myEncryptKeys,p=l.data.mySignKeys,K=l.data.myExchangeKeys,y=l.data.myPublicEncryptKey,_=l.data.myPublicSignKey,w=!0,X=null,c();else{let m=new Error(l.data.error);N.dispatch({error:m}),a(m)}h.terminate()}),h.addEventListener("error",l=>{N.dispatch({error:l}),a(l),h.terminate()}),h.postMessage({type:"USER_KEYS"})})),X);J();let N=L(),ze=L(),We=L(),Qe=L(),Ze=L(),qe=L(),me=L(),$e=L(),er=L(),V=c=>{b!==c&&(b=c,er.dispatch({state:c}))},rr=c=>z(null,null,function*(){let a=Z.get(c);a&&(Ee.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest($,new TextEncoder().encode(ye+I(yield crypto.subtle.exportKey("raw",a))))))),$e.dispatch({userId:c,code:xe(c)}))}),q=()=>{b===W||b===Te||(V(Te),S&&S.close(),u=w=X=s=Q=K=y=_=p=A=ee=M=B=Y=U=S=null,Z.clear(),re.clear(),te.clear(),Ee.clear(),Ne.clear(),J(),V(W))},Ce=c=>_e({type:ur,userId:c}),tr=(c,a=null)=>{if(!a&&b&&b!==W)return;V(be),ye=c;let h=new URL(E+d);h.searchParams.append("code",ye),a&&h.searchParams.append("creator",a),S=new WebSocket(h.toString()),S.addEventListener("close",l=>{Qe.dispatch({event:l}),q()}),S.addEventListener("error",l=>{N.dispatch({event:l}),q()}),S.addEventListener("message",l=>z(null,null,function*(){nr(gr(l.data,yr),l.data)}))},nr=(c,a,h=!1)=>z(null,null,function*(){let{[He]:l,[Cr]:m,[ke]:g,[Me]:P,[Ye]:C,[Ve]:O,[Fe]:ne,[je]:se,[Xe]:sr,[Ge]:oe}=c,i,ie,he;if(l?he=l:C?he=C:he=a,P){if(!Y||!h&&U.length>0){U.push({time:Date.now(),parts:c,raw:a}),U.length>x&&U.shift();return}if(!g){N.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:R(g),name:v},Y,R(P)),i=new TextDecoder().decode(i)}else if(se){if(!sr||!ne||!O){N.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}w||(yield J());let f=R(se),D=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:R(O),name:v},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:fe},Q.privateKey,R(ne)),{name:v},!0,["encrypt","decrypt"]),f)));if(D.type===ge)ie=D;else{let k=D.sender;if(!k){N.dispatch({error:new Error("Message from unknown sender")});return}let ce=te.get(k);if(!ce){N.dispatch({error:new Error("No public key for "+k)});return}if(!(yield crypto.subtle.verify(G,ce,R(sr),f))){N.dispatch({error:new Error("Invalid signature from "+k)});return}ie=D}}else i=he;if(!ie)try{ie=r(i)}catch(f){N.dispatch({error:new Error("Failed to parse message "+a)});return}switch(i=ie,i.type){case dr:if(u=i.creatorId,s=i.userId,We.dispatch({creatorId:i.creatorId,roomCode:ye,userId:i.userId,users:i.users}),s===u)V(Ae);else{V(cr),w||(yield J());let f=yield crypto.subtle.exportKey(ue,K.publicKey);F({type:Oe,publicData:typeof M=="function"?M():M,publicEncryptKey:I(y),publicExchangeKey:I(f),publicSignKey:I(_),signature:I(yield crypto.subtle.sign(G,p.privateKey,f))},{allowUnencrypted:!0,receiver:u})}break;case Oe:if(oe===u&&s===u){let f=i.sender;if(B&&!B({data:i.publicData,userId:f})){Ce(f);return}re.set(f,yield crypto.subtle.importKey(le,R(i.publicEncryptKey),{hash:$,name:fe},!0,["encrypt"]));let D=yield crypto.subtle.importKey(le,R(i.publicSignKey),{hash:$,name:G},!0,["verify"]),k=R(i.publicExchangeKey);if(!(yield crypto.subtle.verify(G,D,R(i.signature),k))){N.dispatch({error:new Error("Invalid signature for exchange from "+f)});return}te.set(f,D),w||(yield J()),Z.set(f,yield crypto.subtle.deriveKey({name:pe,public:yield crypto.subtle.importKey(ue,k,{name:pe,namedCurve:ve},!0,[])},K.privateKey,{length:256,name:v},!0,["encrypt","decrypt"]));let ce=yield crypto.subtle.exportKey(ue,K.publicKey);F({type:ge,publicData:typeof M=="function"?M():M,publicEncryptKey:I(y),publicExchangeKey:I(ce),publicSignKey:I(_),signature:I(yield crypto.subtle.sign(G,p.privateKey,ce))},{receiver:f}),rr(f)}break;case ge:if(oe===s&&i.sender===u){if(B&&!B({data:i.publicData,userId:u})){q();return}let f=yield crypto.subtle.importKey(le,R(i.publicSignKey),{hash:$,name:G},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(G,f,R(i.signature),R(i.publicExchangeKey)))){N.dispatch({error:new Error("Invalid signature for exchange from "+u)}),q();return}te.set(u,f),re.set(u,yield crypto.subtle.importKey(le,R(i.publicEncryptKey),{hash:$,name:fe},!0,["encrypt"])),w||(yield J()),Z.set(u,yield crypto.subtle.deriveKey({name:pe,public:yield crypto.subtle.importKey(ue,R(i.publicExchangeKey),{name:pe,namedCurve:ve},!0,[])},K.privateKey,{length:256,name:v},!0,["encrypt","decrypt"])),rr(u)}break;case De:if(oe===s&&i.sender===u){if(ee&&!ee({data:i.privateData,userId:u})){q();return}F({type:we,privateData:A},{receiver:u})}break;case we:if(oe===u&&s===u){let f=i.sender;if(!Ne.get(f)||ee&&!ee({data:i.privateData,userId:f})){Ce(f);return}F({type:Ke,sharedKey:I(yield crypto.subtle.exportKey("raw",Y))},{receiver:f}),me.dispatch({userId:f}),_e({type:Pe,userId:f})}break;case Ke:if(oe===s&&i.sender===u){if(Y=yield crypto.subtle.importKey("raw",R(i.sharedKey),{name:v},!0,["encrypt","decrypt"]),me.dispatch({userId:s}),U.length>0){let f=Date.now();for(U=U.filter(D=>f-D.time<H);U.length>0;){let{parts:D,raw:k}=U.shift();nr(D,k,!0)}}V(Ae)}break;case lr:qe.dispatch({userId:i.userId}),Z.delete(i.userId),re.delete(i.userId),te.delete(i.userId);break;case pr:Ze.dispatch({userId:i.userId});break;case Pe:me.dispatch({userId:i.userId});break;default:ze.dispatch({data:i,time:Rr(m,i==null?void 0:i.senderTime)});break}}),F=(h,...l)=>z(null,[h,...l],function*(c,a={}){if(!S||S.readyState!==WebSocket.OPEN)return N.dispatch({error:new Error("No open socket")}),!1;let m=n(de(ae({},c),{sender:s,senderTime:Date.now()})),g={},P=a.receiver;if(P){let C=re.get(P);if(C){let O=yield crypto.subtle.generateKey({name:v,length:256},!0,["encrypt","decrypt"]),ne=crypto.getRandomValues(new Uint8Array(12)),se=yield crypto.subtle.encrypt({iv:ne,name:v},O,new TextEncoder().encode(m));w||(yield J()),g[Ve]=I(ne),g[Fe]=I(yield crypto.subtle.encrypt({name:fe},C,yield crypto.subtle.exportKey("raw",O))),g[je]=I(se),g[Xe]=I(yield crypto.subtle.sign(G,p.privateKey,se))}else if(a.allowUnencrypted)g[Ye]=m;else return N.dispatch({error:new Error("No public key for "+P)}),!1;g[Ge]=P}else if(a.server)g[He]=m;else if(Y){let C=crypto.getRandomValues(new Uint8Array(12));g[ke]=I(C),g[Me]=I(yield crypto.subtle.encrypt({iv:C,name:v},Y,new TextEncoder().encode(m)))}else return N.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(hr(g,Er)),!0}),_e=c=>s&&s===u&&F(c,{server:!0}),Tr=(c,a)=>a&&F(c,{receiver:a}),xe=(c,a=6)=>{if(!Ee.has(c))return!1;let h=Ee.get(c),l="";for(let m=0;m<a;m++){let g=h[m]%Le.length;l+=Le[g]}return l};return{onConnection:er,onError:N,onMessage:ze,onRoomJoin:We,onRoomLeave:Qe,onUserJoin:Ze,onUserLeave:qe,onUserVerified:me,onUserVerificationCode:$e,messageRoom:c=>F(c),messageServer:_e,messageUser:Tr,closeRoom:()=>_e({type:ar}),createRoom:(...a)=>z(null,[...a],function*(c={}){if(b&&b!==W)return;V(be),c.publicData&&(M=c.publicData),c.verifyPublicData&&(B=c.verifyPublicData);try{yield new Promise((g,P)=>{let C=new Worker(URL.createObjectURL(new Blob([Nr],{type:"text/javascript"})));C.addEventListener("message",O=>{O.data.success?(Y=O.data.sharedKey,g()):P(new Error(O.data.error)),C.terminate()}),C.addEventListener("error",O=>{P(O),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(g){V(W),N.dispatch({error:g});return}let h=new URL(j+o);c.limit&&h.searchParams.append("limit",c.limit);let l=yield fetch(h.toString(),{method:"GET",headers:{Accept:e}});if(!l.ok)throw new Error("Failed to create room");let m=yield l.text();return m=r(m),s=m.userId,tr(m.roomCode,m.creatorSecret),m}),joinRoom:(c,a={})=>{a.publicData&&(M=a.publicData),a.verifyPublicData&&(B=a.verifyPublicData),tr(c)},leaveRoom:q,kickUser:Ce,getVerificationCode:xe,verifyUser:(c,a)=>z(null,null,function*(){if(s!==u||!a)return!1;let h=xe(c,a.length);return!h||!a||h!==a||(Ne.set(c,!0),!Z.get(c))?!1:(F({type:De,privateData:A},{receiver:c}),!0)})}};var T=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=T(t[r]);return e}return t};var Be=(t,e,r)=>{let n=t;for(let o=0;o<e.length-1;o++){let d=e[o];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=T(r)},br=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},Re=(t,e,r=[])=>{let n=[];for(let o in t){let d=[...r,o];o in e?typeof t[o]=="object"&&typeof e[o]=="object"?n.unshift(...Re(t[o],e[o],d)):t[o]!==e[o]&&n.unshift({type:"set",path:d,old:T(t[o]),new:T(e[o])}):n.unshift({type:"delete",path:d,old:T(t[o])})}for(let o in e)o in t||n.unshift({type:"set",path:[...r,o],new:T(e[o])});return n},Ie=(t,e)=>{for(let r of e)r.type==="set"?Be(t,r.path,r.new):r.type==="delete"&&br(t,r.path);return t},Je=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?br(t,r.path):Be(t,r.path,r.old):r.type==="delete"&&Be(t,r.path,r.old);return t};var ft=(t={},e={},r={})=>{let n=Ar(t),{messageRoom:o}=n,{windowPerUser:d=16,synchronisationInterval:j=60*1e3}=t,E=[],x,H=0,b=0,u=d,w=s=>{let y=fr(),_=s.length>0?s[0].identifier:null;E.unshift({identifier:y,previous:_,sender:e.userId,stateDelta:s,time:{adjusted:Date.now()+H-b}}),E.length>u&&E.splice(u),o({identifier:y,previous:_,stateDelta:s,type:Ue}),K()},X=()=>{if(e.previousState){let s=Re(e.previousState,r);s.length>0&&w(s)}},Q=()=>{e.users.length>1&&o({type:Se,state:T(r)})},K=()=>{e.previousState=T(r)};return n.onMessage.addListener(({data:s,time:y})=>{if(!(s.sender===e.userId||s.receiver&&s.receiver!==e.userId)){if(H=(H+y.delay)/2,b=(b+y.offset)/2,s.type===Se){let _=0;for(;_<E.length&&!(E[_].time.adjusted>=y.adjusted);_++);E.splice(0,_);for(let p in r)delete r[p];for(let p in s.state)r[p]=s.state[p];for(let p=0;p<E.length;p++)Ie(r,E[p].stateDelta);K()}else if(s.type===Ue){let _=!0;for(let p=0;p<E.length;p++){let A=E[p];if(A.identifier===s.previous||A.previous===s.previous&&A.time.adjusted<y.adjusted){E.splice(p,0,de(ae({},s),{time:y})),_=!1;break}}_&&E.unshift(de(ae({},s),{time:y}));for(let p=0;p<E.length;p++){let A=E[p];if(A.identifier===s.identifier)break;Je(r,A.stateDelta)}for(let p=0;p<E.length;p++){let A=E[p];if(Ie(r,A.stateDelta),A.identifier===s.identifier)break}K()}}}),n.onConnection.addListener(({state:s})=>{e.connectionState=s}),n.onRoomJoin.addListener(({creatorId:s,roomCode:y,userId:_,users:p})=>{e.creatorId=s,e.roomCode=y,e.userId=_,e.users=p,e.verifiedUsers=[],e.previousState=T(r),_===s&&(e.verifiedUsers.push(_),x=setInterval(Q,j))}),n.onRoomLeave.addListener(()=>{for(let s in e)delete e[s];x&&clearInterval(x)}),n.onUserJoin.addListener(({userId:s})=>{e.users.push(s),u=d+d*e.users.length}),n.onUserVerificationCode.addListener(s=>{s.userId===e.creatorId&&(e.verificationCode=s.code)}),n.onUserVerified.addListener(({userId:s})=>{e.verifiedUsers.push(s),u=d+d*e.users.length,e.userId===e.creatorId&&Q()}),n.onUserLeave.addListener(({userId:s})=>{for(let y=0;y<e.users.length;y++)if(e.users[y]===s){e.users.splice(y,1);break}for(let y=0;y<e.verifiedUsers.length;y++)if(e.verifiedUsers[y]===s){e.verifiedUsers.splice(y,1);break}u=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:X},n)};export{Ar as createClientConnector,ft as createClientSynchronizer};
