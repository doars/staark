var U6="CONNECTED",O6="CONNECTING",c="DISCONNECTED",P6="DISCONNECTING",Z0="PENDING_VERIFICATION";var b6="_X0",w6="_X1",N6="_X2",A6="_X3",K6="_X4",J0="_RC",W0="_RJ";var D6="_SU",h6="_SS",X0="_UJ",z0="_UK",j0="_UL",m6="_UV";var T6="ABCDEFGHKMNPQRSTUVWXYZ23456789",F0=($=24,x="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")=>{let q="";for(let Q=0;Q<$;Q++)q+=x.charAt(Math.floor(Math.random()*x.length));return q};var C=($)=>{let x=atob($);return Uint8Array.from(x,(q)=>q.charCodeAt(0)).buffer},Y0=($)=>{let x=atob($),q=Uint8Array.from(x,(Q)=>Q.charCodeAt(0));return new TextDecoder().decode(q)},V0=($)=>{let x=new TextEncoder().encode($);if(x.length<65536)return btoa(String.fromCharCode(...x));let q="",Q=65536;for(let J=0;J<x.length;J+=Q){let Y=x.subarray(J,J+Q);q+=String.fromCharCode(...Y)}return btoa(q)},U=($)=>{let x=new Uint8Array($);if(x.length<65536)return btoa(String.fromCharCode(...x));let q="",Q=65536;for(let J=0;J<x.length;J+=Q){let Y=x.subarray(J,J+Q);q+=String.fromCharCode(...Y)}return btoa(q)};var R=()=>{let $=new Map;return{addListener:(x,q)=>{if(!$.has(x))$.set(x,q)},removeListener:(x)=>{$.delete(x)},dispatch:(x)=>{for(let[q,Q]of $.entries())if(q(x),Q&&Q.once)$.delete(q)}}};var B0=($,x)=>{let q=[];for(let Q in $){let J=$[Q];if(J!==null&&J!==void 0)q.push(Q+":"+x(String(J)))}return q.join("|")},G0=($,x)=>{let q={},Q=$.split("|");for(let J of Q){let Y=J.indexOf(":");if(Y>0){let r=J.substring(0,Y),M=J.substring(Y+1);q[r]=x(M)}}return q};var L0=($,x)=>{let q=Date.now();if(!$)return{delay:0,offset:0,adjusted:q};if(!x){let Y=$-q;return{delay:0,offset:Y,adjusted:q+Y}}let Q=q-x,J=($-x+($-q))/2;return{delay:Q,offset:J,adjusted:q-Q+J}};var J6="ECDH",g6="P-256",W6="raw",s="SHA-256",X6="spki",f="AES-GCM",R6=256,z6="RSA-OAEP",u="RSASSA-PKCS1-v1_5",w0="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([$,x,q])=>{Promise.all([crypto.subtle.exportKey("spki",$.publicKey),crypto.subtle.exportKey("spki",x.publicKey)]).then(([Q,J])=>{self.postMessage({success:!0,myEncryptKeys:$,mySignKeys:x,myExchangeKeys:q,myPublicEncryptKey:Q,myPublicSignKey:J})}).catch((Q)=>{self.postMessage({success:!1,error:Q.message})})}).catch(($)=>{self.postMessage({success:!1,error:$.message})})}).toString()+")",M0="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(($)=>{self.postMessage({success:!0,sharedKey:$})}).catch(($)=>{self.postMessage({success:!1,error:$.message})})}).toString()+")";var f6="S",k0="T",l6="E",v6="I",I6="U",E6="D",S6="V",u6="K",y6="P",p6="G";var H0=($={})=>{let{contentType:x="application/json",deserializeMessage:q=JSON.parse,serializeMessage:Q=JSON.stringify,createRoomEndpoint:J="/create-room",joinRoomEndpoint:Y="/join-room",httpUrl:r="http://localhost:3000",wsUrl:M="http://localhost:3000",messageBufferMaxCount:a=50,messageBufferMaxDuration:t=60000}=$,b=c,B,h,y,d,m,Z,G,k,F,O,e,l,p,j6,I,T=[],g,n=new Map,x6=new Map,q6=new Map,F6=new Map,H6=new Map,_=()=>{if(!h&&!y)y=new Promise((W,j)=>{let L=new Worker(URL.createObjectURL(new Blob([w0],{type:"text/javascript"})));L.addEventListener("message",(X)=>{if(X.data.success)d=X.data.myEncryptKeys,F=X.data.mySignKeys,m=X.data.myExchangeKeys,G=X.data.myPublicEncryptKey,k=X.data.myPublicSignKey,h=!0,y=null,W();else{let H=Error(X.data.error);w.dispatch({error:H}),j(H)}L.terminate()}),L.addEventListener("error",(X)=>{w.dispatch({error:X}),j(X),L.terminate()}),L.postMessage({type:"USER_KEYS"})});return y};_();let w=R(),d6=R(),n6=R(),o6=R(),i6=R(),s6=R(),Y6=R(),r6=R(),a6=R(),E=(W)=>{if(b!==W)b=W,a6.dispatch({state:W})},t6=async(W)=>{let j=n.get(W);if(!j)return;F6.set(W,Array.from(new Uint8Array(await crypto.subtle.digest(s,new TextEncoder().encode(j6+U(await crypto.subtle.exportKey("raw",j))))))),r6.dispatch({userId:W,code:C6(W)})},o=()=>{if(b===c||b===P6)return;if(E(P6),g)g.close();B=h=y=Z=d=m=G=k=F=O=e=l=p=I=T=g=null,n.clear(),x6.clear(),q6.clear(),F6.clear(),H6.clear(),_(),E(c)},V6=(W)=>B6({type:z0,userId:W}),e6=(W,j=null)=>{if(!j&&b&&b!==c)return;E(O6),j6=W;let L=new URL(M+Y);if(L.searchParams.append("code",j6),j)L.searchParams.append("creator",j);g=new WebSocket(L.toString()),g.addEventListener("close",(X)=>{o6.dispatch({event:X}),o()}),g.addEventListener("error",(X)=>{w.dispatch({event:X}),o()}),g.addEventListener("message",async(X)=>{x0(G0(X.data,Y0),X.data)})},x0=async(W,j,L=!1)=>{let{[f6]:X,[k0]:H,[v6]:P,[l6]:A,[E6]:K,[S6]:$6,[u6]:q0,[y6]:$0,[p6]:Q0,[I6]:Q6}=W,z,Z6,G6,i;if(X)G6=X;else if(K)G6=K;else G6=j;if(A){if(!I||!L&&T.length>0){if(T.push({time:Date.now(),parts:W,raw:j}),T.length>a)T.shift();return}if(!P){w.dispatch(Error("Missing IV to decrypt message"));return}z=await crypto.subtle.decrypt({iv:C(P),name:f},I,C(A)),z=new TextDecoder().decode(z),i=!0}else if($0){if(!q0||!$6){w.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!h)await _();let V=C($0),D=q(new TextDecoder().decode(await crypto.subtle.decrypt({iv:C($6),name:f},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:z6},d.privateKey,C(q0)),{name:f},!0,["encrypt","decrypt"]),V)));if(i=!0,D.type===w6)Z6=D;else if(Q0){let v=D.sender;if(!v){w.dispatch({error:Error("Message from unknown sender")});return}let L6=q6.get(v);if(!L6){w.dispatch({error:Error("No public key for "+v)});return}if(!await crypto.subtle.verify(u,L6,C(Q0),V)){w.dispatch({error:Error("Invalid signature from "+v)});return}Z6=D}else{w.dispatch({error:Error("Missing encryption signature")});return}}else z=G6;if(!Z6)try{Z6=q(z)}catch(V){w.dispatch({error:Error("Failed to parse message "+j)});return}switch(z=Z6,z.type){case W0:if(B=z.creatorId,Z=z.userId,n6.dispatch({creatorId:z.creatorId,roomCode:j6,userId:z.userId,users:z.users}),Z===B)E(U6);else{if(E(Z0),!h)await _();let V=await crypto.subtle.exportKey(W6,m.publicKey);S({type:b6,publicData:typeof l==="function"?l():l,publicEncryptKey:U(G),publicExchangeKey:U(V),publicSignKey:U(k),signature:U(await crypto.subtle.sign(u,F.privateKey,V))},{allowUnencrypted:!0,receiver:B})}break;case b6:if(Q6===B&&Z===B){let V=z.sender;if(p&&!p({data:z.publicData,userId:V})){V6(V);return}x6.set(V,await crypto.subtle.importKey(X6,C(z.publicEncryptKey),{hash:s,name:z6},!0,["encrypt"]));let D=await crypto.subtle.importKey(X6,C(z.publicSignKey),{hash:s,name:u},!0,["verify"]),v=C(z.publicExchangeKey);if(!await crypto.subtle.verify(u,D,C(z.signature),v)){w.dispatch({error:Error("Invalid signature for exchange from "+V)});return}if(q6.set(V,D),!h)await _();n.set(V,await crypto.subtle.deriveKey({name:J6,public:await crypto.subtle.importKey(W6,v,{name:J6,namedCurve:g6},!0,[])},m.privateKey,{length:R6,name:f},!0,["encrypt","decrypt"]));let L6=await crypto.subtle.exportKey(W6,m.publicKey);S({type:w6,publicData:typeof l==="function"?l():l,publicEncryptKey:U(G),publicExchangeKey:U(L6),publicSignKey:U(k)},{receiver:V}),t6(V)}break;case w6:if(Q6===Z&&z.sender===B){if(p&&!p({data:z.publicData,userId:B})){o();return}let V=await crypto.subtle.importKey(X6,C(z.publicSignKey),{hash:s,name:u},!0,["verify"]);if(z.publicExchangeKey&&z.signature){if(!await crypto.subtle.verify(u,V,C(z.signature),C(z.publicExchangeKey))){w.dispatch({error:Error("Invalid signature for exchange from "+B)}),o();return}}if(q6.set(B,V),x6.set(B,await crypto.subtle.importKey(X6,C(z.publicEncryptKey),{hash:s,name:z6},!0,["encrypt"])),!h)await _();n.set(B,await crypto.subtle.deriveKey({name:J6,public:await crypto.subtle.importKey(W6,C(z.publicExchangeKey),{name:J6,namedCurve:g6},!0,[])},m.privateKey,{length:R6,name:f},!0,["encrypt","decrypt"])),t6(B)}break;case N6:if(Q6===Z&&z.sender===B){if(!i){w.dispatch({error:Error("Message was not encrypted")});return}if(e&&!e({data:z.privateData,userId:B})){o();return}S({type:A6,privateData:O},{receiver:B})}break;case A6:if(Q6===B&&Z===B){if(!i){w.dispatch({error:Error("Message was not encrypted")});return}let V=z.sender;if(!H6.get(V)){w.dispatch({error:Error("User not verified")}),V6(V);return}if(e&&!e({data:z.privateData,userId:V})){V6(V);return}S({type:K6,sharedKey:U(await crypto.subtle.exportKey("raw",I))},{receiver:V}),Y6.dispatch({userId:V}),B6({type:m6,userId:V})}break;case K6:if(Q6===Z&&z.sender===B){if(!i){w.dispatch({error:Error("Message was not encrypted")});return}if(I=await crypto.subtle.importKey("raw",C(z.sharedKey),{name:f},!0,["encrypt","decrypt"]),Y6.dispatch({userId:Z}),T.length>0){let V=Date.now();T=T.filter((D)=>V-D.time<t);while(T.length>0){let{parts:D,raw:v}=T.shift();x0(D,v,!0)}}E(U6)}break;case j0:s6.dispatch({userId:z.userId}),n.delete(z.userId),x6.delete(z.userId),q6.delete(z.userId);break;case X0:i6.dispatch({userId:z.userId});break;case m6:Y6.dispatch({userId:z.userId});break;default:if(!i){w.dispatch({error:Error("Message was not encrypted")});return}d6.dispatch({data:z,time:L0(H,z?.senderTime)});break}},S=async(W,j={})=>{if(!g||g.readyState!==WebSocket.OPEN)return w.dispatch({error:Error("No open socket")}),!1;let L=Q({...W,sender:Z,senderTime:Date.now()}),X={},H=j.receiver;if(H){let P=x6.get(H);if(P){let A=await crypto.subtle.generateKey({name:f,length:256},!0,["encrypt","decrypt"]),K=crypto.getRandomValues(new Uint8Array(12)),$6=await crypto.subtle.encrypt({iv:K,name:f},A,new TextEncoder().encode(L));if(!h)await _();X[S6]=U(K),X[u6]=U(await crypto.subtle.encrypt({name:z6},P,await crypto.subtle.exportKey("raw",A))),X[y6]=U($6),X[p6]=U(await crypto.subtle.sign(u,F.privateKey,$6))}else if(!j.allowUnencrypted)return w.dispatch({error:Error("No public key for "+H)}),!1;else X[E6]=L;X[I6]=H}else if(j.server)X[f6]=L;else if(I){let P=crypto.getRandomValues(new Uint8Array(12));X[v6]=U(P),X[l6]=U(await crypto.subtle.encrypt({iv:P,name:f},I,new TextEncoder().encode(L)))}else return w.dispatch(Error("Trying to send without valid destination")),!1;return g.send(B0(X,V0)),!0},B6=(W)=>Z&&Z===B&&S(W,{server:!0}),U0=(W,j)=>j&&S(W,{receiver:j}),C6=(W,j=6)=>{if(!F6.has(W))return!1;let L=F6.get(W),X="";for(let H=0;H<j;H++){let P=L[H]%T6.length;X+=T6[P]}return X};return{onConnection:a6,onError:w,onMessage:d6,onRoomJoin:n6,onRoomLeave:o6,onUserJoin:i6,onUserLeave:s6,onUserVerified:Y6,onUserVerificationCode:r6,messageRoom:(W)=>S(W),messageServer:B6,messageUser:U0,closeRoom:()=>B6({type:J0}),createRoom:async(W={})=>{if(b&&b!==c)return;if(E(O6),W.publicData)l=W.publicData;if(W.verifyPublicData)p=W.verifyPublicData;try{await new Promise((H,P)=>{let A=new Worker(URL.createObjectURL(new Blob([M0],{type:"text/javascript"})));A.addEventListener("message",(K)=>{if(K.data.success)I=K.data.sharedKey,H();else P(Error(K.data.error));A.terminate()}),A.addEventListener("error",(K)=>{P(K),A.terminate()}),A.postMessage({type:"SHARED_KEY"})})}catch(H){E(c),w.dispatch({error:H});return}let j=new URL(r+J);if(W.limit)j.searchParams.append("limit",W.limit);let L=await fetch(j.toString(),{method:"GET",headers:{Accept:x}});if(!L.ok)throw Error("Failed to create room");let X=await L.text();return X=q(X),Z=X.userId,e6(X.roomCode,X.creatorSecret),X},joinRoom:(W,j={})=>{if(j.publicData)l=j.publicData;if(j.verifyPublicData)p=j.verifyPublicData;e6(W)},leaveRoom:o,kickUser:V6,getVerificationCode:C6,verifyUser:async(W,j)=>{if(Z!==B||!j)return!1;let L=C6(W,j.length);if(!L||!j||L!==j)return!1;if(H6.set(W,!0),!n.get(W))return!1;return S({type:N6,privateData:O},{receiver:W}),!0}}};var N=($)=>{if(typeof $==="object"){let x=Array.isArray($)?[]:{};for(let q in $)x[q]=N($[q]);return x}return $};var _6=($,x,q)=>{let Q=$;for(let J=0;J<x.length-1;J++){let Y=x[J];if(!(Y in Q))Q[Y]={};Q=Q[Y]}Q[x[x.length-1]]=N(q)},C0=($,x)=>{let q=$;for(let Q=0;Q<x.length-1;Q++)if(q=q[x[Q]],!q)return;if(Array.isArray(q))q.splice(parseInt(x[x.length-1]),1);else delete q[x[x.length-1]]},M6=($,x,q=[])=>{let Q=[];for(let J in $){let Y=[...q,J];if(!(J in x))Q.unshift({type:"delete",path:Y,old:N($[J])});else if(typeof $[J]==="object"&&typeof x[J]==="object")Q.unshift(...M6($[J],x[J],Y));else if($[J]!==x[J])Q.unshift({type:"set",path:Y,old:N($[J]),new:N(x[J])})}for(let J in x)if(!(J in $))Q.unshift({type:"set",path:[...q,J],new:N(x[J])});return Q},k6=($,x)=>{for(let q of x)if(q.type==="set")_6($,q.path,q.new);else if(q.type==="delete")C0($,q.path);return $},c6=($,x)=>{for(let q of x)if(q.type==="set")if(q.old===void 0)C0($,q.path);else _6($,q.path,q.old);else if(q.type==="delete")_6($,q.path,q.old);return $};var e0=($={},x={},q={})=>{let Q=H0($),{messageRoom:J}=Q,{windowPerUser:Y=16,synchronisationInterval:r=60000}=$,M=[],a,t=0,b=0,B=Y,h=(Z)=>{let G=F0(),k=Z.length>0?Z[0].identifier:null;if(M.unshift({identifier:G,previous:k,sender:x.userId,stateDelta:Z,time:{adjusted:Date.now()+t-b}}),M.length>B)M.splice(B);J({identifier:G,previous:k,stateDelta:Z,type:D6}),m()},y=()=>{if(x.previousState){let Z=M6(x.previousState,q);if(Z.length>0)h(Z)}},d=()=>{if(x.users.length>1)J({type:h6,state:N(q)})},m=()=>{x.previousState=N(q)};return Q.onMessage.addListener(({data:Z,time:G})=>{if(Z.sender===x.userId||Z.receiver&&Z.receiver!==x.userId)return;if(t=(t+G.delay)/2,b=(b+G.offset)/2,Z.type===h6){let k=0;for(;k<M.length;k++)if(M[k].time.adjusted>=G.adjusted)break;M.splice(0,k);for(let F in q)delete q[F];for(let F in Z.state)q[F]=Z.state[F];for(let F=0;F<M.length;F++)k6(q,M[F].stateDelta);m()}else if(Z.type===D6){let k=!0;for(let F=0;F<M.length;F++){let O=M[F];if(O.identifier===Z.previous||O.previous===Z.previous&&O.time.adjusted<G.adjusted){M.splice(F,0,{...Z,time:G}),k=!1;break}}if(k)M.unshift({...Z,time:G});for(let F=0;F<M.length;F++){let O=M[F];if(O.identifier===Z.identifier)break;c6(q,O.stateDelta)}for(let F=0;F<M.length;F++){let O=M[F];if(k6(q,O.stateDelta),O.identifier===Z.identifier)break}m()}}),Q.onConnection.addListener(({state:Z})=>{x.connectionState=Z}),Q.onRoomJoin.addListener(({creatorId:Z,roomCode:G,userId:k,users:F})=>{if(x.creatorId=Z,x.roomCode=G,x.userId=k,x.users=F,x.verifiedUsers=[],x.previousState=N(q),k===Z)x.verifiedUsers.push(k),a=setInterval(d,r)}),Q.onRoomLeave.addListener(()=>{for(let Z in x)delete x[Z];if(a)clearInterval(a)}),Q.onUserJoin.addListener(({userId:Z})=>{x.users.push(Z),B=Y+Y*x.users.length}),Q.onUserVerificationCode.addListener((Z)=>{if(Z.userId===x.creatorId)x.verificationCode=Z.code}),Q.onUserVerified.addListener(({userId:Z})=>{if(x.verifiedUsers.push(Z),B=Y+Y*x.users.length,x.userId===x.creatorId)d()}),Q.onUserLeave.addListener(({userId:Z})=>{for(let G=0;G<x.users.length;G++)if(x.users[G]===Z){x.users.splice(G,1);break}for(let G=0;G<x.verifiedUsers.length;G++)if(x.verifiedUsers[G]===Z){x.verifiedUsers.splice(G,1);break}B=Y+Y*x.users.length}),Object.assign({privateState:x,publicState:q,sendUpdate:y},Q)};export{e0 as createClientSynchronizer,H0 as createClientConnector};

//# debugId=35983E04A124099D64756E2164756E21
