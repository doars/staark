var U0="CONNECTED",P0="CONNECTING",c="DISCONNECTED",C0="DISCONNECTING",J1="PENDING_VERIFICATION";var N0="_X0",w0="_X1",K0="_X2",A0="_X3",D0="_X4",x1="_RC",W1="_RJ";var m0="_SU",b0="_SS",X1="_UJ",z1="_UK",j1="_UL",T0="_UV";var R0="ABCDEFGHKMNPQRSTUVWXYZ23456789",F1=(Q=24,q="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")=>{let $="";for(let Z=0;Z<Q;Z++)$+=q.charAt(Math.floor(Math.random()*q.length));return $};var O=(Q)=>{let q=atob(Q);return Uint8Array.from(q,($)=>$.charCodeAt(0)).buffer},Y1=(Q)=>{let q=atob(Q),$=Uint8Array.from(q,(Z)=>Z.charCodeAt(0));return new TextDecoder().decode($)},V1=(Q)=>{let q=new TextEncoder().encode(Q);if(q.length<65536)return btoa(String.fromCharCode(...q));let $="",Z=65536;for(let x=0;x<q.length;x+=Z){let Y=q.subarray(x,x+Z);$+=String.fromCharCode(...Y)}return btoa($)},U=(Q)=>{let q=new Uint8Array(Q);if(q.length<65536)return btoa(String.fromCharCode(...q));let $="",Z=65536;for(let x=0;x<q.length;x+=Z){let Y=q.subarray(x,x+Z);$+=String.fromCharCode(...Y)}return btoa($)};var g=()=>{let Q=new Map;return{addListener:(q,$)=>{if(!Q.has(q))Q.set(q,$)},removeListener:(q)=>{Q.delete(q)},dispatch:(q)=>{for(let[$,Z]of Q.entries())if($(q),Z&&Z.once)Q.delete($)}}};var G1=(Q,q)=>{let $=[];for(let Z in Q){let x=Q[Z];if(x!==null&&x!==void 0)$.push(Z+":"+q(String(x)))}return $.join("|")},B1=(Q,q)=>{let $={},Z=Q.split("|");for(let x of Z){let Y=x.indexOf(":");if(Y>0){let r=x.substring(0,Y),M=x.substring(Y+1);$[r]=q(M)}}return $};var L1=(Q,q)=>{let $=Date.now();if(!Q)return{delay:0,offset:0,adjusted:$};if(!q){let Y=Q-$;return{delay:0,offset:Y,adjusted:$+Y}}let Z=$-q,x=(Q-q+(Q-$))/2;return{delay:Z,offset:x,adjusted:$-Z+x}};var x0="ECDH",h0="P-256",W0="raw",s="SHA-256",X0="spki",I="AES-GCM",g0=256,z0="RSA-OAEP",u="RSASSA-PKCS1-v1_5",w1="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([Q,q,$])=>{Promise.all([crypto.subtle.exportKey("spki",Q.publicKey),crypto.subtle.exportKey("spki",q.publicKey)]).then(([Z,x])=>{self.postMessage({success:!0,myEncryptKeys:Q,mySignKeys:q,myExchangeKeys:$,myPublicEncryptKey:Z,myPublicSignKey:x})}).catch((Z)=>{self.postMessage({success:!1,error:Z.message})})}).catch((Q)=>{self.postMessage({success:!1,error:Q.message})})}).toString()+")",M1="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then((Q)=>{self.postMessage({success:!0,sharedKey:Q})}).catch((Q)=>{self.postMessage({success:!1,error:Q.message})})}).toString()+")";var I0="S",H1="T",l0="E",v0="I",f0="U",E0="D",S0="V",u0="K",y0="P",p0="G";var k1=(Q={})=>{let{contentType:q="application/json",deserializeMessage:$=JSON.parse,serializeMessage:Z=JSON.stringify,createRoomEndpoint:x="/create-room",joinRoomEndpoint:Y="/join-room",httpUrl:r="http://localhost:3000",wsUrl:M="http://localhost:3000",messageBufferMaxCount:a=50,messageBufferMaxDuration:t=60000}=Q,N=c,G,b,y,d,T,J,B,H,F,P,e,l,p,j0,f,R=[],h,n=new Map,q0=new Map,$0=new Map,F0=new Map,k0=new Map,_=()=>{if(!b&&!y)y=new Promise((W,j)=>{let L=new Worker(URL.createObjectURL(new Blob([w1],{type:"text/javascript"})));L.addEventListener("message",(X)=>{if(X.data.success)d=X.data.myEncryptKeys,F=X.data.mySignKeys,T=X.data.myExchangeKeys,B=X.data.myPublicEncryptKey,H=X.data.myPublicSignKey,b=!0,y=null,W();else{let k=Error(X.data.error);w.dispatch({error:k}),j(k)}L.terminate()}),L.addEventListener("error",(X)=>{w.dispatch({error:X}),j(X),L.terminate()}),L.postMessage({type:"USER_KEYS"})});return y};_();let w=g(),d0=g(),n0=g(),o0=g(),i0=g(),s0=g(),Y0=g(),r0=g(),a0=g(),E=(W)=>{if(N!==W)N=W,a0.dispatch({state:W})},t0=async(W)=>{let j=n.get(W);if(!j)return;F0.set(W,Array.from(new Uint8Array(await crypto.subtle.digest(s,new TextEncoder().encode(j0+U(await crypto.subtle.exportKey("raw",j))))))),r0.dispatch({userId:W,code:O0(W)})},o=()=>{if(N===c||N===C0)return;if(E(C0),h)h.close();G=b=y=J=d=T=B=H=F=P=e=l=p=f=R=h=null,n.clear(),q0.clear(),$0.clear(),F0.clear(),k0.clear(),_(),E(c)},V0=(W)=>G0({type:z1,userId:W}),e0=(W,j=null)=>{if(!j&&N&&N!==c)return;E(P0),j0=W;let L=new URL(M+Y);if(L.searchParams.append("code",j0),j)L.searchParams.append("creator",j);h=new WebSocket(L.toString()),h.addEventListener("close",(X)=>{o0.dispatch({event:X}),o()}),h.addEventListener("error",(X)=>{w.dispatch({event:X}),o()}),h.addEventListener("message",async(X)=>{q1(B1(X.data,Y1),X.data)})},q1=async(W,j,L=!1)=>{let{[I0]:X,[H1]:k,[v0]:C,[l0]:A,[E0]:D,[S0]:Q0,[u0]:$1,[y0]:Q1,[p0]:Z1,[f0]:Z0}=W,z,J0,B0,i;if(X)B0=X;else if(D)B0=D;else B0=j;if(A){if(!f||!L&&R.length>0){if(R.push({time:Date.now(),parts:W,raw:j}),R.length>a)R.shift();return}if(!C){w.dispatch(Error("Missing IV to decrypt message"));return}z=await crypto.subtle.decrypt({iv:O(C),name:I},f,O(A)),z=new TextDecoder().decode(z),i=!0}else if(Q1){if(!$1||!Q0){w.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!b)await _();let V=O(Q1),m=$(new TextDecoder().decode(await crypto.subtle.decrypt({iv:O(Q0),name:I},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:z0},d.privateKey,O($1)),{name:I},!0,["encrypt","decrypt"]),V)));if(i=!0,m.type===w0)J0=m;else if(Z1){let v=m.sender;if(!v){w.dispatch({error:Error("Message from unknown sender")});return}let L0=$0.get(v);if(!L0){w.dispatch({error:Error("No public key for "+v)});return}if(!await crypto.subtle.verify(u,L0,O(Z1),V)){w.dispatch({error:Error("Invalid signature from "+v)});return}J0=m}else{w.dispatch({error:Error("Missing encryption signature")});return}}else z=B0;if(!J0)try{J0=$(z)}catch(V){w.dispatch({error:Error("Failed to parse message "+j)});return}switch(z=J0,z.type){case W1:if(G=z.creatorId,J=z.userId,n0.dispatch({creatorId:z.creatorId,roomCode:j0,userId:z.userId,users:z.users}),J===G)E(U0);else{if(E(J1),!b)await _();let V=await crypto.subtle.exportKey(W0,T.publicKey);S({type:N0,publicData:typeof l==="function"?l():l,publicEncryptKey:U(B),publicExchangeKey:U(V),publicSignKey:U(H),signature:U(await crypto.subtle.sign(u,F.privateKey,V))},{allowUnencrypted:!0,receiver:G})}break;case N0:if(Z0===G&&J===G){let V=z.sender;if(p&&!p({data:z.publicData,userId:V})){V0(V);return}q0.set(V,await crypto.subtle.importKey(X0,O(z.publicEncryptKey),{hash:s,name:z0},!0,["encrypt"]));let m=await crypto.subtle.importKey(X0,O(z.publicSignKey),{hash:s,name:u},!0,["verify"]),v=O(z.publicExchangeKey);if(!await crypto.subtle.verify(u,m,O(z.signature),v)){w.dispatch({error:Error("Invalid signature for exchange from "+V)});return}if($0.set(V,m),!b)await _();n.set(V,await crypto.subtle.deriveKey({name:x0,public:await crypto.subtle.importKey(W0,v,{name:x0,namedCurve:h0},!0,[])},T.privateKey,{length:g0,name:I},!0,["encrypt","decrypt"]));let L0=await crypto.subtle.exportKey(W0,T.publicKey);S({type:w0,publicData:typeof l==="function"?l():l,publicEncryptKey:U(B),publicExchangeKey:U(L0),publicSignKey:U(H)},{receiver:V}),t0(V)}break;case w0:if(Z0===J&&z.sender===G){if(p&&!p({data:z.publicData,userId:G})){o();return}let V=await crypto.subtle.importKey(X0,O(z.publicSignKey),{hash:s,name:u},!0,["verify"]);if(z.publicExchangeKey&&z.signature){if(!await crypto.subtle.verify(u,V,O(z.signature),O(z.publicExchangeKey))){w.dispatch({error:Error("Invalid signature for exchange from "+G)}),o();return}}if($0.set(G,V),q0.set(G,await crypto.subtle.importKey(X0,O(z.publicEncryptKey),{hash:s,name:z0},!0,["encrypt"])),!b)await _();n.set(G,await crypto.subtle.deriveKey({name:x0,public:await crypto.subtle.importKey(W0,O(z.publicExchangeKey),{name:x0,namedCurve:h0},!0,[])},T.privateKey,{length:g0,name:I},!0,["encrypt","decrypt"])),t0(G)}break;case K0:if(Z0===J&&z.sender===G){if(!i){w.dispatch({error:Error("Message was not encrypted")});return}if(e&&!e({data:z.privateData,userId:G})){o();return}S({type:A0,privateData:P},{receiver:G})}break;case A0:if(Z0===G&&J===G){if(!i){w.dispatch({error:Error("Message was not encrypted")});return}let V=z.sender;if(!k0.get(V)){w.dispatch({error:Error("User not verified")}),V0(V);return}if(e&&!e({data:z.privateData,userId:V})){V0(V);return}S({type:D0,sharedKey:U(await crypto.subtle.exportKey("raw",f))},{receiver:V}),Y0.dispatch({userId:V}),G0({type:T0,userId:V})}break;case D0:if(Z0===J&&z.sender===G){if(!i){w.dispatch({error:Error("Message was not encrypted")});return}if(f=await crypto.subtle.importKey("raw",O(z.sharedKey),{name:I},!0,["encrypt","decrypt"]),Y0.dispatch({userId:J}),R.length>0){let V=Date.now();R=R.filter((m)=>V-m.time<t);while(R.length>0){let{parts:m,raw:v}=R.shift();q1(m,v,!0)}}E(U0)}break;case j1:s0.dispatch({userId:z.userId}),n.delete(z.userId),q0.delete(z.userId),$0.delete(z.userId);break;case X1:i0.dispatch({userId:z.userId});break;case T0:Y0.dispatch({userId:z.userId});break;default:if(!i){w.dispatch({error:Error("Message was not encrypted")});return}d0.dispatch({data:z,time:L1(k,z?.senderTime)});break}},S=async(W,j={})=>{if(!h||h.readyState!==WebSocket.OPEN)return w.dispatch({error:Error("No open socket")}),!1;let L=Z({...W,sender:J,senderTime:Date.now()}),X={},k=j.receiver;if(k){let C=q0.get(k);if(C){let A=await crypto.subtle.generateKey({name:I,length:256},!0,["encrypt","decrypt"]),D=crypto.getRandomValues(new Uint8Array(12)),Q0=await crypto.subtle.encrypt({iv:D,name:I},A,new TextEncoder().encode(L));if(!b)await _();X[S0]=U(D),X[u0]=U(await crypto.subtle.encrypt({name:z0},C,await crypto.subtle.exportKey("raw",A))),X[y0]=U(Q0),X[p0]=U(await crypto.subtle.sign(u,F.privateKey,Q0))}else if(!j.allowUnencrypted)return w.dispatch({error:Error("No public key for "+k)}),!1;else X[E0]=L;X[f0]=k}else if(j.server)X[I0]=L;else if(f){let C=crypto.getRandomValues(new Uint8Array(12));X[v0]=U(C),X[l0]=U(await crypto.subtle.encrypt({iv:C,name:I},f,new TextEncoder().encode(L)))}else return w.dispatch(Error("Trying to send without valid destination")),!1;return h.send(G1(X,V1)),!0},G0=(W)=>J&&J===G&&S(W,{server:!0}),U1=(W,j)=>j&&S(W,{receiver:j}),O0=(W,j=6)=>{if(!F0.has(W))return!1;let L=F0.get(W),X="";for(let k=0;k<j;k++){let C=L[k]%R0.length;X+=R0[C]}return X};return{onConnection:a0,onError:w,onMessage:d0,onRoomJoin:n0,onRoomLeave:o0,onUserJoin:i0,onUserLeave:s0,onUserVerified:Y0,onUserVerificationCode:r0,messageRoom:(W)=>S(W),messageServer:G0,messageUser:U1,closeRoom:()=>G0({type:x1}),createRoom:async(W={})=>{if(N&&N!==c)return;if(E(P0),W.publicData)l=W.publicData;if(W.verifyPublicData)p=W.verifyPublicData;try{await new Promise((k,C)=>{let A=new Worker(URL.createObjectURL(new Blob([M1],{type:"text/javascript"})));A.addEventListener("message",(D)=>{if(D.data.success)f=D.data.sharedKey,k();else C(Error(D.data.error));A.terminate()}),A.addEventListener("error",(D)=>{C(D),A.terminate()}),A.postMessage({type:"SHARED_KEY"})})}catch(k){E(c),w.dispatch({error:k});return}let j=new URL(r+x);if(W.limit)j.searchParams.append("limit",W.limit);let L=await fetch(j.toString(),{method:"GET",headers:{Accept:q}});if(!L.ok)throw Error("Failed to create room");let X=await L.text();return X=$(X),J=X.userId,e0(X.roomCode,X.creatorSecret),X},joinRoom:(W,j={})=>{if(j.publicData)l=j.publicData;if(j.verifyPublicData)p=j.verifyPublicData;e0(W)},leaveRoom:o,kickUser:V0,getVerificationCode:O0,verifyUser:async(W,j)=>{if(J!==G||!j)return!1;let L=O0(W,j.length);if(!L||!j||L!==j)return!1;if(k0.set(W,!0),!n.get(W))return!1;return S({type:K0,privateData:P},{receiver:W}),!0}}};var K=(Q)=>{if(Q&&typeof Q==="object"){let q=Array.isArray(Q)?[]:{};for(let $ in Q)q[$]=K(Q[$]);return q}return Q};var _0=(Q,q,$)=>{let Z=Q;for(let x=0;x<q.length-1;x++){let Y=q[x];if(!(Y in Z))Z[Y]={};Z=Z[Y]}Z[q[q.length-1]]=K($)},O1=(Q,q)=>{let $=Q;for(let Z=0;Z<q.length-1;Z++)if($=$[q[Z]],!$)return;if(Array.isArray($))$.splice(parseInt(q[q.length-1]),1);else delete $[q[q.length-1]]},M0=(Q,q,$=[])=>{let Z=[];for(let x in Q){let Y=[...$,x];if(!(x in q))Z.unshift({type:"delete",path:Y,old:K(Q[x])});else if(typeof Q[x]==="object"&&typeof q[x]==="object")Z.unshift(...M0(Q[x],q[x],Y));else if(Q[x]!==q[x])Z.unshift({type:"set",path:Y,old:K(Q[x]),new:K(q[x])})}for(let x in q)if(!(x in Q))Z.unshift({type:"set",path:[...$,x],new:K(q[x])});return Z},H0=(Q,q)=>{for(let $ of q)if($.type==="set")_0(Q,$.path,$.new);else if($.type==="delete")O1(Q,$.path);return Q},c0=(Q,q)=>{for(let $ of q)if($.type==="set")if($.old===void 0)O1(Q,$.path);else _0(Q,$.path,$.old);else if($.type==="delete")_0(Q,$.path,$.old);return Q};var e1=(Q={},q={},$={})=>{let Z=k1(Q),{messageRoom:x}=Z,{windowPerUser:Y=16,synchronisationInterval:r=60000}=Q,M=[],a,t=0,N=0,G=Y,b=(J)=>{let B=F1(),H=J.length>0?J[0].identifier:null;if(M.unshift({identifier:B,previous:H,sender:q.userId,stateDelta:J,time:{adjusted:Date.now()+t-N}}),M.length>G)M.splice(G);x({identifier:B,previous:H,stateDelta:J,type:m0}),T()},y=()=>{if(q.previousState){let J=M0(q.previousState,$);if(J.length>0)b(J)}},d=()=>{if(q.users.length>1)x({type:b0,state:K($)})},T=()=>{q.previousState=K($)};return Z.onMessage.addListener(({data:J,time:B})=>{if(J.sender===q.userId||J.receiver&&J.receiver!==q.userId)return;if(t=(t+B.delay)/2,N=(N+B.offset)/2,J.type===b0){let H=0;for(;H<M.length;H++)if(M[H].time.adjusted>=B.adjusted)break;M.splice(0,H);for(let F in $)delete $[F];for(let F in J.state)$[F]=J.state[F];for(let F=0;F<M.length;F++)H0($,M[F].stateDelta);T()}else if(J.type===m0){let H=!0;for(let F=0;F<M.length;F++){let P=M[F];if(P.identifier===J.previous||P.previous===J.previous&&P.time.adjusted<B.adjusted){M.splice(F,0,{...J,time:B}),H=!1;break}}if(H)M.unshift({...J,time:B});for(let F=0;F<M.length;F++){let P=M[F];if(P.identifier===J.identifier)break;c0($,P.stateDelta)}for(let F=0;F<M.length;F++){let P=M[F];if(H0($,P.stateDelta),P.identifier===J.identifier)break}T()}}),Z.onConnection.addListener(({state:J})=>{q.connectionState=J}),Z.onRoomJoin.addListener(({creatorId:J,roomCode:B,userId:H,users:F})=>{if(q.creatorId=J,q.roomCode=B,q.userId=H,q.users=F,q.verifiedUsers=[],q.previousState=K($),H===J)q.verifiedUsers.push(H),a=setInterval(d,r)}),Z.onRoomLeave.addListener(()=>{for(let J in q)delete q[J];if(a)clearInterval(a)}),Z.onUserJoin.addListener(({userId:J})=>{q.users.push(J),G=Y+Y*q.users.length}),Z.onUserVerificationCode.addListener((J)=>{if(J.userId===q.creatorId)q.verificationCode=J.code}),Z.onUserVerified.addListener(({userId:J})=>{if(q.verifiedUsers.push(J),G=Y+Y*q.users.length,q.userId===q.creatorId)d()}),Z.onUserLeave.addListener(({userId:J})=>{for(let B=0;B<q.users.length;B++)if(q.users[B]===J){q.users.splice(B,1);break}for(let B=0;B<q.verifiedUsers.length;B++)if(q.verifiedUsers[B]===J){q.verifiedUsers.splice(B,1);break}G=Y+Y*q.users.length}),Object.assign({privateState:q,publicState:$,sendUpdate:y},Z)};export{e1 as createClientSynchronizer,k1 as createClientConnector};

//# debugId=D84F00527261FB9F64756E2164756E21
