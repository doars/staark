var Cr=Object.defineProperty,Ar=Object.defineProperties;var xr=Object.getOwnPropertyDescriptors;var er=Object.getOwnPropertySymbols;var Tr=Object.prototype.hasOwnProperty,br=Object.prototype.propertyIsEnumerable;var rr=(t,e,r)=>e in t?Cr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ne=(t,e)=>{for(var r in e||(e={}))Tr.call(e,r)&&rr(t,r,e[r]);if(er)for(var r of er(e))br.call(e,r)&&rr(t,r,e[r]);return t},se=(t,e)=>Ar(t,xr(e));var X=(t,e,r)=>new Promise((n,s)=>{var d=A=>{try{f(r.next(A))}catch(H){s(H)}},j=A=>{try{f(r.throw(A))}catch(H){s(H)}},f=A=>A.done?n(A.value):Promise.resolve(A.value).then(d,j);f((r=r.apply(t,e)).next())});var ge="CONNECTED",Re="CONNECTING",z="DISCONNECTED",Ie="DISCONNECTING",tr="PENDING_VERIFICATION";var Ee="_KA",Ne="_KO",Ce="_KT",nr="_RC",sr="_RJ";var Ae="_SU",xe="_SS",or="_UJ",ir="_UK",cr="_UL",Te="_UV";var Or="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",be="ABCDEFGHKMNPQRSTUVWXYZ23456789",ar=(t=24,e=Or)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var R=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},dr=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},lr=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let s=0;s<e.length;s+=n){let d=e.subarray(s,s+n);r+=String.fromCharCode(...d)}return btoa(r)},I=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let s=0;s<e.length;s+=n){let d=e.subarray(s,s+n);r+=String.fromCharCode(...d)}return btoa(r)};var v=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var ur="|",pr=":",yr=(t,e)=>{let r=[];for(let n in t){let s=t[n];s!=null&&r.push(n+pr+e(String(s)))}return r.join(ur)},fr=(t,e)=>{let r={},n=t.split(ur);for(let s of n){let d=s.indexOf(pr);if(d>0){let j=s.substring(0,d),f=s.substring(d+1);r[j]=e(f)}}return r};var Er=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,s=(t-e+(t-r))/2;return{delay:n,offset:s,adjusted:r-n+s}};var oe="ECDH",Oe="P-256",ie="raw",Q="SHA-256",ce="spki",T="AES-GCM";var ae="RSA-OAEP",G="RSASSA-PKCS1-v1_5",mr="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,s])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:s})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",_r="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Ke="S",hr="T",we="E",De="I",Ue="U",Se="D",Pe="V",Le="K",ve="P",He="G";var Rr=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:s="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:j="http://localhost:3000",wsUrl:f="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:H=60*1e3}=t,x=z,m,U,O,S,M,i,p,y,l,C,Z,de,F,P=[],L,B=new Map,q=new Map,$=new Map,le=new Map,J=()=>(!U&&!M&&(M=new Promise((o,a)=>{let h=new Worker(URL.createObjectURL(new Blob([mr],{type:"text/javascript"})));h.addEventListener("message",u=>{if(u.data.success)i=u.data.myEncryptKeys,Z=u.data.mySignKeys,p=u.data.myExchangeKeys,l=u.data.myPublicEncryptKey,C=u.data.myPublicSignKey,U=!0,M=null,o();else{let _=new Error(u.data.error);N.dispatch({error:_}),a(_)}h.terminate()}),h.addEventListener("error",u=>{N.dispatch({error:u}),a(u),h.terminate()}),h.postMessage({type:"USER_KEYS"})})),M);J();let N=v(),Ye=v(),Ge=v(),Fe=v(),Ve=v(),je=v(),ue=v(),Be=v(),Je=v(),V=o=>{x!==o&&(x=o,Je.dispatch({state:o}))},Xe=o=>X(null,null,function*(){let a=B.get(o);a&&(le.set(o,Array.from(new Uint8Array(yield crypto.subtle.digest(Q,new TextEncoder().encode(de+I(yield crypto.subtle.exportKey("raw",a))))))),Be.dispatch({userId:o,code:he(o)}))}),ee=()=>{x===z||x===Ie||(V(Ie),L&&L.close(),m=U=O=S=M=y=i=p=l=C=Z=F=P=L=null,B.clear(),q.clear(),$.clear(),le.clear(),J(),V(z))},ze=o=>pe({type:ir,userId:o}),We=(o,a=null)=>{if(!a&&x&&x!==z)return;V(Re),de=o;let h=new URL(f+d);h.searchParams.append("code",de),a&&h.searchParams.append("creator",a),L=new WebSocket(h.toString()),L.addEventListener("close",u=>{Fe.dispatch({event:u}),ee()}),L.addEventListener("error",u=>{N.dispatch({event:u}),ee()}),L.addEventListener("message",u=>X(null,null,function*(){Qe(fr(u.data,dr),u.data)}))},Qe=(o,a,h=!1)=>X(null,null,function*(){let{[Ke]:u,[hr]:_,[De]:g,[we]:K,[Se]:w,[Pe]:D,[Le]:re,[ve]:Ze,[He]:qe,[Ue]:$e}=o,c,te,ye;if(u?ye=u:w?ye=w:ye=a,K){if(!F||!h&&P.length>0){P.push({time:Date.now(),parts:o,raw:a}),P.length>A&&P.shift();return}if(!g){N.dispatch(new Error("Missing IV to decrypt message"));return}c=yield crypto.subtle.decrypt({iv:R(g),name:T},F,R(K)),c=new TextDecoder().decode(c)}else if(Ze){if(!qe||!re||!D)return;U||(yield J());let E=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:R(D),name:T},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ae},i.privateKey,R(re)),{name:T},!0,["encrypt","decrypt"]),R(Ze))));if(E.type===Ee)te=E;else{let k=E.sender;if(!k){N.dispatch({error:new Error("Message from unknown sender")});return}let Y=$.get(k);if(!Y){N.dispatch({error:new Error("No public key for "+k)});return}if(!(yield crypto.subtle.verify(G,Y,R(qe),new TextEncoder().encode(E.payload)))){N.dispatch({error:new Error("Invalid signature from "+k)});return}te=E}}else c=ye;if(!te)try{te=r(c)}catch(E){N.dispatch({error:new Error("Failed to parse message "+a)});return}switch(c=te,c.type){case sr:if(m=c.creatorId,y=c.userId,Ge.dispatch({creatorId:c.creatorId,roomCode:de,userId:c.userId,users:c.users}),y===m)V(ge);else{V(tr),U||(yield J());let E=yield crypto.subtle.exportKey(ie,p.publicKey);W({type:Ne,publicData:typeof O=="function"?O():O,publicEncryptKey:I(l),publicExchangeKey:I(E),publicSignKey:I(C),signature:I(yield crypto.subtle.sign(G,Z.privateKey,E))},{allowUnencrypted:!0,receiver:m})}break;case Ne:if(y===m){let E=c.sender;if(S&&!S({data:c.publicData,userId:E})){ze(E);return}q.set(E,yield crypto.subtle.importKey(ce,R(c.publicEncryptKey),{hash:Q,name:ae},!0,["encrypt"]));let k=yield crypto.subtle.importKey(ce,R(c.publicSignKey),{hash:Q,name:G},!0,["verify"]),Y=R(c.publicExchangeKey);if(!(yield crypto.subtle.verify(G,k,R(c.signature),Y))){N.dispatch({error:new Error("Invalid signature for exchange from "+E)});return}$.set(E,k),U||(yield J()),B.set(E,yield crypto.subtle.deriveKey({name:oe,public:yield crypto.subtle.importKey(ie,Y,{name:oe,namedCurve:Oe},!0,[])},p.privateKey,{length:256,name:T},!0,["encrypt","decrypt"]));let fe=yield crypto.subtle.exportKey(ie,p.publicKey);W({type:Ee,publicData:typeof O=="function"?O():O,publicEncryptKey:I(l),publicExchangeKey:I(fe),publicSignKey:I(C),signature:I(yield crypto.subtle.sign(G,Z.privateKey,fe))},{receiver:E}),Xe(E)}break;case Ee:if($e===y&&c.sender===m){if(S&&!S({data:c.publicData,userId:m})){ee();return}let E=yield crypto.subtle.importKey(ce,R(c.publicSignKey),{hash:Q,name:G},!0,["verify"]);if(c.publicExchangeKey&&c.signature&&!(yield crypto.subtle.verify(G,E,R(c.signature),R(c.publicExchangeKey)))){N.dispatch({error:new Error("Invalid signature for exchange from "+m)}),ee();return}$.set(m,E),q.set(m,yield crypto.subtle.importKey(ce,R(c.publicEncryptKey),{hash:Q,name:ae},!0,["encrypt"])),U||(yield J()),B.set(m,yield crypto.subtle.deriveKey({name:oe,public:yield crypto.subtle.importKey(ie,R(c.publicExchangeKey),{name:oe,namedCurve:Oe},!0,[])},p.privateKey,{length:256,name:T},!0,["encrypt","decrypt"])),Xe(m)}break;case Ce:if($e===y&&c.sender===m){let E=B.get(m);if(!E){N.dispatch({error:new Error("No derived key for host "+m)});return}if(F=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:R(c.sharedKeyIv),name:T},E,R(c.sharedKey)),{name:T},!0,["encrypt","decrypt"]),ue.dispatch({userId:y}),P.length>0){let k=Date.now();for(P=P.filter(Y=>k-Y.time<H);P.length>0;){let{parts:Y,raw:fe}=P.shift();Qe(Y,fe,!0)}}V(ge)}break;case cr:je.dispatch({userId:c.userId}),B.delete(c.userId),q.delete(c.userId),$.delete(c.userId);break;case or:Ve.dispatch({userId:c.userId});break;case Te:ue.dispatch({userId:c.userId});break;default:Ye.dispatch({data:c,time:Er(_,c==null?void 0:c.senderTime)});break}}),W=(h,...u)=>X(null,[h,...u],function*(o,a={}){if(!L||L.readyState!==WebSocket.OPEN)return N.dispatch({error:new Error("No open socket")}),!1;let _=n(se(ne({},o),{sender:y,senderTime:Date.now()})),g={};if(a.receiver){let K=q.get(a.receiver);if(K){let w=yield crypto.subtle.generateKey({name:T,length:256},!0,["encrypt","decrypt"]),D=crypto.getRandomValues(new Uint8Array(12)),re=yield crypto.subtle.encrypt({iv:D,name:T},w,new TextEncoder().encode(_));U||(yield J()),g[He]=I(yield crypto.subtle.sign(G,Z.privateKey,re)),g[Le]=I(yield crypto.subtle.encrypt({name:ae},K,yield crypto.subtle.exportKey("raw",w))),g[ve]=I(re),g[Pe]=I(D)}else if(a.allowUnencrypted)g[Se]=_;else return N.dispatch({error:new Error("No public key for "+a.receiver)}),!1;g[Ue]=a.receiver}else if(a.server)g[Ke]=_;else if(F){let K=crypto.getRandomValues(new Uint8Array(12));g[De]=I(K),g[we]=I(yield crypto.subtle.encrypt({iv:K,name:T},F,new TextEncoder().encode(_)))}else return N.dispatch(new Error("Trying to send without valid destination")),!1;return L.send(yr(g,lr)),!0}),pe=o=>y&&y===m&&W(o,{server:!0}),Nr=(o,a)=>a&&W(o,{receiver:a}),he=(o,a=6)=>{if(!le.has(o))return!1;let h=le.get(o),u="";for(let _=0;_<a;_++){let g=h[_]%be.length;u+=be[g]}return u};return{onConnection:Je,onError:N,onMessage:Ye,onRoomJoin:Ge,onRoomLeave:Fe,onUserJoin:Ve,onUserLeave:je,onUserVerified:ue,onUserVerificationCode:Be,messageRoom:o=>W(o),messageServer:pe,messageUser:Nr,closeRoom:()=>pe({type:nr}),createRoom:(...a)=>X(null,[...a],function*(o={}){if(x&&x!==z)return;V(Re),o.publicData&&(O=o.publicData),o.verifyPublicData&&(S=o.verifyPublicData);try{yield new Promise((g,K)=>{let w=new Worker(URL.createObjectURL(new Blob([_r],{type:"text/javascript"})));w.addEventListener("message",D=>{D.data.success?(F=D.data.sharedKey,g()):K(new Error(D.data.error)),w.terminate()}),w.addEventListener("error",D=>{K(D),w.terminate()}),w.postMessage({type:"SHARED_KEY"})})}catch(g){V(z),N.dispatch({error:g});return}let h=new URL(j+s);o.limit&&h.searchParams.append("limit",o.limit);let u=yield fetch(h.toString(),{method:"GET",headers:{Accept:e}});if(!u.ok)throw new Error("Failed to create room");let _=yield u.text();return _=r(_),y=_.userId,We(_.roomCode,_.creatorSecret),_}),joinRoom:(o,a={})=>{a.publicData&&(O=a.publicData),a.verifyPublicData&&(S=a.verifyPublicData),We(o)},leaveRoom:ee,kickUser:ze,getVerificationCode:he,verifyUser:(o,a)=>X(null,null,function*(){if(y!==m||!a)return!1;let h=he(o,a.length);if(!h||!a||h!==a)return!1;let u=B.get(o);if(!u)return!1;let _=crypto.getRandomValues(new Uint8Array(12));return W({type:Ce,sharedKey:I(yield crypto.subtle.encrypt({iv:_,name:T},u,yield crypto.subtle.exportKey("raw",F))),sharedKeyIv:I(_)},{receiver:o}),ue.dispatch({userId:o}),pe({type:Te,userId:o}),!0})}};var b=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=b(t[r]);return e}return t};var Me=(t,e,r)=>{let n=t;for(let s=0;s<e.length-1;s++){let d=e[s];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=b(r)},Ir=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},me=(t,e,r=[])=>{let n=[];for(let s in t){let d=[...r,s];s in e?typeof t[s]=="object"&&typeof e[s]=="object"?n.unshift(...me(t[s],e[s],d)):t[s]!==e[s]&&n.unshift({type:"set",path:d,old:b(t[s]),new:b(e[s])}):n.unshift({type:"delete",path:d,old:b(t[s])})}for(let s in e)s in t||n.unshift({type:"set",path:[...r,s],new:b(e[s])});return n},_e=(t,e)=>{for(let r of e)r.type==="set"?Me(t,r.path,r.new):r.type==="delete"&&Ir(t,r.path);return t},ke=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?Ir(t,r.path):Me(t,r.path,r.old):r.type==="delete"&&Me(t,r.path,r.old);return t};var at=(t={},e={},r={})=>{let n=Rr(t),{messageRoom:s}=n,{windowPerUser:d=16,synchronisationInterval:j=60*1e3}=t,f=[],A,H=0,x=0,m=d,U=i=>{let p=ar(),y=i.length>0?i[0].identifier:null;f.unshift({identifier:p,previous:y,sender:e.userId,stateDelta:i,time:{adjusted:Date.now()+H-x}}),f.length>m&&f.splice(m),s({identifier:p,previous:y,stateDelta:i,type:Ae}),M()},O=()=>{if(e.previousState){let i=me(e.previousState,r);i.length>0&&U(i)}},S=()=>{e.users.length>1&&s({type:xe,state:b(r)})},M=()=>{e.previousState=b(r)};return n.onMessage.addListener(({data:i,time:p})=>{if(!(i.sender===e.userId||i.receiver&&i.receiver!==e.userId)){if(H=(H+p.delay)/2,x=(x+p.offset)/2,i.type===xe){let y=0;for(;y<f.length&&!(f[y].time.adjusted>=p.adjusted);y++);f.splice(0,y);for(let l in r)delete r[l];for(let l in i.state)r[l]=i.state[l];for(let l=0;l<f.length;l++)_e(r,f[l].stateDelta);M()}else if(i.type===Ae){let y=!0;for(let l=0;l<f.length;l++){let C=f[l];if(C.identifier===i.previous||C.previous===i.previous&&C.time.adjusted<p.adjusted){f.splice(l,0,se(ne({},i),{time:p})),y=!1;break}}y&&f.unshift(se(ne({},i),{time:p}));for(let l=0;l<f.length;l++){let C=f[l];if(C.identifier===i.identifier)break;ke(r,C.stateDelta)}for(let l=0;l<f.length;l++){let C=f[l];if(_e(r,C.stateDelta),C.identifier===i.identifier)break}M()}}}),n.onConnection.addListener(({state:i})=>{e.connectionState=i}),n.onRoomJoin.addListener(({creatorId:i,roomCode:p,userId:y,users:l})=>{e.creatorId=i,e.roomCode=p,e.userId=y,e.users=l,e.verifiedUsers=[],e.previousState=b(r),y===i&&(e.verifiedUsers.push(y),A=setInterval(S,j))}),n.onRoomLeave.addListener(()=>{for(let i in e)delete e[i];A&&clearInterval(A)}),n.onUserJoin.addListener(({userId:i})=>{e.users.push(i),m=d+d*e.users.length}),n.onUserVerificationCode.addListener(i=>{i.userId===e.creatorId&&(e.verificationCode=i.code)}),n.onUserVerified.addListener(({userId:i})=>{e.verifiedUsers.push(i),m=d+d*e.users.length,e.userId===e.creatorId&&S()}),n.onUserLeave.addListener(({userId:i})=>{for(let p=0;p<e.users.length;p++)if(e.users[p]===i){e.users.splice(p,1);break}for(let p=0;p<e.verifiedUsers.length;p++)if(e.verifiedUsers[p]===i){e.verifiedUsers.splice(p,1);break}m=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:O},n)};export{Rr as createClientConnector,at as createClientSynchronizer};
