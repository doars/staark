var Ir=Object.defineProperty,Nr=Object.defineProperties;var Cr=Object.getOwnPropertyDescriptors;var Xe=Object.getOwnPropertySymbols;var xr=Object.prototype.hasOwnProperty,Ar=Object.prototype.propertyIsEnumerable;var je=(t,e,r)=>e in t?Ir(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ae=(t,e)=>{for(var r in e||(e={}))xr.call(e,r)&&je(t,r,e[r]);if(Xe)for(var r of Xe(e))Ar.call(e,r)&&je(t,r,e[r]);return t},de=(t,e)=>Nr(t,Cr(e));var J=(t,e,r)=>new Promise((n,o)=>{var d=x=>{try{E(r.next(x))}catch(H){o(H)}},F=x=>{try{E(r.throw(x))}catch(H){o(H)}},E=x=>x.done?n(x.value):Promise.resolve(x.value).then(d,F);E((r=r.apply(t,e)).next())});var Ae="CONNECTED",be="CONNECTING",z="DISCONNECTED",Te="DISCONNECTING",Be="PENDING_VERIFICATION";var br="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",we="ABCDEFGHKMNPQRSTUVWXYZ23456789",Je=(t=24,e=br)=>{let r="";for(let n=0;n<t;n++)r+=e.charAt(Math.floor(Math.random()*e.length));return r};var I=t=>{let e=atob(t);return Uint8Array.from(e,r=>r.charCodeAt(0)).buffer},ze=t=>{let e=atob(t),r=Uint8Array.from(e,n=>n.charCodeAt(0));return new TextDecoder().decode(r)},We=t=>{let e=new TextEncoder().encode(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)},N=t=>{let e=new Uint8Array(t);if(e.length<65536)return btoa(String.fromCharCode(...e));let r="",n=65536;for(let o=0;o<e.length;o+=n){let d=e.subarray(o,o+n);r+=String.fromCharCode(...d)}return btoa(r)};var P=()=>{let t=new Map;return{addListener:(e,r)=>{t.has(e)||t.set(e,r)},removeListener:e=>{t.delete(e)},dispatch:e=>{for(let[r,n]of t.entries())r(e),n&&n.once&&t.delete(r)}}};var Qe=(t,e)=>{let r=[];for(let n in t){let o=t[n];o!=null&&r.push(n+":"+e(String(o)))}return r.join("|")},Ze=(t,e)=>{let r={},n=t.split("|");for(let o of n){let d=o.indexOf(":");if(d>0){let F=o.substring(0,d),E=o.substring(d+1);r[F]=e(E)}}return r};var qe=(t,e)=>{let r=Date.now();if(!t)return{delay:0,offset:0,adjusted:r};if(!e){let d=t-r;return{delay:0,offset:d,adjusted:r+d}}let n=r-e,o=(t-e+(t-r))/2;return{delay:n,offset:o,adjusted:r-n+o}};var pe="ECDH",Oe="P-256";var ee="SHA-256",ue="spki",M="AES-GCM";var le="RSA-OAEP",W="RSASSA-PKCS1-v1_5",$e="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,e,r])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",e.publicKey)]).then(([n,o])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:e,myExchangeKeys:r,myPublicEncryptKey:n,myPublicSignKey:o})}).catch(n=>{self.postMessage({success:!1,error:n.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",er="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var mr=(t={})=>{let{contentType:e="application/json",deserializeMessage:r=JSON.parse,serializeMessage:n=JSON.stringify,createRoomEndpoint:o="/create-room",joinRoomEndpoint:d="/join-room",httpUrl:F="http://localhost:3000",wsUrl:E="http://localhost:3000",messageBufferMaxCount:x=50,messageBufferMaxDuration:H=60*1e3}=t,b=z,u,D,X,Q,K,s,y,h,p,A,re,v,j,fe,G,U=[],S,Z=new Map,te=new Map,ne=new Map,ye=new Map,Ce=new Map,B=()=>(!D&&!X&&(X=new Promise((c,a)=>{let g=new Worker(URL.createObjectURL(new Blob([$e],{type:"text/javascript"})));g.addEventListener("message",l=>{if(l.data.success)Q=l.data.myEncryptKeys,p=l.data.mySignKeys,K=l.data.myExchangeKeys,y=l.data.myPublicEncryptKey,h=l.data.myPublicSignKey,D=!0,X=null,c();else{let _=new Error(l.data.error);m.dispatch({error:_}),a(_)}g.terminate()}),g.addEventListener("error",l=>{m.dispatch({error:l}),a(l),g.terminate()}),g.postMessage({type:"USER_KEYS"})})),X);B();let m=P(),Se=P(),Le=P(),Pe=P(),Me=P(),He=P(),Ee=P(),ve=P(),ke=P(),Y=c=>{b!==c&&(b=c,ke.dispatch({state:c}))},Ge=c=>J(null,null,function*(){let a=Z.get(c);a&&(ye.set(c,Array.from(new Uint8Array(yield crypto.subtle.digest(ee,new TextEncoder().encode(fe+N(yield crypto.subtle.exportKey("raw",a))))))),ve.dispatch({userId:c,code:xe(c)}))}),q=()=>{b===z||b===Te||(Y(Te),S&&S.close(),u=D=X=s=Q=K=y=h=p=A=re=v=j=G=U=S=null,Z.clear(),te.clear(),ne.clear(),ye.clear(),Ce.clear(),B(),Y(z))},me=c=>_e({type:"_UK",userId:c}),Ye=(c,a=null)=>{if(!a&&b&&b!==z)return;Y(be),fe=c;let g=new URL(E+d);g.searchParams.append("code",fe),a&&g.searchParams.append("creator",a),S=new WebSocket(g.toString()),S.addEventListener("close",l=>{Pe.dispatch({event:l}),q()}),S.addEventListener("error",l=>{m.dispatch({event:l}),q()}),S.addEventListener("message",l=>J(null,null,function*(){Ve(Ze(l.data,ze),l.data)}))},Ve=(c,a,g=!1)=>J(null,null,function*(){let{["S"]:l,["T"]:_,["I"]:R,["E"]:L,["D"]:C,["V"]:w,["K"]:se,["P"]:oe,["G"]:Fe,["U"]:ie}=c,i,ce,he,$;if(l?he=l:C?he=C:he=a,L){if(!G||!g&&U.length>0){U.push({time:Date.now(),parts:c,raw:a}),U.length>x&&U.shift();return}if(!R){m.dispatch(new Error("Missing IV to decrypt message"));return}i=yield crypto.subtle.decrypt({iv:I(R),name:M},G,I(L)),i=new TextDecoder().decode(i),$=!0}else if(oe){if(!se||!w){m.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}D||(yield B());let f=I(oe),O=r(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:I(w),name:M},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:le},Q.privateKey,I(se)),{name:M},!0,["encrypt","decrypt"]),f)));if($=!0,O.type==="_X1")ce=O;else if(Fe){let k=O.sender;if(!k){m.dispatch({error:new Error("Message from unknown sender")});return}let ge=ne.get(k);if(!ge){m.dispatch({error:new Error("No public key for "+k)});return}if(!(yield crypto.subtle.verify(W,ge,I(Fe),f))){m.dispatch({error:new Error("Invalid signature from "+k)});return}ce=O}else{m.dispatch({error:new Error("Missing encryption signature")});return}}else i=he;if(!ce)try{ce=r(i)}catch(f){m.dispatch({error:new Error("Failed to parse message "+a)});return}switch(i=ce,i.type){case"_RJ":if(u=i.creatorId,s=i.userId,Le.dispatch({creatorId:i.creatorId,roomCode:fe,userId:i.userId,users:i.users}),s===u)Y(Ae);else{Y(Be),D||(yield B());let f=yield crypto.subtle.exportKey("raw",K.publicKey);V({type:"_X0",publicData:typeof v=="function"?v():v,publicEncryptKey:N(y),publicExchangeKey:N(f),publicSignKey:N(h)},{allowUnencrypted:!0,receiver:u})}break;case"_X0":if(ie===u&&s===u){let f=i.sender;if(j&&!j({data:i.publicData,userId:f})){me(f);return}te.set(f,yield crypto.subtle.importKey(ue,I(i.publicEncryptKey),{hash:ee,name:le},!0,["encrypt"]));let O=yield crypto.subtle.importKey(ue,I(i.publicSignKey),{hash:ee,name:W},!0,["verify"]),k=I(i.publicExchangeKey);if(!(yield crypto.subtle.verify(W,O,I(i.signature),k))){m.dispatch({error:new Error("Invalid signature for exchange from "+f)});return}ne.set(f,O),D||(yield B()),Z.set(f,yield crypto.subtle.deriveKey({name:pe,public:yield crypto.subtle.importKey("raw",k,{name:pe,namedCurve:Oe},!0,[])},K.privateKey,{length:256,name:M},!0,["encrypt","decrypt"]));let ge=yield crypto.subtle.exportKey("raw",K.publicKey);V({type:"_X1",publicData:typeof v=="function"?v():v,publicEncryptKey:N(y),publicExchangeKey:N(ge),publicSignKey:N(h)},{receiver:f}),Ge(f)}break;case"_X1":if(ie===s&&i.sender===u){if(j&&!j({data:i.publicData,userId:u})){q();return}let f=yield crypto.subtle.importKey(ue,I(i.publicSignKey),{hash:ee,name:W},!0,["verify"]);if(i.publicExchangeKey&&i.signature&&!(yield crypto.subtle.verify(W,f,I(i.signature),I(i.publicExchangeKey)))){m.dispatch({error:new Error("Invalid signature for exchange from "+u)}),q();return}ne.set(u,f),te.set(u,yield crypto.subtle.importKey(ue,I(i.publicEncryptKey),{hash:ee,name:le},!0,["encrypt"])),D||(yield B()),Z.set(u,yield crypto.subtle.deriveKey({name:pe,public:yield crypto.subtle.importKey("raw",I(i.publicExchangeKey),{name:pe,namedCurve:Oe},!0,[])},K.privateKey,{length:256,name:M},!0,["encrypt","decrypt"])),Ge(u)}break;case"_X2":if(ie===s&&i.sender===u){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}if(re&&!re({data:i.privateData,userId:u})){q();return}V({type:"_X3",privateData:A},{receiver:u})}break;case"_X3":if(ie===u&&s===u){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}let f=i.sender;if(!Ce.get(f)){m.dispatch({error:new Error("User not verified")}),me(f);return}if(re&&!re({data:i.privateData,userId:f})){me(f);return}V({type:"_X4",sharedKey:N(yield crypto.subtle.exportKey("raw",G))},{receiver:f}),Ee.dispatch({userId:f}),_e({type:"_UV",userId:f})}break;case"_X4":if(ie===s&&i.sender===u){if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}if(G=yield crypto.subtle.importKey("raw",I(i.sharedKey),{name:M},!0,["encrypt","decrypt"]),Ee.dispatch({userId:s}),U.length>0){let f=Date.now();for(U=U.filter(O=>f-O.time<H);U.length>0;){let{parts:O,raw:k}=U.shift();Ve(O,k,!0)}}Y(Ae)}break;case"_UL":He.dispatch({userId:i.userId}),Z.delete(i.userId),te.delete(i.userId),ne.delete(i.userId);break;case"_UJ":Me.dispatch({userId:i.userId});break;case"_UV":Ee.dispatch({userId:i.userId});break;default:if(!$){m.dispatch({error:new Error("Message was not encrypted")});return}Se.dispatch({data:i,time:qe(_,i==null?void 0:i.senderTime)});break}}),V=(g,...l)=>J(null,[g,...l],function*(c,a={}){if(!S||S.readyState!==WebSocket.OPEN)return m.dispatch({error:new Error("No open socket")}),!1;let _=n(de(ae({},c),{sender:s,senderTime:Date.now()})),R={},L=a.receiver;if(L){let C=te.get(L);if(C){let w=yield crypto.subtle.generateKey({name:M,length:256},!0,["encrypt","decrypt"]),se=crypto.getRandomValues(new Uint8Array(12)),oe=yield crypto.subtle.encrypt({iv:se,name:M},w,new TextEncoder().encode(_));D||(yield B()),R["V"]=N(se),R["K"]=N(yield crypto.subtle.encrypt({name:le},C,yield crypto.subtle.exportKey("raw",w))),R["P"]=N(oe),R["G"]=N(yield crypto.subtle.sign(W,p.privateKey,oe))}else if(a.allowUnencrypted)R["D"]=_;else return m.dispatch({error:new Error("No public key for "+L)}),!1;R["U"]=L}else if(a.server)R["S"]=_;else if(G){let C=crypto.getRandomValues(new Uint8Array(12));R["I"]=N(C),R["E"]=N(yield crypto.subtle.encrypt({iv:C,name:M},G,new TextEncoder().encode(_)))}else return m.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(Qe(R,We)),!0}),_e=c=>s&&s===u&&V(c,{server:!0}),Rr=(c,a)=>a&&V(c,{receiver:a}),xe=(c,a=6)=>{if(!ye.has(c))return!1;let g=ye.get(c),l="";for(let _=0;_<a;_++){let R=g[_]%we.length;l+=we[R]}return l};return{onConnection:ke,onError:m,onMessage:Se,onRoomJoin:Le,onRoomLeave:Pe,onUserJoin:Me,onUserLeave:He,onUserVerified:Ee,onUserVerificationCode:ve,messageRoom:c=>V(c),messageServer:_e,messageUser:Rr,closeRoom:()=>_e({type:"_RC"}),createRoom:(...a)=>J(null,[...a],function*(c={}){if(b&&b!==z)return;Y(be),c.publicData&&(v=c.publicData),c.verifyPublicData&&(j=c.verifyPublicData);try{yield new Promise((R,L)=>{let C=new Worker(URL.createObjectURL(new Blob([er],{type:"text/javascript"})));C.addEventListener("message",w=>{w.data.success?(G=w.data.sharedKey,R()):L(new Error(w.data.error)),C.terminate()}),C.addEventListener("error",w=>{L(w),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(R){Y(z),m.dispatch({error:R});return}let g=new URL(F+o);c.limit&&g.searchParams.append("limit",c.limit);let l=yield fetch(g.toString(),{method:"GET",headers:{Accept:e}});if(!l.ok)throw new Error("Failed to create room");let _=yield l.text();return _=r(_),s=_.userId,Ye(_.roomCode,_.creatorSecret),_}),joinRoom:(c,a={})=>{a.publicData&&(v=a.publicData),a.verifyPublicData&&(j=a.verifyPublicData),Ye(c)},leaveRoom:q,kickUser:me,getVerificationCode:xe,verifyUser:(c,a)=>J(null,null,function*(){if(s!==u||!a)return!1;let g=xe(c,a.length);return!g||!a||g!==a||(Ce.set(c,!0),!Z.get(c))?!1:(V({type:"_X2",privateData:A},{receiver:c}),!0)})}};var T=t=>{if(typeof t=="object"){let e=Array.isArray(t)?[]:{};for(let r in t)e[r]=T(t[r]);return e}return t};var Ke=(t,e,r)=>{let n=t;for(let o=0;o<e.length-1;o++){let d=e[o];d in n||(n[d]={}),n=n[d]}n[e[e.length-1]]=T(r)},_r=(t,e)=>{let r=t;for(let n=0;n<e.length-1;n++)if(r=r[e[n]],!r)return;Array.isArray(r)?r.splice(parseInt(e[e.length-1]),1):delete r[e[e.length-1]]},Ie=(t,e,r=[])=>{let n=[];for(let o in t){let d=[...r,o];o in e?typeof t[o]=="object"&&typeof e[o]=="object"?n.unshift(...Ie(t[o],e[o],d)):t[o]!==e[o]&&n.unshift({type:"set",path:d,old:T(t[o]),new:T(e[o])}):n.unshift({type:"delete",path:d,old:T(t[o])})}for(let o in e)o in t||n.unshift({type:"set",path:[...r,o],new:T(e[o])});return n},Ne=(t,e)=>{for(let r of e)r.type==="set"?Ke(t,r.path,r.new):r.type==="delete"&&_r(t,r.path);return t},Ue=(t,e)=>{for(let r of e)r.type==="set"?r.old===void 0?_r(t,r.path):Ke(t,r.path,r.old):r.type==="delete"&&Ke(t,r.path,r.old);return t};var lt=(t={},e={},r={})=>{let n=mr(t),{messageRoom:o}=n,{windowPerUser:d=16,synchronisationInterval:F=60*1e3}=t,E=[],x,H=0,b=0,u=d,D=s=>{let y=Je(),h=s.length>0?s[0].identifier:null;E.unshift({identifier:y,previous:h,sender:e.userId,stateDelta:s,time:{adjusted:Date.now()+H-b}}),E.length>u&&E.splice(u),o({identifier:y,previous:h,stateDelta:s,type:"_SU"}),K()},X=()=>{if(e.previousState){let s=Ie(e.previousState,r);s.length>0&&D(s)}},Q=()=>{e.users.length>1&&o({type:"_SS",state:T(r)})},K=()=>{e.previousState=T(r)};return n.onMessage.addListener(({data:s,time:y})=>{if(!(s.sender===e.userId||s.receiver&&s.receiver!==e.userId)){if(H=(H+y.delay)/2,b=(b+y.offset)/2,s.type==="_SS"){let h=0;for(;h<E.length&&!(E[h].time.adjusted>=y.adjusted);h++);E.splice(0,h);for(let p in r)delete r[p];for(let p in s.state)r[p]=s.state[p];for(let p=0;p<E.length;p++)Ne(r,E[p].stateDelta);K()}else if(s.type==="_SU"){let h=!0;for(let p=0;p<E.length;p++){let A=E[p];if(A.identifier===s.previous||A.previous===s.previous&&A.time.adjusted<y.adjusted){E.splice(p,0,de(ae({},s),{time:y})),h=!1;break}}h&&E.unshift(de(ae({},s),{time:y}));for(let p=0;p<E.length;p++){let A=E[p];if(A.identifier===s.identifier)break;Ue(r,A.stateDelta)}for(let p=0;p<E.length;p++){let A=E[p];if(Ne(r,A.stateDelta),A.identifier===s.identifier)break}K()}}}),n.onConnection.addListener(({state:s})=>{e.connectionState=s}),n.onRoomJoin.addListener(({creatorId:s,roomCode:y,userId:h,users:p})=>{e.creatorId=s,e.roomCode=y,e.userId=h,e.users=p,e.verifiedUsers=[],e.previousState=T(r),h===s&&(e.verifiedUsers.push(h),x=setInterval(Q,F))}),n.onRoomLeave.addListener(()=>{for(let s in e)delete e[s];x&&clearInterval(x)}),n.onUserJoin.addListener(({userId:s})=>{e.users.push(s),u=d+d*e.users.length}),n.onUserVerificationCode.addListener(s=>{s.userId===e.creatorId&&(e.verificationCode=s.code)}),n.onUserVerified.addListener(({userId:s})=>{e.verifiedUsers.push(s),u=d+d*e.users.length,e.userId===e.creatorId&&Q()}),n.onUserLeave.addListener(({userId:s})=>{for(let y=0;y<e.users.length;y++)if(e.users[y]===s){e.users.splice(y,1);break}for(let y=0;y<e.verifiedUsers.length;y++)if(e.verifiedUsers[y]===s){e.verifiedUsers.splice(y,1);break}u=d+d*e.users.length}),Object.assign({privateState:e,publicState:r,sendUpdate:X},n)};export{mr as createClientConnector,lt as createClientSynchronizer};
