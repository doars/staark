(()=>{var ft=Object.defineProperty,_t=Object.defineProperties;var Rt=Object.getOwnPropertyDescriptors;var je=Object.getOwnPropertySymbols;var mt=Object.prototype.hasOwnProperty,Nt=Object.prototype.propertyIsEnumerable;var Xe=(t,r,e)=>r in t?ft(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,Je=(t,r)=>{for(var e in r||(r={}))mt.call(r,e)&&Xe(t,e,r[e]);if(je)for(var e of je(r))Nt.call(r,e)&&Xe(t,e,r[e]);return t},ze=(t,r)=>_t(t,Rt(r));var Y=(t,r,e)=>new Promise((a,i)=>{var R=A=>{try{v(e.next(A))}catch(j){i(j)}},B=A=>{try{v(e.throw(A))}catch(j){i(j)}},v=A=>A.done?a(A.value):Promise.resolve(A.value).then(R,B);v((e=e.apply(t,r)).next())});var We=(t,r)=>{let e=window;for(let a=0;a<t.length-1;a++)(typeof e[t[a]]!="object"||!Array.isArray(e[t[a]]))&&(e[t[a]]={}),e=e[t[a]];e[t[t.length-1]]=r};var de="CONNECTED",fe="CONNECTING",G="DISCONNECTED",_e="DISCONNECTING",Qe="PENDING_VERIFICATION";var ye="_KA",Re="_KO",me="_KT",Ze="_RC",qe="_RJ";var $e="_UJ",et="_UK",tt="_UL",Ne="_UV";var Ie="ABCDEFGHKMNPQRSTUVWXYZ23456789";var l=t=>{let r=atob(t);return Uint8Array.from(r,e=>e.charCodeAt(0)).buffer},rt=t=>{let r=atob(t),e=Uint8Array.from(r,a=>a.charCodeAt(0));return new TextDecoder().decode(e)},nt=t=>{let r=new TextEncoder().encode(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",a=65536;for(let i=0;i<r.length;i+=a){let R=r.subarray(i,i+a);e+=String.fromCharCode(...R)}return btoa(e)},d=t=>{let r=new Uint8Array(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",a=65536;for(let i=0;i<r.length;i+=a){let R=r.subarray(i,i+a);e+=String.fromCharCode(...R)}return btoa(e)};var S=()=>{let t=new Map;return{addListener:(r,e)=>{t.has(r)||t.set(r,e)},removeListener:r=>{t.delete(r)},dispatch:r=>{for(let[e,a]of t.entries())e(r),a&&a.once&&t.delete(e)}}};var ot="|",st=":",at=(t,r)=>{let e=[];for(let a in t){let i=t[a];i!=null&&e.push(a+st+r(String(i)))}return e.join(ot)},ct=(t,r)=>{let e={},a=t.split(ot);for(let i of a){let R=i.indexOf(st);if(R>0){let B=i.substring(0,R),v=i.substring(R+1);e[B]=r(v)}}return e};var it=(t,r)=>{let e=Date.now();if(!t)return{delay:0,offset:0,adjusted:e};if(!r){let R=t-e;return{delay:0,offset:R,adjusted:e+R}}let a=e-r,i=(t-r+(t-e))/2;return{delay:a,offset:i,adjusted:e-a+i}};var $="ECDH",Ce="P-256",ee="raw",V="SHA-256",te="spki",N="AES-GCM";var re="RSA-OAEP",w="RSASSA-PKCS1-v1_5",pt="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,r,e])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",r.publicKey)]).then(([a,i])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:r,myExchangeKeys:e,myPublicEncryptKey:a,myPublicSignKey:i})}).catch(a=>{self.postMessage({success:!1,error:a.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",Et="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var ge="S",yt="T",be="E",he="I",Se="U",Ae="D",Te="V",Oe="K",Ke="P",we="G";var lt=(t={})=>{let{contentType:r="application/json",deserializeMessage:e=JSON.parse,serializeMessage:a=JSON.stringify,createRoomEndpoint:i="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:B="http://localhost:3000",wsUrl:v="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:j=60*1e3}=t,x=G,f,D,T,L,X,ue,F,m,ne,oe,J,se,P,b=[],h,M=new Map,z=new Map,W=new Map,ae=new Map,H=()=>(!D&&!X&&(X=new Promise((n,s)=>{let y=new Worker(URL.createObjectURL(new Blob([pt],{type:"text/javascript"})));y.addEventListener("message",c=>{if(c.data.success)ue=c.data.myEncryptKeys,J=c.data.mySignKeys,F=c.data.myExchangeKeys,ne=c.data.myPublicEncryptKey,oe=c.data.myPublicSignKey,D=!0,X=null,n();else{let E=new Error(c.data.error);_.dispatch({error:E}),s(E)}y.terminate()}),y.addEventListener("error",c=>{_.dispatch({error:c}),s(c),y.terminate()}),y.postMessage({type:"USER_KEYS"})})),X);H();let _=S(),xe=S(),De=S(),Pe=S(),Ue=S(),ve=S(),ce=S(),Le=S(),Me=S(),U=n=>{x!==n&&(x=n,Me.dispatch({state:n}))},He=n=>Y(null,null,function*(){let s=M.get(n);s&&(ae.set(n,Array.from(new Uint8Array(yield crypto.subtle.digest(V,new TextEncoder().encode(se+d(yield crypto.subtle.exportKey("raw",s))))))),Le.dispatch({userId:n,code:le(n)}))}),Q=()=>{x===G||x===_e||(U(_e),h&&h.close(),f=D=T=L=X=m=ue=F=ne=oe=J=P=b=h=null,M.clear(),z.clear(),W.clear(),ae.clear(),H(),U(G))},Ye=n=>ie({type:et,userId:n}),Ge=(n,s=null)=>{if(!s&&x&&x!==G)return;U(fe),se=n;let y=new URL(v+R);y.searchParams.append("code",se),s&&y.searchParams.append("creator",s),h=new WebSocket(y.toString()),h.addEventListener("close",c=>{Pe.dispatch({event:c}),Q()}),h.addEventListener("error",c=>{_.dispatch({event:c}),Q()}),h.addEventListener("message",c=>Y(null,null,function*(){Fe(ct(c.data,rt),c.data)}))},Fe=(n,s,y=!1)=>Y(null,null,function*(){let{[ge]:c,[yt]:E,[he]:u,[be]:I,[Ae]:C,[Te]:g,[Oe]:Z,[Ke]:ke,[we]:Ve,[Se]:Be}=n,o,q,pe;if(c?pe=c:C?pe=C:pe=s,I){if(!P||!y&&b.length>0){b.push({time:Date.now(),parts:n,raw:s}),b.length>A&&b.shift();return}if(!u){_.dispatch(new Error("Missing IV to decrypt message"));return}o=yield crypto.subtle.decrypt({iv:l(u),name:N},P,l(I)),o=new TextDecoder().decode(o)}else if(ke){if(!Ve||!Z||!g)return;D||(yield H());let p=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:l(g),name:N},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:re},ue.privateKey,l(Z)),{name:N},!0,["encrypt","decrypt"]),l(ke))));if(p.type===ye)q=p;else{let O=p.sender;if(!O){_.dispatch({error:new Error("Message from unknown sender")});return}let K=W.get(O);if(!K){_.dispatch({error:new Error("No public key for "+O)});return}if(!(yield crypto.subtle.verify(w,K,l(Ve),new TextEncoder().encode(p.payload)))){_.dispatch({error:new Error("Invalid signature from "+O)});return}q=p}}else o=pe;if(!q)try{q=e(o)}catch(p){_.dispatch({error:new Error("Failed to parse message "+s)});return}switch(o=q,o.type){case qe:if(f=o.creatorId,m=o.userId,De.dispatch({creatorId:o.creatorId,roomCode:se,userId:o.userId,users:o.users}),m===f)U(de);else{U(Qe),D||(yield H());let p=yield crypto.subtle.exportKey(ee,F.publicKey);k({type:Re,publicData:typeof T=="function"?T():T,publicEncryptKey:d(ne),publicExchangeKey:d(p),publicSignKey:d(oe),signature:d(yield crypto.subtle.sign(w,J.privateKey,p))},{allowUnencrypted:!0,receiver:f})}break;case Re:if(m===f){let p=o.sender;if(L&&!L({data:o.publicData,userId:p})){Ye(p);return}z.set(p,yield crypto.subtle.importKey(te,l(o.publicEncryptKey),{hash:V,name:re},!0,["encrypt"]));let O=yield crypto.subtle.importKey(te,l(o.publicSignKey),{hash:V,name:w},!0,["verify"]),K=l(o.publicExchangeKey);if(!(yield crypto.subtle.verify(w,O,l(o.signature),K))){_.dispatch({error:new Error("Invalid signature for exchange from "+p)});return}W.set(p,O),D||(yield H()),M.set(p,yield crypto.subtle.deriveKey({name:$,public:yield crypto.subtle.importKey(ee,K,{name:$,namedCurve:Ce},!0,[])},F.privateKey,{length:256,name:N},!0,["encrypt","decrypt"]));let Ee=yield crypto.subtle.exportKey(ee,F.publicKey);k({type:ye,publicData:typeof T=="function"?T():T,publicEncryptKey:d(ne),publicExchangeKey:d(Ee),publicSignKey:d(oe),signature:d(yield crypto.subtle.sign(w,J.privateKey,Ee))},{receiver:p}),He(p)}break;case ye:if(Be===m&&o.sender===f){if(L&&!L({data:o.publicData,userId:f})){Q();return}let p=yield crypto.subtle.importKey(te,l(o.publicSignKey),{hash:V,name:w},!0,["verify"]);if(o.publicExchangeKey&&o.signature&&!(yield crypto.subtle.verify(w,p,l(o.signature),l(o.publicExchangeKey)))){_.dispatch({error:new Error("Invalid signature for exchange from "+f)}),Q();return}W.set(f,p),z.set(f,yield crypto.subtle.importKey(te,l(o.publicEncryptKey),{hash:V,name:re},!0,["encrypt"])),D||(yield H()),M.set(f,yield crypto.subtle.deriveKey({name:$,public:yield crypto.subtle.importKey(ee,l(o.publicExchangeKey),{name:$,namedCurve:Ce},!0,[])},F.privateKey,{length:256,name:N},!0,["encrypt","decrypt"])),He(f)}break;case me:if(Be===m&&o.sender===f){let p=M.get(f);if(!p){_.dispatch({error:new Error("No derived key for host "+f)});return}if(P=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:l(o.sharedKeyIv),name:N},p,l(o.sharedKey)),{name:N},!0,["encrypt","decrypt"]),ce.dispatch({userId:m}),b.length>0){let O=Date.now();for(b=b.filter(K=>O-K.time<j);b.length>0;){let{parts:K,raw:Ee}=b.shift();Fe(K,Ee,!0)}}U(de)}break;case tt:ve.dispatch({userId:o.userId}),M.delete(o.userId),z.delete(o.userId),W.delete(o.userId);break;case $e:Ue.dispatch({userId:o.userId});break;case Ne:ce.dispatch({userId:o.userId});break;default:xe.dispatch({data:o,time:it(E,o==null?void 0:o.senderTime)});break}}),k=(y,...c)=>Y(null,[y,...c],function*(n,s={}){if(!h||h.readyState!==WebSocket.OPEN)return _.dispatch({error:new Error("No open socket")}),!1;let E=a(ze(Je({},n),{sender:m,senderTime:Date.now()})),u={};if(s.receiver){let I=z.get(s.receiver);if(I){let C=yield crypto.subtle.generateKey({name:N,length:256},!0,["encrypt","decrypt"]),g=crypto.getRandomValues(new Uint8Array(12)),Z=yield crypto.subtle.encrypt({iv:g,name:N},C,new TextEncoder().encode(E));D||(yield H()),u[we]=d(yield crypto.subtle.sign(w,J.privateKey,Z)),u[Oe]=d(yield crypto.subtle.encrypt({name:re},I,yield crypto.subtle.exportKey("raw",C))),u[Ke]=d(Z),u[Te]=d(g)}else if(s.allowUnencrypted)u[Ae]=E;else return _.dispatch({error:new Error("No public key for "+s.receiver)}),!1;u[Se]=s.receiver}else if(s.server)u[ge]=E;else if(P){let I=crypto.getRandomValues(new Uint8Array(12));u[he]=d(I),u[be]=d(yield crypto.subtle.encrypt({iv:I,name:N},P,new TextEncoder().encode(E)))}else return _.dispatch(new Error("Trying to send without valid destination")),!1;return h.send(at(u,nt)),!0}),ie=n=>m&&m===f&&k(n,{server:!0}),dt=(n,s)=>s&&k(n,{receiver:s}),le=(n,s=6)=>{if(!ae.has(n))return!1;let y=ae.get(n),c="";for(let E=0;E<s;E++){let u=y[E]%Ie.length;c+=Ie[u]}return c};return{onConnection:Me,onError:_,onMessage:xe,onRoomJoin:De,onRoomLeave:Pe,onUserJoin:Ue,onUserLeave:ve,onUserVerified:ce,onUserVerificationCode:Le,messageRoom:n=>k(n),messageServer:ie,messageUser:dt,closeRoom:()=>ie({type:Ze}),createRoom:(...s)=>Y(null,[...s],function*(n={}){if(x&&x!==G)return;U(fe),n.publicData&&(T=n.publicData),n.verifyPublicData&&(L=n.verifyPublicData);try{yield new Promise((u,I)=>{let C=new Worker(URL.createObjectURL(new Blob([Et],{type:"text/javascript"})));C.addEventListener("message",g=>{g.data.success?(P=g.data.sharedKey,u()):I(new Error(g.data.error)),C.terminate()}),C.addEventListener("error",g=>{I(g),C.terminate()}),C.postMessage({type:"SHARED_KEY"})})}catch(u){U(G),_.dispatch({error:u});return}let y=new URL(B+i);n.limit&&y.searchParams.append("limit",n.limit);let c=yield fetch(y.toString(),{method:"GET",headers:{Accept:r}});if(!c.ok)throw new Error("Failed to create room");let E=yield c.text();return E=e(E),m=E.userId,Ge(E.roomCode,E.creatorSecret),E}),joinRoom:(n,s={})=>{s.publicData&&(T=s.publicData),s.verifyPublicData&&(L=s.verifyPublicData),Ge(n)},leaveRoom:Q,kickUser:Ye,getVerificationCode:le,verifyUser:(n,s)=>Y(null,null,function*(){if(m!==f||!s)return!1;let y=le(n,s.length);if(!y||!s||y!==s)return!1;let c=M.get(n);if(!c)return!1;let E=crypto.getRandomValues(new Uint8Array(12));return k({type:me,sharedKey:d(yield crypto.subtle.encrypt({iv:E,name:N},c,yield crypto.subtle.exportKey("raw",P))),sharedKeyIv:d(E)},{receiver:n}),ce.dispatch({userId:n}),ie({type:Ne,userId:n}),!0})}};We(["roupn"],{createClientConnector:lt});})();
