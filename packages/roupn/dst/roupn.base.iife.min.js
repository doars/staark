(()=>{var dt=Object.defineProperty,lt=Object.defineProperties;var ft=Object.getOwnPropertyDescriptors;var ve=Object.getOwnPropertySymbols;var _t=Object.prototype.hasOwnProperty,Rt=Object.prototype.propertyIsEnumerable;var He=(t,r,e)=>r in t?dt(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,Ge=(t,r)=>{for(var e in r||(r={}))_t.call(r,e)&&He(t,e,r[e]);if(ve)for(var e of ve(r))Rt.call(r,e)&&He(t,e,r[e]);return t},Ye=(t,r)=>lt(t,ft(r));var H=(t,r,e)=>new Promise((s,c)=>{var R=w=>{try{M(e.next(w))}catch(J){c(J)}},j=w=>{try{M(e.throw(w))}catch(J){c(J)}},M=w=>w.done?s(w.value):Promise.resolve(w.value).then(R,j);M((e=e.apply(t,r)).next())});var ke=(t,r)=>{let e=window;for(let s=0;s<t.length-1;s++)(typeof e[t[s]]!="object"||!Array.isArray(e[t[s]]))&&(e[t[s]]={}),e=e[t[s]];e[t[t.length-1]]=r};var Ie="CONNECTED",ge="CONNECTING",G="DISCONNECTED",Ce="DISCONNECTING",Fe="PENDING_VERIFICATION";var be="ABCDEFGHKMNPQRSTUVWXYZ23456789";var f=t=>{let r=atob(t);return Uint8Array.from(r,e=>e.charCodeAt(0)).buffer},Ve=t=>{let r=atob(t),e=Uint8Array.from(r,s=>s.charCodeAt(0));return new TextDecoder().decode(e)},Xe=t=>{let r=new TextEncoder().encode(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let c=0;c<r.length;c+=s){let R=r.subarray(c,c+s);e+=String.fromCharCode(...R)}return btoa(e)},_=t=>{let r=new Uint8Array(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let c=0;c<r.length;c+=s){let R=r.subarray(c,c+s);e+=String.fromCharCode(...R)}return btoa(e)};var S=()=>{let t=new Map;return{addListener:(r,e)=>{t.has(r)||t.set(r,e)},removeListener:r=>{t.delete(r)},dispatch:r=>{for(let[e,s]of t.entries())e(r),s&&s.once&&t.delete(e)}}};var Be=(t,r)=>{let e=[];for(let s in t){let c=t[s];c!=null&&e.push(s+":"+r(String(c)))}return e.join("|")},je=(t,r)=>{let e={},s=t.split("|");for(let c of s){let R=c.indexOf(":");if(R>0){let j=c.substring(0,R),M=c.substring(R+1);e[j]=r(M)}}return e};var Je=(t,r)=>{let e=Date.now();if(!t)return{delay:0,offset:0,adjusted:e};if(!r){let R=t-e;return{delay:0,offset:R,adjusted:e+R}}let s=e-r,c=(t-r+(t-e))/2;return{delay:s,offset:c,adjusted:e-s+c}};var re="ECDH",he="P-256";var B="SHA-256",ne="spki",A="AES-GCM";var oe="RSA-OAEP",Y="RSASSA-PKCS1-v1_5",ze="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,r,e])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",r.publicKey)]).then(([s,c])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:r,myExchangeKeys:e,myPublicEncryptKey:s,myPublicSignKey:c})}).catch(s=>{self.postMessage({success:!1,error:s.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",We="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var yt=(t={})=>{let{contentType:r="application/json",deserializeMessage:e=JSON.parse,serializeMessage:s=JSON.stringify,createRoomEndpoint:c="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:j="http://localhost:3000",wsUrl:M="http://localhost:3000",messageBufferMaxCount:w=50,messageBufferMaxDuration:J=60*1e3}=t,K=G,y,x,z,fe,k,N,se,ae,_e,Re,W,T,L,ce,D,C=[],b,F=new Map,Q=new Map,Z=new Map,ie=new Map,Ne=new Map,v=()=>(!x&&!z&&(z=new Promise((o,a)=>{let d=new Worker(URL.createObjectURL(new Blob([ze],{type:"text/javascript"})));d.addEventListener("message",i=>{if(i.data.success)fe=i.data.myEncryptKeys,_e=i.data.mySignKeys,k=i.data.myExchangeKeys,se=i.data.myPublicEncryptKey,ae=i.data.myPublicSignKey,x=!0,z=null,o();else{let u=new Error(i.data.error);E.dispatch({error:u}),a(u)}d.terminate()}),d.addEventListener("error",i=>{E.dispatch({error:i}),a(i),d.terminate()}),d.postMessage({type:"USER_KEYS"})})),z);v();let E=S(),Ae=S(),we=S(),Te=S(),Oe=S(),Ke=S(),pe=S(),xe=S(),De=S(),P=o=>{K!==o&&(K=o,De.dispatch({state:o}))},Pe=o=>H(null,null,function*(){let a=F.get(o);a&&(ie.set(o,Array.from(new Uint8Array(yield crypto.subtle.digest(B,new TextEncoder().encode(ce+_(yield crypto.subtle.exportKey("raw",a))))))),xe.dispatch({userId:o,code:me(o)}))}),V=()=>{K===G||K===Ce||(P(Ce),b&&b.close(),y=x=z=N=fe=k=se=ae=_e=Re=W=T=L=D=C=b=null,F.clear(),Q.clear(),Z.clear(),ie.clear(),Ne.clear(),v(),P(G))},Ee=o=>ye({type:"_UK",userId:o}),Ue=(o,a=null)=>{if(!a&&K&&K!==G)return;P(ge),ce=o;let d=new URL(M+R);d.searchParams.append("code",ce),a&&d.searchParams.append("creator",a),b=new WebSocket(d.toString()),b.addEventListener("close",i=>{Te.dispatch({event:i}),V()}),b.addEventListener("error",i=>{E.dispatch({event:i}),V()}),b.addEventListener("message",i=>H(null,null,function*(){Me(je(i.data,Ve),i.data)}))},Me=(o,a,d=!1)=>H(null,null,function*(){let{["S"]:i,["T"]:u,["I"]:l,["E"]:h,["D"]:m,["V"]:I,["K"]:q,["P"]:$,["G"]:Le,["U"]:ee}=o,n,te,ue,X;if(i?ue=i:m?ue=m:ue=a,h){if(!D||!d&&C.length>0){C.push({time:Date.now(),parts:o,raw:a}),C.length>w&&C.shift();return}if(!l){E.dispatch(new Error("Missing IV to decrypt message"));return}n=yield crypto.subtle.decrypt({iv:f(l),name:A},D,f(h)),n=new TextDecoder().decode(n),X=!0}else if($){if(!q||!I){E.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}x||(yield v());let p=f($),g=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:f(I),name:A},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:oe},fe.privateKey,f(q)),{name:A},!0,["encrypt","decrypt"]),p)));if(X=!0,g.type==="_X1")te=g;else if(Le){let O=g.sender;if(!O){E.dispatch({error:new Error("Message from unknown sender")});return}let de=Z.get(O);if(!de){E.dispatch({error:new Error("No public key for "+O)});return}if(!(yield crypto.subtle.verify(Y,de,f(Le),p))){E.dispatch({error:new Error("Invalid signature from "+O)});return}te=g}else{E.dispatch({error:new Error("Missing encryption signature")});return}}else n=ue;if(!te)try{te=e(n)}catch(p){E.dispatch({error:new Error("Failed to parse message "+a)});return}switch(n=te,n.type){case"_RJ":if(y=n.creatorId,N=n.userId,we.dispatch({creatorId:n.creatorId,roomCode:ce,userId:n.userId,users:n.users}),N===y)P(Ie);else{P(Fe),x||(yield v());let p=yield crypto.subtle.exportKey("raw",k.publicKey);U({type:"_X0",publicData:typeof T=="function"?T():T,publicEncryptKey:_(se),publicExchangeKey:_(p),publicSignKey:_(ae)},{allowUnencrypted:!0,receiver:y})}break;case"_X0":if(ee===y&&N===y){let p=n.sender;if(L&&!L({data:n.publicData,userId:p})){Ee(p);return}Q.set(p,yield crypto.subtle.importKey(ne,f(n.publicEncryptKey),{hash:B,name:oe},!0,["encrypt"]));let g=yield crypto.subtle.importKey(ne,f(n.publicSignKey),{hash:B,name:Y},!0,["verify"]),O=f(n.publicExchangeKey);if(!(yield crypto.subtle.verify(Y,g,f(n.signature),O))){E.dispatch({error:new Error("Invalid signature for exchange from "+p)});return}Z.set(p,g),x||(yield v()),F.set(p,yield crypto.subtle.deriveKey({name:re,public:yield crypto.subtle.importKey("raw",O,{name:re,namedCurve:he},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"]));let de=yield crypto.subtle.exportKey("raw",k.publicKey);U({type:"_X1",publicData:typeof T=="function"?T():T,publicEncryptKey:_(se),publicExchangeKey:_(de),publicSignKey:_(ae)},{receiver:p}),Pe(p)}break;case"_X1":if(ee===N&&n.sender===y){if(L&&!L({data:n.publicData,userId:y})){V();return}let p=yield crypto.subtle.importKey(ne,f(n.publicSignKey),{hash:B,name:Y},!0,["verify"]);if(n.publicExchangeKey&&n.signature&&!(yield crypto.subtle.verify(Y,p,f(n.signature),f(n.publicExchangeKey)))){E.dispatch({error:new Error("Invalid signature for exchange from "+y)}),V();return}Z.set(y,p),Q.set(y,yield crypto.subtle.importKey(ne,f(n.publicEncryptKey),{hash:B,name:oe},!0,["encrypt"])),x||(yield v()),F.set(y,yield crypto.subtle.deriveKey({name:re,public:yield crypto.subtle.importKey("raw",f(n.publicExchangeKey),{name:re,namedCurve:he},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"])),Pe(y)}break;case"_X2":if(ee===N&&n.sender===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}if(W&&!W({data:n.privateData,userId:y})){V();return}U({type:"_X3",privateData:Re},{receiver:y})}break;case"_X3":if(ee===y&&N===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}let p=n.sender;if(!Ne.get(p)){E.dispatch({error:new Error("User not verified")}),Ee(p);return}if(W&&!W({data:n.privateData,userId:p})){Ee(p);return}U({type:"_X4",sharedKey:_(yield crypto.subtle.exportKey("raw",D))},{receiver:p}),pe.dispatch({userId:p}),ye({type:"_UV",userId:p})}break;case"_X4":if(ee===N&&n.sender===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}if(D=yield crypto.subtle.importKey("raw",f(n.sharedKey),{name:A},!0,["encrypt","decrypt"]),pe.dispatch({userId:N}),C.length>0){let p=Date.now();for(C=C.filter(g=>p-g.time<J);C.length>0;){let{parts:g,raw:O}=C.shift();Me(g,O,!0)}}P(Ie)}break;case"_UL":Ke.dispatch({userId:n.userId}),F.delete(n.userId),Q.delete(n.userId),Z.delete(n.userId);break;case"_UJ":Oe.dispatch({userId:n.userId});break;case"_UV":pe.dispatch({userId:n.userId});break;default:if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}Ae.dispatch({data:n,time:Je(u,n==null?void 0:n.senderTime)});break}}),U=(d,...i)=>H(null,[d,...i],function*(o,a={}){if(!b||b.readyState!==WebSocket.OPEN)return E.dispatch({error:new Error("No open socket")}),!1;let u=s(Ye(Ge({},o),{sender:N,senderTime:Date.now()})),l={},h=a.receiver;if(h){let m=Q.get(h);if(m){let I=yield crypto.subtle.generateKey({name:A,length:256},!0,["encrypt","decrypt"]),q=crypto.getRandomValues(new Uint8Array(12)),$=yield crypto.subtle.encrypt({iv:q,name:A},I,new TextEncoder().encode(u));x||(yield v()),l["V"]=_(q),l["K"]=_(yield crypto.subtle.encrypt({name:oe},m,yield crypto.subtle.exportKey("raw",I))),l["P"]=_($),l["G"]=_(yield crypto.subtle.sign(Y,_e.privateKey,$))}else if(a.allowUnencrypted)l["D"]=u;else return E.dispatch({error:new Error("No public key for "+h)}),!1;l["U"]=h}else if(a.server)l["S"]=u;else if(D){let m=crypto.getRandomValues(new Uint8Array(12));l["I"]=_(m),l["E"]=_(yield crypto.subtle.encrypt({iv:m,name:A},D,new TextEncoder().encode(u)))}else return E.dispatch(new Error("Trying to send without valid destination")),!1;return b.send(Be(l,Xe)),!0}),ye=o=>N&&N===y&&U(o,{server:!0}),ut=(o,a)=>a&&U(o,{receiver:a}),me=(o,a=6)=>{if(!ie.has(o))return!1;let d=ie.get(o),i="";for(let u=0;u<a;u++){let l=d[u]%be.length;i+=be[l]}return i};return{onConnection:De,onError:E,onMessage:Ae,onRoomJoin:we,onRoomLeave:Te,onUserJoin:Oe,onUserLeave:Ke,onUserVerified:pe,onUserVerificationCode:xe,messageRoom:o=>U(o),messageServer:ye,messageUser:ut,closeRoom:()=>ye({type:"_RC"}),createRoom:(...a)=>H(null,[...a],function*(o={}){if(K&&K!==G)return;P(ge),o.publicData&&(T=o.publicData),o.verifyPublicData&&(L=o.verifyPublicData);try{yield new Promise((l,h)=>{let m=new Worker(URL.createObjectURL(new Blob([We],{type:"text/javascript"})));m.addEventListener("message",I=>{I.data.success?(D=I.data.sharedKey,l()):h(new Error(I.data.error)),m.terminate()}),m.addEventListener("error",I=>{h(I),m.terminate()}),m.postMessage({type:"SHARED_KEY"})})}catch(l){P(G),E.dispatch({error:l});return}let d=new URL(j+c);o.limit&&d.searchParams.append("limit",o.limit);let i=yield fetch(d.toString(),{method:"GET",headers:{Accept:r}});if(!i.ok)throw new Error("Failed to create room");let u=yield i.text();return u=e(u),N=u.userId,Ue(u.roomCode,u.creatorSecret),u}),joinRoom:(o,a={})=>{a.publicData&&(T=a.publicData),a.verifyPublicData&&(L=a.verifyPublicData),Ue(o)},leaveRoom:V,kickUser:Ee,getVerificationCode:me,verifyUser:(o,a)=>H(null,null,function*(){if(N!==y||!a)return!1;let d=me(o,a.length);return!d||!a||d!==a||(Ne.set(o,!0),!F.get(o))?!1:(U({type:"_X2",privateData:Re},{receiver:o}),!0)})}};ke(["roupn"],{createClientConnector:yt});})();
