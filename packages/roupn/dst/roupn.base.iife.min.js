(()=>{var It=Object.defineProperty,gt=Object.defineProperties;var Ct=Object.getOwnPropertyDescriptors;var Qe=Object.getOwnPropertySymbols;var bt=Object.prototype.hasOwnProperty,St=Object.prototype.propertyIsEnumerable;var Ze=(t,r,e)=>r in t?It(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,qe=(t,r)=>{for(var e in r||(r={}))bt.call(r,e)&&Ze(t,e,r[e]);if(Qe)for(var e of Qe(r))St.call(r,e)&&Ze(t,e,r[e]);return t},$e=(t,r)=>gt(t,Ct(r));var G=(t,r,e)=>new Promise((s,c)=>{var R=O=>{try{L(e.next(O))}catch(j){c(j)}},B=O=>{try{L(e.throw(O))}catch(j){c(j)}},L=O=>O.done?s(O.value):Promise.resolve(O.value).then(R,B);L((e=e.apply(t,r)).next())});var et=(t,r)=>{let e=window;for(let s=0;s<t.length-1;s++)(typeof e[t[s]]!="object"||!Array.isArray(e[t[s]]))&&(e[t[s]]={}),e=e[t[s]];e[t[t.length-1]]=r};var Ie="CONNECTED",ge="CONNECTING",Y="DISCONNECTED",Ce="DISCONNECTING",tt="PENDING_VERIFICATION";var be="_X0",de="_X1",Se="_X2",he="_X3",Ae="_X4",rt="_RC",nt="_RJ";var ot="_UJ",st="_UK",at="_UL",Oe="_UV";var Te="ABCDEFGHKMNPQRSTUVWXYZ23456789";var d=t=>{let r=atob(t);return Uint8Array.from(r,e=>e.charCodeAt(0)).buffer},ct=t=>{let r=atob(t),e=Uint8Array.from(r,s=>s.charCodeAt(0));return new TextDecoder().decode(e)},it=t=>{let r=new TextEncoder().encode(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let c=0;c<r.length;c+=s){let R=r.subarray(c,c+s);e+=String.fromCharCode(...R)}return btoa(e)},f=t=>{let r=new Uint8Array(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let c=0;c<r.length;c+=s){let R=r.subarray(c,c+s);e+=String.fromCharCode(...R)}return btoa(e)};var h=()=>{let t=new Map;return{addListener:(r,e)=>{t.has(r)||t.set(r,e)},removeListener:r=>{t.delete(r)},dispatch:r=>{for(let[e,s]of t.entries())e(r),s&&s.once&&t.delete(e)}}};var pt="|",Et=":",yt=(t,r)=>{let e=[];for(let s in t){let c=t[s];c!=null&&e.push(s+Et+r(String(c)))}return e.join(pt)},ut=(t,r)=>{let e={},s=t.split(pt);for(let c of s){let R=c.indexOf(Et);if(R>0){let B=c.substring(0,R),L=c.substring(R+1);e[B]=r(L)}}return e};var lt=(t,r)=>{let e=Date.now();if(!t)return{delay:0,offset:0,adjusted:e};if(!r){let R=t-e;return{delay:0,offset:R,adjusted:e+R}}let s=e-r,c=(t-r+(t-e))/2;return{delay:s,offset:c,adjusted:e-s+c}};var ne="ECDH",we="P-256",oe="raw",X="SHA-256",se="spki",A="AES-GCM";var ae="RSA-OAEP",K="RSASSA-PKCS1-v1_5",dt="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,r,e])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",r.publicKey)]).then(([s,c])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:r,myExchangeKeys:e,myPublicEncryptKey:s,myPublicSignKey:c})}).catch(s=>{self.postMessage({success:!1,error:s.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",ft="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Ke="S",_t="T",xe="E",De="I",Pe="U",Ue="D",ve="V",Le="K",Me="P",He="G";var Nt=(t={})=>{let{contentType:r="application/json",deserializeMessage:e=JSON.parse,serializeMessage:s=JSON.stringify,createRoomEndpoint:c="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:B="http://localhost:3000",wsUrl:L="http://localhost:3000",messageBufferMaxCount:O=50,messageBufferMaxDuration:j=60*1e3}=t,x=Y,E,D,J,fe,k,N,ce,ie,z,_e,W,T,M,pe,P,C=[],b,V=new Map,Q=new Map,Z=new Map,Ee=new Map,Re=new Map,H=()=>(!D&&!J&&(J=new Promise((o,a)=>{let u=new Worker(URL.createObjectURL(new Blob([dt],{type:"text/javascript"})));u.addEventListener("message",i=>{if(i.data.success)fe=i.data.myEncryptKeys,z=i.data.mySignKeys,k=i.data.myExchangeKeys,ce=i.data.myPublicEncryptKey,ie=i.data.myPublicSignKey,D=!0,J=null,o();else{let y=new Error(i.data.error);_.dispatch({error:y}),a(y)}u.terminate()}),u.addEventListener("error",i=>{_.dispatch({error:i}),a(i),u.terminate()}),u.postMessage({type:"USER_KEYS"})})),J);H();let _=h(),Ge=h(),Ye=h(),ke=h(),Ve=h(),Fe=h(),ye=h(),Xe=h(),Be=h(),U=o=>{x!==o&&(x=o,Be.dispatch({state:o}))},je=o=>G(null,null,function*(){let a=V.get(o);a&&(Ee.set(o,Array.from(new Uint8Array(yield crypto.subtle.digest(X,new TextEncoder().encode(pe+f(yield crypto.subtle.exportKey("raw",a))))))),Xe.dispatch({userId:o,code:me(o)}))}),F=()=>{x===Y||x===Ce||(U(Ce),b&&b.close(),E=D=J=N=fe=k=ce=ie=z=_e=W=T=M=P=C=b=null,V.clear(),Q.clear(),Z.clear(),Ee.clear(),Re.clear(),H(),U(Y))},Ne=o=>ue({type:st,userId:o}),Je=(o,a=null)=>{if(!a&&x&&x!==Y)return;U(ge),pe=o;let u=new URL(L+R);u.searchParams.append("code",pe),a&&u.searchParams.append("creator",a),b=new WebSocket(u.toString()),b.addEventListener("close",i=>{ke.dispatch({event:i}),F()}),b.addEventListener("error",i=>{_.dispatch({event:i}),F()}),b.addEventListener("message",i=>G(null,null,function*(){ze(ut(i.data,ct),i.data)}))},ze=(o,a,u=!1)=>G(null,null,function*(){let{[Ke]:i,[_t]:y,[De]:l,[xe]:S,[Ue]:m,[ve]:I,[Le]:q,[Me]:$,[He]:We,[Pe]:ee}=o,n,te,le;if(i?le=i:m?le=m:le=a,S){if(!P||!u&&C.length>0){C.push({time:Date.now(),parts:o,raw:a}),C.length>O&&C.shift();return}if(!l){_.dispatch(new Error("Missing IV to decrypt message"));return}n=yield crypto.subtle.decrypt({iv:d(l),name:A},P,d(S)),n=new TextDecoder().decode(n)}else if($){if(!We||!q||!I){_.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}D||(yield H());let p=d($),g=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:d(I),name:A},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ae},fe.privateKey,d(q)),{name:A},!0,["encrypt","decrypt"]),p)));if(g.type===de)te=g;else{let w=g.sender;if(!w){_.dispatch({error:new Error("Message from unknown sender")});return}let re=Z.get(w);if(!re){_.dispatch({error:new Error("No public key for "+w)});return}if(!(yield crypto.subtle.verify(K,re,d(We),p))){_.dispatch({error:new Error("Invalid signature from "+w)});return}te=g}}else n=le;if(!te)try{te=e(n)}catch(p){_.dispatch({error:new Error("Failed to parse message "+a)});return}switch(n=te,n.type){case nt:if(E=n.creatorId,N=n.userId,Ye.dispatch({creatorId:n.creatorId,roomCode:pe,userId:n.userId,users:n.users}),N===E)U(Ie);else{U(tt),D||(yield H());let p=yield crypto.subtle.exportKey(oe,k.publicKey);v({type:be,publicData:typeof T=="function"?T():T,publicEncryptKey:f(ce),publicExchangeKey:f(p),publicSignKey:f(ie),signature:f(yield crypto.subtle.sign(K,z.privateKey,p))},{allowUnencrypted:!0,receiver:E})}break;case be:if(ee===E&&N===E){let p=n.sender;if(M&&!M({data:n.publicData,userId:p})){Ne(p);return}Q.set(p,yield crypto.subtle.importKey(se,d(n.publicEncryptKey),{hash:X,name:ae},!0,["encrypt"]));let g=yield crypto.subtle.importKey(se,d(n.publicSignKey),{hash:X,name:K},!0,["verify"]),w=d(n.publicExchangeKey);if(!(yield crypto.subtle.verify(K,g,d(n.signature),w))){_.dispatch({error:new Error("Invalid signature for exchange from "+p)});return}Z.set(p,g),D||(yield H()),V.set(p,yield crypto.subtle.deriveKey({name:ne,public:yield crypto.subtle.importKey(oe,w,{name:ne,namedCurve:we},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"]));let re=yield crypto.subtle.exportKey(oe,k.publicKey);v({type:de,publicData:typeof T=="function"?T():T,publicEncryptKey:f(ce),publicExchangeKey:f(re),publicSignKey:f(ie),signature:f(yield crypto.subtle.sign(K,z.privateKey,re))},{receiver:p}),je(p)}break;case de:if(ee===N&&n.sender===E){if(M&&!M({data:n.publicData,userId:E})){F();return}let p=yield crypto.subtle.importKey(se,d(n.publicSignKey),{hash:X,name:K},!0,["verify"]);if(n.publicExchangeKey&&n.signature&&!(yield crypto.subtle.verify(K,p,d(n.signature),d(n.publicExchangeKey)))){_.dispatch({error:new Error("Invalid signature for exchange from "+E)}),F();return}Z.set(E,p),Q.set(E,yield crypto.subtle.importKey(se,d(n.publicEncryptKey),{hash:X,name:ae},!0,["encrypt"])),D||(yield H()),V.set(E,yield crypto.subtle.deriveKey({name:ne,public:yield crypto.subtle.importKey(oe,d(n.publicExchangeKey),{name:ne,namedCurve:we},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"])),je(E)}break;case Se:if(ee===N&&n.sender===E){if(W&&!W({data:n.privateData,userId:E})){F();return}v({type:he,privateData:_e},{receiver:E})}break;case he:if(ee===E&&N===E){let p=n.sender;if(!Re.get(p)||W&&!W({data:n.privateData,userId:p})){Ne(p);return}v({type:Ae,sharedKey:f(yield crypto.subtle.exportKey("raw",P))},{receiver:p}),ye.dispatch({userId:p}),ue({type:Oe,userId:p})}break;case Ae:if(ee===N&&n.sender===E){if(P=yield crypto.subtle.importKey("raw",d(n.sharedKey),{name:A},!0,["encrypt","decrypt"]),ye.dispatch({userId:N}),C.length>0){let p=Date.now();for(C=C.filter(g=>p-g.time<j);C.length>0;){let{parts:g,raw:w}=C.shift();ze(g,w,!0)}}U(Ie)}break;case at:Fe.dispatch({userId:n.userId}),V.delete(n.userId),Q.delete(n.userId),Z.delete(n.userId);break;case ot:Ve.dispatch({userId:n.userId});break;case Oe:ye.dispatch({userId:n.userId});break;default:Ge.dispatch({data:n,time:lt(y,n==null?void 0:n.senderTime)});break}}),v=(u,...i)=>G(null,[u,...i],function*(o,a={}){if(!b||b.readyState!==WebSocket.OPEN)return _.dispatch({error:new Error("No open socket")}),!1;let y=s($e(qe({},o),{sender:N,senderTime:Date.now()})),l={},S=a.receiver;if(S){let m=Q.get(S);if(m){let I=yield crypto.subtle.generateKey({name:A,length:256},!0,["encrypt","decrypt"]),q=crypto.getRandomValues(new Uint8Array(12)),$=yield crypto.subtle.encrypt({iv:q,name:A},I,new TextEncoder().encode(y));D||(yield H()),l[ve]=f(q),l[Le]=f(yield crypto.subtle.encrypt({name:ae},m,yield crypto.subtle.exportKey("raw",I))),l[Me]=f($),l[He]=f(yield crypto.subtle.sign(K,z.privateKey,$))}else if(a.allowUnencrypted)l[Ue]=y;else return _.dispatch({error:new Error("No public key for "+S)}),!1;l[Pe]=S}else if(a.server)l[Ke]=y;else if(P){let m=crypto.getRandomValues(new Uint8Array(12));l[De]=f(m),l[xe]=f(yield crypto.subtle.encrypt({iv:m,name:A},P,new TextEncoder().encode(y)))}else return _.dispatch(new Error("Trying to send without valid destination")),!1;return b.send(yt(l,it)),!0}),ue=o=>N&&N===E&&v(o,{server:!0}),mt=(o,a)=>a&&v(o,{receiver:a}),me=(o,a=6)=>{if(!Ee.has(o))return!1;let u=Ee.get(o),i="";for(let y=0;y<a;y++){let l=u[y]%Te.length;i+=Te[l]}return i};return{onConnection:Be,onError:_,onMessage:Ge,onRoomJoin:Ye,onRoomLeave:ke,onUserJoin:Ve,onUserLeave:Fe,onUserVerified:ye,onUserVerificationCode:Xe,messageRoom:o=>v(o),messageServer:ue,messageUser:mt,closeRoom:()=>ue({type:rt}),createRoom:(...a)=>G(null,[...a],function*(o={}){if(x&&x!==Y)return;U(ge),o.publicData&&(T=o.publicData),o.verifyPublicData&&(M=o.verifyPublicData);try{yield new Promise((l,S)=>{let m=new Worker(URL.createObjectURL(new Blob([ft],{type:"text/javascript"})));m.addEventListener("message",I=>{I.data.success?(P=I.data.sharedKey,l()):S(new Error(I.data.error)),m.terminate()}),m.addEventListener("error",I=>{S(I),m.terminate()}),m.postMessage({type:"SHARED_KEY"})})}catch(l){U(Y),_.dispatch({error:l});return}let u=new URL(B+c);o.limit&&u.searchParams.append("limit",o.limit);let i=yield fetch(u.toString(),{method:"GET",headers:{Accept:r}});if(!i.ok)throw new Error("Failed to create room");let y=yield i.text();return y=e(y),N=y.userId,Je(y.roomCode,y.creatorSecret),y}),joinRoom:(o,a={})=>{a.publicData&&(T=a.publicData),a.verifyPublicData&&(M=a.verifyPublicData),Je(o)},leaveRoom:F,kickUser:Ne,getVerificationCode:me,verifyUser:(o,a)=>G(null,null,function*(){if(N!==E||!a)return!1;let u=me(o,a.length);return!u||!a||u!==a||(Re.set(o,!0),!V.get(o))?!1:(v({type:Se,privateData:_e},{receiver:o}),!0)})}};et(["roupn"],{createClientConnector:Nt});})();
