(()=>{var tx=(x,Z)=>{let W=window;for(let X=0;X<x.length-1;X++){if(typeof W[x[X]]!=="object"||!Array.isArray(W[x[X]]))W[x[X]]={};W=W[x[X]]}W[x[x.length-1]]=Z};var Ux="CONNECTED",Bx="CONNECTING",f="DISCONNECTED",Lx="DISCONNECTING",sx="PENDING_VERIFICATION";var Mx="_X0",zx="_X1",Px="_X2",Hx="_X3",hx="_X4",ax="_RC",rx="_RJ";var ex="_UJ",x0="_UK",q0="_UL",Dx="_UV";var Ox="ABCDEFGHKMNPQRSTUVWXYZ23456789";var k=(x)=>{let Z=atob(x);return Uint8Array.from(Z,(W)=>W.charCodeAt(0)).buffer},$0=(x)=>{let Z=atob(x),W=Uint8Array.from(Z,(X)=>X.charCodeAt(0));return new TextDecoder().decode(W)},Q0=(x)=>{let Z=new TextEncoder().encode(x);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let W="",X=65536;for(let z=0;z<Z.length;z+=X){let L=Z.subarray(z,z+X);W+=String.fromCharCode(...L)}return btoa(W)},G=(x)=>{let Z=new Uint8Array(x);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let W="",X=65536;for(let z=0;z<Z.length;z+=X){let L=Z.subarray(z,z+X);W+=String.fromCharCode(...L)}return btoa(W)};var O=()=>{let x=new Map;return{addListener:(Z,W)=>{if(!x.has(Z))x.set(Z,W)},removeListener:(Z)=>{x.delete(Z)},dispatch:(Z)=>{for(let[W,X]of x.entries())if(W(Z),X&&X.once)x.delete(W)}}};var W0=(x,Z)=>{let W=[];for(let X in x){let z=x[X];if(z!==null&&z!==void 0)W.push(X+":"+Z(String(z)))}return W.join("|")},Z0=(x,Z)=>{let W={},X=x.split("|");for(let z of X){let L=z.indexOf(":");if(L>0){let Fx=z.substring(0,L),wx=z.substring(L+1);W[Fx]=Z(wx)}}return W};var J0=(x,Z)=>{let W=Date.now();if(!x)return{delay:0,offset:0,adjusted:W};if(!Z){let L=x-W;return{delay:0,offset:L,adjusted:W+L}}let X=W-Z,z=(x-Z+(x-W))/2;return{delay:X,offset:z,adjusted:W-X+z}};var t="ECDH",Cx="P-256",s="raw",E="SHA-256",a="spki",C="AES-GCM",Ax=256,r="RSA-OAEP",p="RSASSA-PKCS1-v1_5",X0="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([x,Z,W])=>{Promise.all([crypto.subtle.exportKey("spki",x.publicKey),crypto.subtle.exportKey("spki",Z.publicKey)]).then(([X,z])=>{self.postMessage({success:!0,myEncryptKeys:x,mySignKeys:Z,myExchangeKeys:W,myPublicEncryptKey:X,myPublicSignKey:z})}).catch((X)=>{self.postMessage({success:!1,error:X.message})})}).catch((x)=>{self.postMessage({success:!1,error:x.message})})}).toString()+")",j0="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then((x)=>{self.postMessage({success:!0,sharedKey:x})}).catch((x)=>{self.postMessage({success:!1,error:x.message})})}).toString()+")";var Nx="S",z0="T",vx="E",mx="I",bx="U",Sx="D",Kx="V",px="K",gx="P",lx="G";var F0=(x={})=>{let{contentType:Z="application/json",deserializeMessage:W=JSON.parse,serializeMessage:X=JSON.stringify,createRoomEndpoint:z="/create-room",joinRoomEndpoint:L="/join-room",httpUrl:Fx="http://localhost:3000",wsUrl:wx="http://localhost:3000",messageBufferMaxCount:w0=50,messageBufferMaxDuration:Y0=60000}=x,v=f,Y,m,c,Yx,R,U,e,xx,qx,Vx,y,A,g,$x,b,h=[],D,T=new Map,d=new Map,_=new Map,Qx=new Map,kx=new Map,l=()=>{if(!m&&!c)c=new Promise((q,J)=>{let F=new Worker(URL.createObjectURL(new Blob([X0],{type:"text/javascript"})));F.addEventListener("message",($)=>{if($.data.success)Yx=$.data.myEncryptKeys,qx=$.data.mySignKeys,R=$.data.myExchangeKeys,e=$.data.myPublicEncryptKey,xx=$.data.myPublicSignKey,m=!0,c=null,q();else{let V=Error($.data.error);w.dispatch({error:V}),J(V)}F.terminate()}),F.addEventListener("error",($)=>{w.dispatch({error:$}),J($),F.terminate()}),F.postMessage({type:"USER_KEYS"})});return c};l();let w=O(),fx=O(),Rx=O(),Tx=O(),ux=O(),Ix=O(),Wx=O(),Ex=O(),cx=O(),S=(q)=>{if(v!==q)v=q,cx.dispatch({state:q})},yx=async(q)=>{let J=T.get(q);if(!J)return;Qx.set(q,Array.from(new Uint8Array(await crypto.subtle.digest(E,new TextEncoder().encode($x+G(await crypto.subtle.exportKey("raw",J))))))),Ex.dispatch({userId:q,code:Gx(q)})},u=()=>{if(v===f||v===Lx)return;if(S(Lx),D)D.close();Y=m=c=U=Yx=R=e=xx=qx=Vx=y=A=g=b=h=D=null,T.clear(),d.clear(),_.clear(),Qx.clear(),kx.clear(),l(),S(f)},Zx=(q)=>Jx({type:x0,userId:q}),dx=(q,J=null)=>{if(!J&&v&&v!==f)return;S(Bx),$x=q;let F=new URL(wx+L);if(F.searchParams.append("code",$x),J)F.searchParams.append("creator",J);D=new WebSocket(F.toString()),D.addEventListener("close",($)=>{Tx.dispatch({event:$}),u()}),D.addEventListener("error",($)=>{w.dispatch({event:$}),u()}),D.addEventListener("message",async($)=>{_x(Z0($.data,$0),$.data)})},_x=async(q,J,F=!1)=>{let{[Nx]:$,[z0]:V,[mx]:B,[vx]:M,[Sx]:P,[Kx]:n,[px]:nx,[gx]:ix,[lx]:ox,[bx]:i}=q,Q,o,Xx,I;if($)Xx=$;else if(P)Xx=P;else Xx=J;if(M){if(!b||!F&&h.length>0){if(h.push({time:Date.now(),parts:q,raw:J}),h.length>w0)h.shift();return}if(!B){w.dispatch(Error("Missing IV to decrypt message"));return}Q=await crypto.subtle.decrypt({iv:k(B),name:C},b,k(M)),Q=new TextDecoder().decode(Q),I=!0}else if(ix){if(!nx||!n){w.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!m)await l();let j=k(ix),H=W(new TextDecoder().decode(await crypto.subtle.decrypt({iv:k(n),name:C},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:r},Yx.privateKey,k(nx)),{name:C},!0,["encrypt","decrypt"]),j)));if(I=!0,H.type===zx)o=H;else if(ox){let N=H.sender;if(!N){w.dispatch({error:Error("Message from unknown sender")});return}let jx=_.get(N);if(!jx){w.dispatch({error:Error("No public key for "+N)});return}if(!await crypto.subtle.verify(p,jx,k(ox),j)){w.dispatch({error:Error("Invalid signature from "+N)});return}o=H}else{w.dispatch({error:Error("Missing encryption signature")});return}}else Q=Xx;if(!o)try{o=W(Q)}catch(j){w.dispatch({error:Error("Failed to parse message "+J)});return}switch(Q=o,Q.type){case rx:if(Y=Q.creatorId,U=Q.userId,Rx.dispatch({creatorId:Q.creatorId,roomCode:$x,userId:Q.userId,users:Q.users}),U===Y)S(Ux);else{if(S(sx),!m)await l();let j=await crypto.subtle.exportKey(s,R.publicKey);K({type:Mx,publicData:typeof A==="function"?A():A,publicEncryptKey:G(e),publicExchangeKey:G(j),publicSignKey:G(xx),signature:G(await crypto.subtle.sign(p,qx.privateKey,j))},{allowUnencrypted:!0,receiver:Y})}break;case Mx:if(i===Y&&U===Y){let j=Q.sender;if(g&&!g({data:Q.publicData,userId:j})){Zx(j);return}d.set(j,await crypto.subtle.importKey(a,k(Q.publicEncryptKey),{hash:E,name:r},!0,["encrypt"]));let H=await crypto.subtle.importKey(a,k(Q.publicSignKey),{hash:E,name:p},!0,["verify"]),N=k(Q.publicExchangeKey);if(!await crypto.subtle.verify(p,H,k(Q.signature),N)){w.dispatch({error:Error("Invalid signature for exchange from "+j)});return}if(_.set(j,H),!m)await l();T.set(j,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,N,{name:t,namedCurve:Cx},!0,[])},R.privateKey,{length:Ax,name:C},!0,["encrypt","decrypt"]));let jx=await crypto.subtle.exportKey(s,R.publicKey);K({type:zx,publicData:typeof A==="function"?A():A,publicEncryptKey:G(e),publicExchangeKey:G(jx),publicSignKey:G(xx)},{receiver:j}),yx(j)}break;case zx:if(i===U&&Q.sender===Y){if(g&&!g({data:Q.publicData,userId:Y})){u();return}let j=await crypto.subtle.importKey(a,k(Q.publicSignKey),{hash:E,name:p},!0,["verify"]);if(Q.publicExchangeKey&&Q.signature){if(!await crypto.subtle.verify(p,j,k(Q.signature),k(Q.publicExchangeKey))){w.dispatch({error:Error("Invalid signature for exchange from "+Y)}),u();return}}if(_.set(Y,j),d.set(Y,await crypto.subtle.importKey(a,k(Q.publicEncryptKey),{hash:E,name:r},!0,["encrypt"])),!m)await l();T.set(Y,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,k(Q.publicExchangeKey),{name:t,namedCurve:Cx},!0,[])},R.privateKey,{length:Ax,name:C},!0,["encrypt","decrypt"])),yx(Y)}break;case Px:if(i===U&&Q.sender===Y){if(!I){w.dispatch({error:Error("Message was not encrypted")});return}if(y&&!y({data:Q.privateData,userId:Y})){u();return}K({type:Hx,privateData:Vx},{receiver:Y})}break;case Hx:if(i===Y&&U===Y){if(!I){w.dispatch({error:Error("Message was not encrypted")});return}let j=Q.sender;if(!kx.get(j)){w.dispatch({error:Error("User not verified")}),Zx(j);return}if(y&&!y({data:Q.privateData,userId:j})){Zx(j);return}K({type:hx,sharedKey:G(await crypto.subtle.exportKey("raw",b))},{receiver:j}),Wx.dispatch({userId:j}),Jx({type:Dx,userId:j})}break;case hx:if(i===U&&Q.sender===Y){if(!I){w.dispatch({error:Error("Message was not encrypted")});return}if(b=await crypto.subtle.importKey("raw",k(Q.sharedKey),{name:C},!0,["encrypt","decrypt"]),Wx.dispatch({userId:U}),h.length>0){let j=Date.now();h=h.filter((H)=>j-H.time<Y0);while(h.length>0){let{parts:H,raw:N}=h.shift();_x(H,N,!0)}}S(Ux)}break;case q0:Ix.dispatch({userId:Q.userId}),T.delete(Q.userId),d.delete(Q.userId),_.delete(Q.userId);break;case ex:ux.dispatch({userId:Q.userId});break;case Dx:Wx.dispatch({userId:Q.userId});break;default:if(!I){w.dispatch({error:Error("Message was not encrypted")});return}fx.dispatch({data:Q,time:J0(V,Q?.senderTime)});break}},K=async(q,J={})=>{if(!D||D.readyState!==WebSocket.OPEN)return w.dispatch({error:Error("No open socket")}),!1;let F=X({...q,sender:U,senderTime:Date.now()}),$={},V=J.receiver;if(V){let B=d.get(V);if(B){let M=await crypto.subtle.generateKey({name:C,length:256},!0,["encrypt","decrypt"]),P=crypto.getRandomValues(new Uint8Array(12)),n=await crypto.subtle.encrypt({iv:P,name:C},M,new TextEncoder().encode(F));if(!m)await l();$[Kx]=G(P),$[px]=G(await crypto.subtle.encrypt({name:r},B,await crypto.subtle.exportKey("raw",M))),$[gx]=G(n),$[lx]=G(await crypto.subtle.sign(p,qx.privateKey,n))}else if(!J.allowUnencrypted)return w.dispatch({error:Error("No public key for "+V)}),!1;else $[Sx]=F;$[bx]=V}else if(J.server)$[Nx]=F;else if(b){let B=crypto.getRandomValues(new Uint8Array(12));$[mx]=G(B),$[vx]=G(await crypto.subtle.encrypt({iv:B,name:C},b,new TextEncoder().encode(F)))}else return w.dispatch(Error("Trying to send without valid destination")),!1;return D.send(W0($,Q0)),!0},Jx=(q)=>U&&U===Y&&K(q,{server:!0}),V0=(q,J)=>J&&K(q,{receiver:J}),Gx=(q,J=6)=>{if(!Qx.has(q))return!1;let F=Qx.get(q),$="";for(let V=0;V<J;V++){let B=F[V]%Ox.length;$+=Ox[B]}return $};return{onConnection:cx,onError:w,onMessage:fx,onRoomJoin:Rx,onRoomLeave:Tx,onUserJoin:ux,onUserLeave:Ix,onUserVerified:Wx,onUserVerificationCode:Ex,messageRoom:(q)=>K(q),messageServer:Jx,messageUser:V0,closeRoom:()=>Jx({type:ax}),createRoom:async(q={})=>{if(v&&v!==f)return;if(S(Bx),q.publicData)A=q.publicData;if(q.verifyPublicData)g=q.verifyPublicData;try{await new Promise((V,B)=>{let M=new Worker(URL.createObjectURL(new Blob([j0],{type:"text/javascript"})));M.addEventListener("message",(P)=>{if(P.data.success)b=P.data.sharedKey,V();else B(Error(P.data.error));M.terminate()}),M.addEventListener("error",(P)=>{B(P),M.terminate()}),M.postMessage({type:"SHARED_KEY"})})}catch(V){S(f),w.dispatch({error:V});return}let J=new URL(Fx+z);if(q.limit)J.searchParams.append("limit",q.limit);let F=await fetch(J.toString(),{method:"GET",headers:{Accept:Z}});if(!F.ok)throw Error("Failed to create room");let $=await F.text();return $=W($),U=$.userId,dx($.roomCode,$.creatorSecret),$},joinRoom:(q,J={})=>{if(J.publicData)A=J.publicData;if(J.verifyPublicData)g=J.verifyPublicData;dx(q)},leaveRoom:u,kickUser:Zx,getVerificationCode:Gx,verifyUser:async(q,J)=>{if(U!==Y||!J)return!1;let F=Gx(q,J.length);if(!F||!J||F!==J)return!1;if(kx.set(q,!0),!T.get(q))return!1;return K({type:Px,privateData:Vx},{receiver:q}),!0}}};tx(["roupn"],{createClientConnector:F0});})();

//# debugId=0C97E61AB3F21FD064756E2164756E21
