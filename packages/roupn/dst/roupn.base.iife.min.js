(()=>{var tx=(x,Z)=>{let W=window;for(let z=0;z<x.length-1;z++){if(typeof W[x[z]]!=="object"||!Array.isArray(W[x[z]]))W[x[z]]={};W=W[x[z]]}W[x[x.length-1]]=Z};var Ux="CONNECTED",Bx="CONNECTING",l="DISCONNECTED",Gx="DISCONNECTING",sx="PENDING_VERIFICATION";var bx="_X0",jx="_X1",Lx="_X2",Mx="_X3",Px="_X4",ax="_RC",rx="_RJ";var ex="_UJ",x6="_UK",q6="_UL",Hx="_UV";var Cx="ABCDEFGHKMNPQRSTUVWXYZ23456789";var k=(x)=>{let Z=atob(x);return Uint8Array.from(Z,(W)=>W.charCodeAt(0)).buffer},$6=(x)=>{let Z=atob(x),W=Uint8Array.from(Z,(z)=>z.charCodeAt(0));return new TextDecoder().decode(W)},Q6=(x)=>{let Z=new TextEncoder().encode(x);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let W="",z=65536;for(let j=0;j<Z.length;j+=z){let G=Z.subarray(j,j+z);W+=String.fromCharCode(...G)}return btoa(W)},h=(x)=>{let Z=new Uint8Array(x);if(Z.length<65536)return btoa(String.fromCharCode(...Z));let W="",z=65536;for(let j=0;j<Z.length;j+=z){let G=Z.subarray(j,j+z);W+=String.fromCharCode(...G)}return btoa(W)};var C=()=>{let x=new Map;return{addListener:(Z,W)=>{if(!x.has(Z))x.set(Z,W)},removeListener:(Z)=>{x.delete(Z)},dispatch:(Z)=>{for(let[W,z]of x.entries())if(W(Z),z&&z.once)x.delete(W)}}};var W6=(x,Z)=>{let W=[];for(let z in x){let j=x[z];if(j!==null&&j!==void 0)W.push(z+":"+Z(String(j)))}return W.join("|")},Z6=(x,Z)=>{let W={},z=x.split("|");for(let j of z){let G=j.indexOf(":");if(G>0){let wx=j.substring(0,G),Fx=j.substring(G+1);W[wx]=Z(Fx)}}return W};var J6=(x,Z)=>{let W=Date.now();if(!x)return{delay:0,offset:0,adjusted:W};if(!Z){let G=x-W;return{delay:0,offset:G,adjusted:W+G}}let z=W-Z,j=(x-Z+(x-W))/2;return{delay:z,offset:j,adjusted:W-z+j}};var t="ECDH",Dx="P-256",s="raw",c="SHA-256",a="spki",D="AES-GCM",fx=256,r="RSA-OAEP",N="RSASSA-PKCS1-v1_5",z6="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([x,Z,W])=>{Promise.all([crypto.subtle.exportKey("spki",x.publicKey),crypto.subtle.exportKey("spki",Z.publicKey)]).then(([z,j])=>{self.postMessage({success:!0,myEncryptKeys:x,mySignKeys:Z,myExchangeKeys:W,myPublicEncryptKey:z,myPublicSignKey:j})}).catch((z)=>{self.postMessage({success:!1,error:z.message})})}).catch((x)=>{self.postMessage({success:!1,error:x.message})})}).toString()+")",X6="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then((x)=>{self.postMessage({success:!0,sharedKey:x})}).catch((x)=>{self.postMessage({success:!1,error:x.message})})}).toString()+")";var Ox="S",j6="T",Ax="E",gx="I",vx="U",Sx="D",mx="V",Nx="K",px="P",Kx="G";var w6=(x={})=>{let{contentType:Z="application/json",deserializeMessage:W=JSON.parse,serializeMessage:z=JSON.stringify,createRoomEndpoint:j="/create-room",joinRoomEndpoint:G="/join-room",httpUrl:wx="http://localhost:3000",wsUrl:Fx="http://localhost:3000",messageBufferMaxCount:F6=50,messageBufferMaxDuration:Y6=60000}=x,A=l,Y,g,E,Yx,T,U,e,xx,qx,Vx,y,f,p,$x,v,P=[],H,R=new Map,n=new Map,d=new Map,Qx=new Map,kx=new Map,K=()=>{if(!g&&!E)E=new Promise((q,J)=>{let w=new Worker(URL.createObjectURL(new Blob([z6],{type:"text/javascript"})));w.addEventListener("message",($)=>{if($.data.success)Yx=$.data.myEncryptKeys,qx=$.data.mySignKeys,T=$.data.myExchangeKeys,e=$.data.myPublicEncryptKey,xx=$.data.myPublicSignKey,g=!0,E=null,q();else{let V=Error($.data.error);F.dispatch({error:V}),J(V)}w.terminate()}),w.addEventListener("error",($)=>{F.dispatch({error:$}),J($),w.terminate()}),w.postMessage({type:"USER_KEYS"})});return E};K();let F=C(),lx=C(),Tx=C(),Rx=C(),ux=C(),Ix=C(),Wx=C(),cx=C(),Ex=C(),S=(q)=>{if(A!==q)A=q,Ex.dispatch({state:q})},yx=async(q)=>{let J=R.get(q);if(!J)return;Qx.set(q,Array.from(new Uint8Array(await crypto.subtle.digest(c,new TextEncoder().encode($x+h(await crypto.subtle.exportKey("raw",J))))))),cx.dispatch({userId:q,code:hx(q)})},u=()=>{if(A===l||A===Gx)return;if(S(Gx),H)H.close();Y=g=E=U=Yx=T=e=xx=qx=Vx=y=f=p=v=P=H=null,R.clear(),n.clear(),d.clear(),Qx.clear(),kx.clear(),K(),S(l)},Zx=(q)=>Jx({type:x6,userId:q}),nx=(q,J=null)=>{if(!J&&A&&A!==l)return;S(Bx),$x=q;let w=new URL(Fx+G);if(w.searchParams.append("code",$x),J)w.searchParams.append("creator",J);H=new WebSocket(w.toString()),H.addEventListener("close",($)=>{Rx.dispatch({event:$}),u()}),H.addEventListener("error",($)=>{F.dispatch({event:$}),u()}),H.addEventListener("message",async($)=>{dx(Z6($.data,$6),$.data)})},dx=async(q,J,w=!1)=>{let{[Ox]:$,[j6]:V,[gx]:B,[Ax]:b,[Sx]:L,[mx]:i,[Nx]:ix,[px]:ox,[Kx]:_x,[vx]:o}=q,Q,_,zx,I;if($)zx=$;else if(L)zx=L;else zx=J;if(b){if(!v||!w&&P.length>0){if(P.push({time:Date.now(),parts:q,raw:J}),P.length>F6)P.shift();return}if(!B){F.dispatch(Error("Missing IV to decrypt message"));return}Q=await crypto.subtle.decrypt({iv:k(B),name:D},v,k(b)),Q=new TextDecoder().decode(Q),I=!0}else if(ox){if(!ix||!i){F.dispatch({error:Error("Missing signature or IV to decrypt message.")});return}if(!g)await K();let X=k(ox),M=W(new TextDecoder().decode(await crypto.subtle.decrypt({iv:k(i),name:D},await crypto.subtle.importKey("raw",await crypto.subtle.decrypt({name:r},Yx.privateKey,k(ix)),{name:D},!0,["encrypt","decrypt"]),X)));if(I=!0,M.type===jx)_=M;else if(_x){let O=M.sender;if(!O){F.dispatch({error:Error("Message from unknown sender")});return}let Xx=d.get(O);if(!Xx){F.dispatch({error:Error("No public key for "+O)});return}if(!await crypto.subtle.verify(N,Xx,k(_x),X)){F.dispatch({error:Error("Invalid signature from "+O)});return}_=M}else{F.dispatch({error:Error("Missing encryption signature")});return}}else Q=zx;if(!_)try{_=W(Q)}catch(X){F.dispatch({error:Error("Failed to parse message "+J)});return}switch(Q=_,Q.type){case rx:if(Y=Q.creatorId,U=Q.userId,Tx.dispatch({creatorId:Q.creatorId,roomCode:$x,userId:Q.userId,users:Q.users}),U===Y)S(Ux);else{if(S(sx),!g)await K();let X=await crypto.subtle.exportKey(s,T.publicKey);m({type:bx,publicData:typeof f==="function"?f():f,publicEncryptKey:h(e),publicExchangeKey:h(X),publicSignKey:h(xx),signature:h(await crypto.subtle.sign(N,qx.privateKey,X))},{allowUnencrypted:!0,receiver:Y})}break;case bx:if(o===Y&&U===Y){let X=Q.sender;if(p&&!p({data:Q.publicData,userId:X})){Zx(X);return}n.set(X,await crypto.subtle.importKey(a,k(Q.publicEncryptKey),{hash:c,name:r},!0,["encrypt"]));let M=await crypto.subtle.importKey(a,k(Q.publicSignKey),{hash:c,name:N},!0,["verify"]),O=k(Q.publicExchangeKey);if(!await crypto.subtle.verify(N,M,k(Q.signature),O)){F.dispatch({error:Error("Invalid signature for exchange from "+X)});return}if(d.set(X,M),!g)await K();R.set(X,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,O,{name:t,namedCurve:Dx},!0,[])},T.privateKey,{length:fx,name:D},!0,["encrypt","decrypt"]));let Xx=await crypto.subtle.exportKey(s,T.publicKey);m({type:jx,publicData:typeof f==="function"?f():f,publicEncryptKey:h(e),publicExchangeKey:h(Xx),publicSignKey:h(xx)},{receiver:X}),yx(X)}break;case jx:if(o===U&&Q.sender===Y){if(p&&!p({data:Q.publicData,userId:Y})){u();return}let X=await crypto.subtle.importKey(a,k(Q.publicSignKey),{hash:c,name:N},!0,["verify"]);if(Q.publicExchangeKey&&Q.signature){if(!await crypto.subtle.verify(N,X,k(Q.signature),k(Q.publicExchangeKey))){F.dispatch({error:Error("Invalid signature for exchange from "+Y)}),u();return}}if(d.set(Y,X),n.set(Y,await crypto.subtle.importKey(a,k(Q.publicEncryptKey),{hash:c,name:r},!0,["encrypt"])),!g)await K();R.set(Y,await crypto.subtle.deriveKey({name:t,public:await crypto.subtle.importKey(s,k(Q.publicExchangeKey),{name:t,namedCurve:Dx},!0,[])},T.privateKey,{length:fx,name:D},!0,["encrypt","decrypt"])),yx(Y)}break;case Lx:if(o===U&&Q.sender===Y){if(!I){F.dispatch({error:Error("Message was not encrypted")});return}if(y&&!y({data:Q.privateData,userId:Y})){u();return}m({type:Mx,privateData:Vx},{receiver:Y})}break;case Mx:if(o===Y&&U===Y){if(!I){F.dispatch({error:Error("Message was not encrypted")});return}let X=Q.sender;if(!kx.get(X)){F.dispatch({error:Error("User not verified")}),Zx(X);return}if(y&&!y({data:Q.privateData,userId:X})){Zx(X);return}m({type:Px,sharedKey:h(await crypto.subtle.exportKey("raw",v))},{receiver:X}),Wx.dispatch({userId:X}),Jx({type:Hx,userId:X})}break;case Px:if(o===U&&Q.sender===Y){if(!I){F.dispatch({error:Error("Message was not encrypted")});return}if(v=await crypto.subtle.importKey("raw",k(Q.sharedKey),{name:D},!0,["encrypt","decrypt"]),Wx.dispatch({userId:U}),P.length>0){let X=Date.now();P=P.filter((M)=>X-M.time<Y6);while(P.length>0){let{parts:M,raw:O}=P.shift();dx(M,O,!0)}}S(Ux)}break;case q6:Ix.dispatch({userId:Q.userId}),R.delete(Q.userId),n.delete(Q.userId),d.delete(Q.userId);break;case ex:ux.dispatch({userId:Q.userId});break;case Hx:Wx.dispatch({userId:Q.userId});break;default:if(!I){F.dispatch({error:Error("Message was not encrypted")});return}lx.dispatch({data:Q,time:J6(V,Q?.senderTime)});break}},m=async(q,J={})=>{if(!H||H.readyState!==WebSocket.OPEN)return F.dispatch({error:Error("No open socket")}),!1;let w=z({...q,sender:U,senderTime:Date.now()}),$={},V=J.receiver;if(V){let B=n.get(V);if(B){let b=await crypto.subtle.generateKey({name:D,length:256},!0,["encrypt","decrypt"]),L=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.encrypt({iv:L,name:D},b,new TextEncoder().encode(w));if(!g)await K();$[mx]=h(L),$[Nx]=h(await crypto.subtle.encrypt({name:r},B,await crypto.subtle.exportKey("raw",b))),$[px]=h(i),$[Kx]=h(await crypto.subtle.sign(N,qx.privateKey,i))}else if(!J.allowUnencrypted)return F.dispatch({error:Error("No public key for "+V)}),!1;else $[Sx]=w;$[vx]=V}else if(J.server)$[Ox]=w;else if(v){let B=crypto.getRandomValues(new Uint8Array(12));$[gx]=h(B),$[Ax]=h(await crypto.subtle.encrypt({iv:B,name:D},v,new TextEncoder().encode(w)))}else return F.dispatch(Error("Trying to send without valid destination")),!1;return H.send(W6($,Q6)),!0},Jx=(q)=>U&&U===Y&&m(q,{server:!0}),V6=(q,J)=>J&&m(q,{receiver:J}),hx=(q,J=6)=>{if(!Qx.has(q))return!1;let w=Qx.get(q),$="";for(let V=0;V<J;V++){let B=w[V]%Cx.length;$+=Cx[B]}return $};return{onConnection:Ex,onError:F,onMessage:lx,onRoomJoin:Tx,onRoomLeave:Rx,onUserJoin:ux,onUserLeave:Ix,onUserVerified:Wx,onUserVerificationCode:cx,messageRoom:(q)=>m(q),messageServer:Jx,messageUser:V6,closeRoom:()=>Jx({type:ax}),createRoom:async(q={})=>{if(A&&A!==l)return;if(S(Bx),q.publicData)f=q.publicData;if(q.verifyPublicData)p=q.verifyPublicData;try{await new Promise((V,B)=>{let b=new Worker(URL.createObjectURL(new Blob([X6],{type:"text/javascript"})));b.addEventListener("message",(L)=>{if(L.data.success)v=L.data.sharedKey,V();else B(Error(L.data.error));b.terminate()}),b.addEventListener("error",(L)=>{B(L),b.terminate()}),b.postMessage({type:"SHARED_KEY"})})}catch(V){S(l),F.dispatch({error:V});return}let J=new URL(wx+j);if(q.limit)J.searchParams.append("limit",q.limit);let w=await fetch(J.toString(),{method:"GET",headers:{Accept:Z}});if(!w.ok)throw Error("Failed to create room");let $=await w.text();return $=W($),U=$.userId,nx($.roomCode,$.creatorSecret),$},joinRoom:(q,J={})=>{if(J.publicData)f=J.publicData;if(J.verifyPublicData)p=J.verifyPublicData;nx(q)},leaveRoom:u,kickUser:Zx,getVerificationCode:hx,verifyUser:async(q,J)=>{if(U!==Y||!J)return!1;let w=hx(q,J.length);if(!w||!J||w!==J)return!1;if(kx.set(q,!0),!R.get(q))return!1;return m({type:Lx,privateData:Vx},{receiver:q}),!0}}};tx(["roupn"],{createClientConnector:w6});})();

//# debugId=5AFAEC92D3B09C9D64756E2164756E21
