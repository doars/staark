(()=>{var dt=Object.defineProperty,lt=Object.defineProperties;var ft=Object.getOwnPropertyDescriptors;var Le=Object.getOwnPropertySymbols;var _t=Object.prototype.hasOwnProperty,Rt=Object.prototype.propertyIsEnumerable;var He=(t,r,e)=>r in t?dt(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,Ge=(t,r)=>{for(var e in r||(r={}))_t.call(r,e)&&He(t,e,r[e]);if(Le)for(var e of Le(r))Rt.call(r,e)&&He(t,e,r[e]);return t},Ye=(t,r)=>lt(t,ft(r));var G=(t,r,e)=>new Promise((s,i)=>{var R=w=>{try{v(e.next(w))}catch(J){i(J)}},j=w=>{try{v(e.throw(w))}catch(J){i(J)}},v=w=>w.done?s(w.value):Promise.resolve(w.value).then(R,j);v((e=e.apply(t,r)).next())});var ke=(t,r)=>{let e=window;for(let s=0;s<t.length-1;s++)(typeof e[t[s]]!="object"||!Array.isArray(e[t[s]]))&&(e[t[s]]={}),e=e[t[s]];e[t[t.length-1]]=r};var Ie="CONNECTED",ge="CONNECTING",Y="DISCONNECTED",Ce="DISCONNECTING",Fe="PENDING_VERIFICATION";var be="ABCDEFGHKMNPQRSTUVWXYZ23456789";var f=t=>{let r=atob(t);return Uint8Array.from(r,e=>e.charCodeAt(0)).buffer},Ve=t=>{let r=atob(t),e=Uint8Array.from(r,s=>s.charCodeAt(0));return new TextDecoder().decode(e)},Xe=t=>{let r=new TextEncoder().encode(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let i=0;i<r.length;i+=s){let R=r.subarray(i,i+s);e+=String.fromCharCode(...R)}return btoa(e)},_=t=>{let r=new Uint8Array(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let i=0;i<r.length;i+=s){let R=r.subarray(i,i+s);e+=String.fromCharCode(...R)}return btoa(e)};var S=()=>{let t=new Map;return{addListener:(r,e)=>{t.has(r)||t.set(r,e)},removeListener:r=>{t.delete(r)},dispatch:r=>{for(let[e,s]of t.entries())e(r),s&&s.once&&t.delete(e)}}};var Be=(t,r)=>{let e=[];for(let s in t){let i=t[s];i!=null&&e.push(s+":"+r(String(i)))}return e.join("|")},je=(t,r)=>{let e={},s=t.split("|");for(let i of s){let R=i.indexOf(":");if(R>0){let j=i.substring(0,R),v=i.substring(R+1);e[j]=r(v)}}return e};var Je=(t,r)=>{let e=Date.now();if(!t)return{delay:0,offset:0,adjusted:e};if(!r){let R=t-e;return{delay:0,offset:R,adjusted:e+R}}let s=e-r,i=(t-r+(t-e))/2;return{delay:s,offset:i,adjusted:e-s+i}};var re="ECDH",he="P-256";var B="SHA-256",ne="spki",A="AES-GCM";var oe="RSA-OAEP",M="RSASSA-PKCS1-v1_5",ze="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,r,e])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",r.publicKey)]).then(([s,i])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:r,myExchangeKeys:e,myPublicEncryptKey:s,myPublicSignKey:i})}).catch(s=>{self.postMessage({success:!1,error:s.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",We="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var yt=(t={})=>{let{contentType:r="application/json",deserializeMessage:e=JSON.parse,serializeMessage:s=JSON.stringify,createRoomEndpoint:i="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:j="http://localhost:3000",wsUrl:v="http://localhost:3000",messageBufferMaxCount:w=50,messageBufferMaxDuration:J=60*1e3}=t,K=Y,y,x,z,_e,k,N,se,ae,ce,Re,W,T,L,ie,D,C=[],b,F=new Map,Q=new Map,Z=new Map,pe=new Map,Ne=new Map,H=()=>(!x&&!z&&(z=new Promise((o,a)=>{let d=new Worker(URL.createObjectURL(new Blob([ze],{type:"text/javascript"})));d.addEventListener("message",p=>{if(p.data.success)_e=p.data.myEncryptKeys,ce=p.data.mySignKeys,k=p.data.myExchangeKeys,se=p.data.myPublicEncryptKey,ae=p.data.myPublicSignKey,x=!0,z=null,o();else{let u=new Error(p.data.error);E.dispatch({error:u}),a(u)}d.terminate()}),d.addEventListener("error",p=>{E.dispatch({error:p}),a(p),d.terminate()}),d.postMessage({type:"USER_KEYS"})})),z);H();let E=S(),Ae=S(),we=S(),Te=S(),Oe=S(),Ke=S(),Ee=S(),xe=S(),De=S(),P=o=>{K!==o&&(K=o,De.dispatch({state:o}))},Pe=o=>G(null,null,function*(){let a=F.get(o);a&&(pe.set(o,Array.from(new Uint8Array(yield crypto.subtle.digest(B,new TextEncoder().encode(ie+_(yield crypto.subtle.exportKey("raw",a))))))),xe.dispatch({userId:o,code:me(o)}))}),V=()=>{K===Y||K===Ce||(P(Ce),b&&b.close(),y=x=z=N=_e=k=se=ae=ce=Re=W=T=L=D=C=b=null,F.clear(),Q.clear(),Z.clear(),pe.clear(),Ne.clear(),H(),P(Y))},ye=o=>ue({type:"_UK",userId:o}),Ue=(o,a=null)=>{if(!a&&K&&K!==Y)return;P(ge),ie=o;let d=new URL(v+R);d.searchParams.append("code",ie),a&&d.searchParams.append("creator",a),b=new WebSocket(d.toString()),b.addEventListener("close",p=>{Te.dispatch({event:p}),V()}),b.addEventListener("error",p=>{E.dispatch({event:p}),V()}),b.addEventListener("message",p=>G(null,null,function*(){Me(je(p.data,Ve),p.data)}))},Me=(o,a,d=!1)=>G(null,null,function*(){let{["S"]:p,["T"]:u,["I"]:l,["E"]:h,["D"]:m,["V"]:I,["K"]:q,["P"]:$,["G"]:ve,["U"]:ee}=o,n,te,de,X;if(p?de=p:m?de=m:de=a,h){if(!D||!d&&C.length>0){C.push({time:Date.now(),parts:o,raw:a}),C.length>w&&C.shift();return}if(!l){E.dispatch(new Error("Missing IV to decrypt message"));return}n=yield crypto.subtle.decrypt({iv:f(l),name:A},D,f(h)),n=new TextDecoder().decode(n),X=!0}else if($){if(!q||!I){E.dispatch({error:new Error("Missing signature or IV to decrypt message.")});return}x||(yield H());let c=f($),g=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:f(I),name:A},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:oe},_e.privateKey,f(q)),{name:A},!0,["encrypt","decrypt"]),c)));if(X=!0,g.type==="_X1")te=g;else if(ve){let O=g.sender;if(!O){E.dispatch({error:new Error("Message from unknown sender")});return}let le=Z.get(O);if(!le){E.dispatch({error:new Error("No public key for "+O)});return}if(!(yield crypto.subtle.verify(M,le,f(ve),c))){E.dispatch({error:new Error("Invalid signature from "+O)});return}te=g}else{E.dispatch({error:new Error("Missing encryption signature")});return}}else n=de;if(!te)try{te=e(n)}catch(c){E.dispatch({error:new Error("Failed to parse message "+a)});return}switch(n=te,n.type){case"_RJ":if(y=n.creatorId,N=n.userId,we.dispatch({creatorId:n.creatorId,roomCode:ie,userId:n.userId,users:n.users}),N===y)P(Ie);else{P(Fe),x||(yield H());let c=yield crypto.subtle.exportKey("raw",k.publicKey);U({type:"_X0",publicData:typeof T=="function"?T():T,publicEncryptKey:_(se),publicExchangeKey:_(c),publicSignKey:_(ae),signature:_(yield crypto.subtle.sign(M,ce.privateKey,c))},{allowUnencrypted:!0,receiver:y})}break;case"_X0":if(ee===y&&N===y){let c=n.sender;if(L&&!L({data:n.publicData,userId:c})){ye(c);return}Q.set(c,yield crypto.subtle.importKey(ne,f(n.publicEncryptKey),{hash:B,name:oe},!0,["encrypt"]));let g=yield crypto.subtle.importKey(ne,f(n.publicSignKey),{hash:B,name:M},!0,["verify"]),O=f(n.publicExchangeKey);if(!(yield crypto.subtle.verify(M,g,f(n.signature),O))){E.dispatch({error:new Error("Invalid signature for exchange from "+c)});return}Z.set(c,g),x||(yield H()),F.set(c,yield crypto.subtle.deriveKey({name:re,public:yield crypto.subtle.importKey("raw",O,{name:re,namedCurve:he},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"]));let le=yield crypto.subtle.exportKey("raw",k.publicKey);U({type:"_X1",publicData:typeof T=="function"?T():T,publicEncryptKey:_(se),publicExchangeKey:_(le),publicSignKey:_(ae)},{receiver:c}),Pe(c)}break;case"_X1":if(ee===N&&n.sender===y){if(L&&!L({data:n.publicData,userId:y})){V();return}let c=yield crypto.subtle.importKey(ne,f(n.publicSignKey),{hash:B,name:M},!0,["verify"]);if(n.publicExchangeKey&&n.signature&&!(yield crypto.subtle.verify(M,c,f(n.signature),f(n.publicExchangeKey)))){E.dispatch({error:new Error("Invalid signature for exchange from "+y)}),V();return}Z.set(y,c),Q.set(y,yield crypto.subtle.importKey(ne,f(n.publicEncryptKey),{hash:B,name:oe},!0,["encrypt"])),x||(yield H()),F.set(y,yield crypto.subtle.deriveKey({name:re,public:yield crypto.subtle.importKey("raw",f(n.publicExchangeKey),{name:re,namedCurve:he},!0,[])},k.privateKey,{length:256,name:A},!0,["encrypt","decrypt"])),Pe(y)}break;case"_X2":if(ee===N&&n.sender===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}if(W&&!W({data:n.privateData,userId:y})){V();return}U({type:"_X3",privateData:Re},{receiver:y})}break;case"_X3":if(ee===y&&N===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}let c=n.sender;if(!Ne.get(c)){E.dispatch({error:new Error("User not verified")}),ye(c);return}if(W&&!W({data:n.privateData,userId:c})){ye(c);return}U({type:"_X4",sharedKey:_(yield crypto.subtle.exportKey("raw",D))},{receiver:c}),Ee.dispatch({userId:c}),ue({type:"_UV",userId:c})}break;case"_X4":if(ee===N&&n.sender===y){if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}if(D=yield crypto.subtle.importKey("raw",f(n.sharedKey),{name:A},!0,["encrypt","decrypt"]),Ee.dispatch({userId:N}),C.length>0){let c=Date.now();for(C=C.filter(g=>c-g.time<J);C.length>0;){let{parts:g,raw:O}=C.shift();Me(g,O,!0)}}P(Ie)}break;case"_UL":Ke.dispatch({userId:n.userId}),F.delete(n.userId),Q.delete(n.userId),Z.delete(n.userId);break;case"_UJ":Oe.dispatch({userId:n.userId});break;case"_UV":Ee.dispatch({userId:n.userId});break;default:if(!X){E.dispatch({error:new Error("Message was not encrypted")});return}Ae.dispatch({data:n,time:Je(u,n==null?void 0:n.senderTime)});break}}),U=(d,...p)=>G(null,[d,...p],function*(o,a={}){if(!b||b.readyState!==WebSocket.OPEN)return E.dispatch({error:new Error("No open socket")}),!1;let u=s(Ye(Ge({},o),{sender:N,senderTime:Date.now()})),l={},h=a.receiver;if(h){let m=Q.get(h);if(m){let I=yield crypto.subtle.generateKey({name:A,length:256},!0,["encrypt","decrypt"]),q=crypto.getRandomValues(new Uint8Array(12)),$=yield crypto.subtle.encrypt({iv:q,name:A},I,new TextEncoder().encode(u));x||(yield H()),l["V"]=_(q),l["K"]=_(yield crypto.subtle.encrypt({name:oe},m,yield crypto.subtle.exportKey("raw",I))),l["P"]=_($),l["G"]=_(yield crypto.subtle.sign(M,ce.privateKey,$))}else if(a.allowUnencrypted)l["D"]=u;else return E.dispatch({error:new Error("No public key for "+h)}),!1;l["U"]=h}else if(a.server)l["S"]=u;else if(D){let m=crypto.getRandomValues(new Uint8Array(12));l["I"]=_(m),l["E"]=_(yield crypto.subtle.encrypt({iv:m,name:A},D,new TextEncoder().encode(u)))}else return E.dispatch(new Error("Trying to send without valid destination")),!1;return b.send(Be(l,Xe)),!0}),ue=o=>N&&N===y&&U(o,{server:!0}),ut=(o,a)=>a&&U(o,{receiver:a}),me=(o,a=6)=>{if(!pe.has(o))return!1;let d=pe.get(o),p="";for(let u=0;u<a;u++){let l=d[u]%be.length;p+=be[l]}return p};return{onConnection:De,onError:E,onMessage:Ae,onRoomJoin:we,onRoomLeave:Te,onUserJoin:Oe,onUserLeave:Ke,onUserVerified:Ee,onUserVerificationCode:xe,messageRoom:o=>U(o),messageServer:ue,messageUser:ut,closeRoom:()=>ue({type:"_RC"}),createRoom:(...a)=>G(null,[...a],function*(o={}){if(K&&K!==Y)return;P(ge),o.publicData&&(T=o.publicData),o.verifyPublicData&&(L=o.verifyPublicData);try{yield new Promise((l,h)=>{let m=new Worker(URL.createObjectURL(new Blob([We],{type:"text/javascript"})));m.addEventListener("message",I=>{I.data.success?(D=I.data.sharedKey,l()):h(new Error(I.data.error)),m.terminate()}),m.addEventListener("error",I=>{h(I),m.terminate()}),m.postMessage({type:"SHARED_KEY"})})}catch(l){P(Y),E.dispatch({error:l});return}let d=new URL(j+i);o.limit&&d.searchParams.append("limit",o.limit);let p=yield fetch(d.toString(),{method:"GET",headers:{Accept:r}});if(!p.ok)throw new Error("Failed to create room");let u=yield p.text();return u=e(u),N=u.userId,Ue(u.roomCode,u.creatorSecret),u}),joinRoom:(o,a={})=>{a.publicData&&(T=a.publicData),a.verifyPublicData&&(L=a.verifyPublicData),Ue(o)},leaveRoom:V,kickUser:ye,getVerificationCode:me,verifyUser:(o,a)=>G(null,null,function*(){if(N!==y||!a)return!1;let d=me(o,a.length);return!d||!a||d!==a||(Ne.set(o,!0),!F.get(o))?!1:(U({type:"_X2",privateData:Re},{receiver:o}),!0)})}};ke(["roupn"],{createClientConnector:yt});})();
