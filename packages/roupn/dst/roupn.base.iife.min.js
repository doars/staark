(()=>{var yt=Object.defineProperty,ut=Object.defineProperties;var lt=Object.getOwnPropertyDescriptors;var Ge=Object.getOwnPropertySymbols;var dt=Object.prototype.hasOwnProperty,ft=Object.prototype.propertyIsEnumerable;var Fe=(t,r,e)=>r in t?yt(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,ke=(t,r)=>{for(var e in r||(r={}))dt.call(r,e)&&Fe(t,e,r[e]);if(Ge)for(var e of Ge(r))ft.call(r,e)&&Fe(t,e,r[e]);return t},Ve=(t,r)=>ut(t,lt(r));var M=(t,r,e)=>new Promise((s,i)=>{var R=A=>{try{P(e.next(A))}catch(V){i(V)}},k=A=>{try{P(e.throw(A))}catch(V){i(V)}},P=A=>A.done?s(A.value):Promise.resolve(A.value).then(R,k);P((e=e.apply(t,r)).next())});var Be=(t,r)=>{let e=window;for(let s=0;s<t.length-1;s++)(typeof e[t[s]]!="object"||!Array.isArray(e[t[s]]))&&(e[t[s]]={}),e=e[t[s]];e[t[t.length-1]]=r};var ue="CONNECTED",le="CONNECTING",H="DISCONNECTED",de="DISCONNECTING",je="PENDING_VERIFICATION";var Q="_KA",fe="_KO",Je="_RC",Xe="_RJ";var ze="_UJ",We="_UK",Qe="_UL",_e="_UV";var l=t=>{let r=atob(t);return Uint8Array.from(r,e=>e.charCodeAt(0)).buffer},Ze=t=>{let r=atob(t),e=Uint8Array.from(r,s=>s.charCodeAt(0));return new TextDecoder().decode(e)},qe=t=>{let r=new TextEncoder().encode(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let i=0;i<r.length;i+=s){let R=r.subarray(i,i+s);e+=String.fromCharCode(...R)}return btoa(e)},d=t=>{let r=new Uint8Array(t);if(r.length<65536)return btoa(String.fromCharCode(...r));let e="",s=65536;for(let i=0;i<r.length;i+=s){let R=r.subarray(i,i+s);e+=String.fromCharCode(...R)}return btoa(e)};var b=()=>{let t=new Map;return{addListener:(r,e)=>{t.has(r)||t.set(r,e)},removeListener:r=>{t.delete(r)},dispatch:r=>{for(let[e,s]of t.entries())e(r),s&&s.once&&t.delete(e)}}};var $e="|",et=":",tt=(t,r)=>{let e=[];for(let s in t){let i=t[s];i!=null&&e.push(s+et+r(String(i)))}return e.join($e)},rt=(t,r)=>{let e={},s=t.split($e);for(let i of s){let R=i.indexOf(et);if(R>0){let k=i.substring(0,R),P=i.substring(R+1);e[k]=r(P)}}return e};var ot=(t,r)=>{let e=Date.now();if(!t)return{delay:0,offset:0,adjusted:e};if(!r){let R=t-e;return{delay:0,offset:R,adjusted:e+R}}let s=e-r,i=(t-r+(t-e))/2;return{delay:s,offset:i,adjusted:e-s+i}};var Re="ABCDEFGHKMNPQRSTUVWXYZ23456789";var Z="ECDH",me="P-256",q="raw",F="SHA-256",$="spki",m="AES-GCM";var ee="RSA-OAEP",T="RSASSA-PKCS1-v1_5",nt="self.addEventListener('message',"+(()=>{Promise.all([crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]),crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])]).then(([t,r,e])=>{Promise.all([crypto.subtle.exportKey("spki",t.publicKey),crypto.subtle.exportKey("spki",r.publicKey)]).then(([s,i])=>{self.postMessage({success:!0,myEncryptKeys:t,mySignKeys:r,myExchangeKeys:e,myPublicEncryptKey:s,myPublicSignKey:i})}).catch(s=>{self.postMessage({success:!1,error:s.message})})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")",st="self.addEventListener('message',"+(()=>{crypto.subtle.generateKey({length:256,name:"AES-GCM"},!0,["encrypt","decrypt"]).then(t=>{self.postMessage({success:!0,sharedKey:t})}).catch(t=>{self.postMessage({success:!1,error:t.message})})}).toString()+")";var Ne="S",at="T",Ie="E",ge="I",Ce="U",he="D",Se="V",be="K",Ae="P",Oe="G";var it=(t={})=>{let{contentType:r="application/json",deserializeMessage:e=JSON.parse,serializeMessage:s=JSON.stringify,createRoomEndpoint:i="/create-room",joinRoomEndpoint:R="/join-room",httpUrl:k="http://localhost:3000",wsUrl:P="http://localhost:3000",messageBufferMaxCount:A=50,messageBufferMaxDuration:V=60*1e3}=t,_,w,B,N,Ee,Y,te,re,j,x,h=[],S,oe,L=new Map,J=new Map,X=new Map,ne=new Map,D=H,v=()=>(!w&&!B&&(B=new Promise((n,a)=>{let y=new Worker(URL.createObjectURL(new Blob([nt],{type:"text/javascript"})));y.addEventListener("message",c=>{if(c.data.success)Ee=c.data.myEncryptKeys,j=c.data.mySignKeys,Y=c.data.myExchangeKeys,te=c.data.myPublicEncryptKey,re=c.data.myPublicSignKey,w=!0,B=null,n();else{let p=new Error(c.data.error);f.dispatch({error:p}),a(p)}y.terminate()}),y.addEventListener("error",c=>{f.dispatch({error:c}),a(c),y.terminate()}),y.postMessage({type:"USER_KEYS"})})),B);v();let f=b(),Ke=b(),Te=b(),we=b(),xe=b(),De=b(),se=b(),Ue=b(),Pe=b(),U=n=>{D!==n&&(D=n,Pe.dispatch({state:n}))},Le=n=>M(null,null,function*(){let a=L.get(n);a&&(ne.set(n,Array.from(new Uint8Array(yield crypto.subtle.digest(F,new TextEncoder().encode(oe+d(yield crypto.subtle.exportKey("raw",a))))))),Ue.dispatch({userId:n,code:ye(n)}))}),ae=()=>{D===H||D===de||(U(de),S&&S.close(),_=w=B=N=Ee=Y=te=re=j=x=h=S=null,L.clear(),J.clear(),X.clear(),ne.clear(),v(),U(H))},ve=(n,a=null)=>{if(!a&&D&&D!==H)return;U(le),oe=n;let y=new URL(P+R);y.searchParams.append("code",oe),a&&y.searchParams.append("creator",a),S=new WebSocket(y.toString()),S.addEventListener("close",c=>{we.dispatch({event:c}),ae()}),S.addEventListener("error",c=>{f.dispatch({event:c}),ae()}),S.addEventListener("message",c=>M(null,null,function*(){Me(rt(c.data,Ze),c.data)}))},Me=(n,a,y=!1)=>M(null,null,function*(){let{[Ne]:c,[at]:p,[ge]:u,[Ie]:I,[he]:g,[Se]:C,[be]:z,[Ae]:He,[Oe]:Ye,[Ce]:Et}=n,o,W,ie;if(c?ie=c:g?ie=g:ie=a,I){if(!x||!y&&h.length>0){h.push({time:Date.now(),parts:n,raw:a}),h.length>A&&h.shift();return}if(!u){f.dispatch(new Error("Missing IV to decrypt message"));return}o=yield crypto.subtle.decrypt({iv:l(u),name:m},x,l(I)),o=new TextDecoder().decode(o)}else if(He){if(!Ye||!z||!C)return;w||(yield v());let E=e(new TextDecoder().decode(yield crypto.subtle.decrypt({iv:l(C),name:m},yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({name:ee},Ee.privateKey,l(z)),{name:m},!0,["encrypt","decrypt"]),l(He))));if(E.type===Q)W=E;else{let O=E.sender;if(!O){f.dispatch({error:new Error("Message from unknown sender")});return}let K=X.get(O);if(!K){f.dispatch({error:new Error("No public key for "+O)});return}if(!(yield crypto.subtle.verify(T,K,l(Ye),dataBuffer))){f.dispatch({error:new Error("Invalid signature from "+O)});return}W=E}}else o=ie;if(!W)try{W=e(o)}catch(E){f.dispatch({error:new Error("Failed to parse message "+a)});return}switch(o=W,o.type){case fe:if(N===_){let E=o.sender;J.set(E,yield crypto.subtle.importKey($,l(o.publicEncryptKey),{hash:F,name:ee},!0,["encrypt"]));let O=yield crypto.subtle.importKey($,l(o.publicSignKey),{hash:F,name:T},!0,["verify"]),K=l(o.publicExchangeKey);if(!(yield crypto.subtle.verify(T,O,l(o.signature),K))){f.dispatch({error:new Error("Invalid signature for exchange from "+E)});return}X.set(E,O),w||(yield v()),L.set(E,yield crypto.subtle.deriveKey({name:Z,public:yield crypto.subtle.importKey(q,K,{name:Z,namedCurve:me},!0,[])},Y.privateKey,{length:256,name:m},!0,["encrypt","decrypt"]));let pe=yield crypto.subtle.exportKey(q,Y.publicKey);G({type:Q,publicEncryptKey:d(te),publicExchangeKey:d(pe),publicSignKey:d(re),signature:d(yield crypto.subtle.sign(T,j.privateKey,pe))},{receiver:E}),Le(E)}break;case Q:if(Et===N&&o.sender===_){if(o.publicSignKey){let E=yield crypto.subtle.importKey($,l(o.publicSignKey),{hash:F,name:T},!0,["verify"]);if(o.publicExchangeKey&&o.signature&&!(yield crypto.subtle.verify(T,E,l(o.signature),l(o.publicExchangeKey)))){f.dispatch({error:new Error("Invalid signature for exchange from "+_)}),ae();return}X.set(_,E)}if(o.publicEncryptKey&&J.set(_,yield crypto.subtle.importKey($,l(o.publicEncryptKey),{hash:F,name:ee},!0,["encrypt"])),o.publicExchangeKey&&(w||(yield v()),L.set(_,yield crypto.subtle.deriveKey({name:Z,public:yield crypto.subtle.importKey(q,l(o.publicExchangeKey),{name:Z,namedCurve:me},!0,[])},Y.privateKey,{length:256,name:m},!0,["encrypt","decrypt"]))),o.sharedKey&&o.sharedKeyIv){let E=L.get(_);if(!E){f.dispatch({error:new Error("No derived key for host "+_)});return}if(x=yield crypto.subtle.importKey("raw",yield crypto.subtle.decrypt({iv:l(o.sharedKeyIv),name:m},E,l(o.sharedKey)),{name:m},!0,["encrypt","decrypt"]),se.dispatch({userId:N}),h.length>0){let O=Date.now();for(h=h.filter(K=>O-K.time<V);h.length>0;){let{parts:K,raw:pe}=h.shift();Me(K,pe,!0)}}U(ue)}else Le(_)}break;case Xe:if(_=o.creatorId,N=o.userId,Te.dispatch({creatorId:o.creatorId,roomCode:oe,userId:o.userId,users:o.users}),N!==_){U(je),w||(yield v());let E=yield crypto.subtle.exportKey(q,Y.publicKey);G({type:fe,publicEncryptKey:d(te),publicExchangeKey:d(E),publicSignKey:d(re),signature:d(yield crypto.subtle.sign(T,j.privateKey,E))},{allowUnencrypted:!0,receiver:_})}else U(ue);break;case Qe:De.dispatch({userId:o.userId}),L.delete(o.userId),J.delete(o.userId),X.delete(o.userId);break;case ze:xe.dispatch({userId:o.userId});break;case _e:se.dispatch({userId:o.userId});break;default:Ke.dispatch({data:o,time:ot(p,o==null?void 0:o.senderTime)});break}}),G=(y,...c)=>M(null,[y,...c],function*(n,a={}){if(!S||S.readyState!==WebSocket.OPEN)return f.dispatch({error:new Error("No open socket")}),!1;let p=s(Ve(ke({},n),{sender:N,senderTime:Date.now()})),u={};if(a.receiver){let I=J.get(a.receiver);if(I){let g=yield crypto.subtle.generateKey({name:m,length:256},!0,["encrypt","decrypt"]),C=crypto.getRandomValues(new Uint8Array(12)),z=yield crypto.subtle.encrypt({iv:C,name:m},g,new TextEncoder().encode(p));w||(yield v()),u[Oe]=d(yield crypto.subtle.sign(T,j.privateKey,z)),u[be]=d(yield crypto.subtle.encrypt({name:ee},I,yield crypto.subtle.exportKey("raw",g))),u[Ae]=d(z),u[Se]=d(C)}else if(a.allowUnencrypted)u[he]=p;else return f.dispatch({error:new Error("No public key for "+a.receiver)}),!1;u[Ce]=a.receiver}else if(a.server)u[Ne]=p;else if(x){let I=crypto.getRandomValues(new Uint8Array(12));u[ge]=d(I),u[Ie]=d(yield crypto.subtle.encrypt({iv:I,name:m},x,new TextEncoder().encode(p)))}else return f.dispatch(new Error("Trying to send without valid destination")),!1;return S.send(tt(u,qe)),!0}),ce=n=>N&&N===_&&G(n,{server:!0}),pt=(n,a)=>a&&G(n,{receiver:a}),ye=(n,a=6)=>{if(!ne.has(n))return!1;let y=ne.get(n),c="";for(let p=0;p<a;p++){let u=y[p]%Re.length;c+=Re[u]}return c};return{onConnection:Pe,onError:f,onMessage:Ke,onRoomJoin:Te,onRoomLeave:we,onUserJoin:xe,onUserLeave:De,onUserVerified:se,onUserVerificationCode:Ue,messageRoom:n=>G(n),messageServer:ce,messageUser:pt,closeRoom:()=>ce({type:Je}),createRoom:(...a)=>M(null,[...a],function*(n={}){if(D&&D!==H)return;U(le);try{yield new Promise((u,I)=>{let g=new Worker(URL.createObjectURL(new Blob([st],{type:"text/javascript"})));g.addEventListener("message",C=>{C.data.success?(x=C.data.sharedKey,u()):I(new Error(C.data.error)),g.terminate()}),g.addEventListener("error",C=>{I(C),g.terminate()}),g.postMessage({type:"SHARED_KEY"})})}catch(u){U(H),f.dispatch({error:u});return}let y=new URL(k+i);n.limit&&y.searchParams.append("limit",n.limit);let c=yield fetch(y.toString(),{method:"GET",headers:{Accept:r}});if(!c.ok)throw new Error("Failed to create room");let p=yield c.text();return p=e(p),N=p.userId,ve(p.roomCode,p.creatorSecret),p}),joinRoom:n=>ve(n),leaveRoom:ae,kickUser:n=>ce({type:We,userId:n}),getVerificationCode:ye,verifyUser:(n,a)=>M(null,null,function*(){if(N!==_||!a)return!1;let y=ye(n,a.length);if(!y||!a||y!==a)return!1;let c=L.get(n);if(!c)return!1;let p=crypto.getRandomValues(new Uint8Array(12));return G({type:Q,sharedKey:d(yield crypto.subtle.encrypt({iv:p,name:m},c,yield crypto.subtle.exportKey("raw",x))),sharedKeyIv:d(p)},{receiver:n}),se.dispatch({userId:n}),ce({type:_e,userId:n}),!0})}};Be(["roupn"],{createClientConnector:it});})();
