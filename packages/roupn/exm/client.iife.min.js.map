{
  "version": 3,
  "sources": ["../../staark-common/src/array.js", "../../staark-common/src/conditional.js", "../../staark-common/src/marker.js", "../../staark-common/src/node.js", "../../staark-common/src/match.js", "../../staark-common/src/clone.js", "../../staark-common/src/compare.js", "../../staark-common/src/element.js", "../../staark/src/library/proxy.js", "../../staark/src/library/mount.js", "../src/library/message-types.js", "../src/utilities/code.js", "../src/utilities/encoding-client.js", "../src/utilities/event.js", "../src/utilities/protocol.js", "../src/utilities/time.js", "../src/library/key-generator.js", "../src/library/payload-keys.js", "../src/library/client-connector.js", "../../tiedliene/src/utilities/clone.js", "../../tiedliene/src/library/diff.js", "../src/library/client-synchronizer.js", "client.js"],
  "sourcesContent": [
    "/**\n * Ensure the data is an array if it isn't already. Non-truthy values are converted to empty arrays.\n *\n * @template T\n * @param {T|T[]} data Data to \"arrify\".\n * @returns {T[]} An array containing the data.\n */\nexport const arrayify = (\n  data,\n) => arrayifyOrUndefined(data) || []\n\n/**\n * Ensure the data is an array if it isn't already. Non-truthy values are converted to undefined.\n *\n * @template T\n * @param {T|T[]} data Data to arrify.\n * @returns {(T[]|undefined)} An array containing the data or undefined.\n */\nexport const arrayifyOrUndefined = (\n  data,\n) => data ? (\n  Array.isArray(data)\n    ? data\n    : [data]\n) : undefined\n",
    "import { arrayify } from './array.js'\n\n/**\n * @typedef {import('./node.js').NodeContent} NodeContent\n * @typedef {import('./types.js').ResolveFunction} ResolveFunction\n */\n\n/**\n * Returns the content based on the condition.\n *\n * @param {any} condition The condition to evaluate.\n * @param {NodeContent[] | NodeContent | ResolveFunction} onTruth The content to return if the condition is true.\n * @param {NodeContent[] | NodeContent | ResolveFunction} [onFalse] The content to return if the condition is false.\n * @returns {NodeContent[]} The resulting content as an array.\n */\nexport const conditional = (\n  condition,\n  onTruth,\n  onFalse,\n) => {\n  let result = (\n    condition\n      ? onTruth\n      : onFalse\n  )\n  if (typeof (result) === 'function') {\n    result = result()\n  }\n  return arrayify(result)\n}\n",
    "/**\n * @type {string} Marker that can be used as a node discriminator.\n */\nexport const marker = 'n'\n",
    "import { arrayifyOrUndefined } from './array.js'\nimport { marker } from './marker.js'\n\n/**\n * @typedef {import('./memo.js').MemoAbstract} MemoAbstract\n */\n\n/**\n * @typedef {function(Event, Record<string, any>): unknown} NodeAttributeListener Listener for node attribute.\n * @property {function(Event, Record<string, any>): unknown} [f] Function that was written to the DOM tree before being wrapped so it can be compared to.\n */\n\n/**\n * @typedef {Object.<string, boolean | null | number | string | (number | string)[] | NodeAttributeListener | Record<string, boolean | number | string>>} NodeAttributes Attributes of a node.\n */\n\n/**\n * @typedef {string | MemoAbstract | NodeAbstract} NodeContent Content of a node.\n */\n\n/**\n * @typedef {Object} NodeAbstract Node abstract.\n * @property {string} _ Discriminator to differentiate from other objects.\n * @property {NodeAttributes} [a] Attributes of the node.\n * @property {NodeContent[]} [c] Abstracts of children.\n * @property {string} t Node type of the node.\n */\n\n/**\n * Creates a NodeAbstract object.\n *\n * @param {string} type Type of the node.\n * @param {NodeAttributes | NodeContent[] | NodeContent} [attributesOrContents] Attributes of node or contents.\n * @param {NodeContent[] | NodeContent} [contents] Abstracts of children.\n * @returns {NodeAbstract} Node abstract representing the given data.\n */\nexport const node = (\n  type,\n  attributesOrContents,\n  contents,\n) => {\n  if (\n    attributesOrContents\n    && (\n      typeof (attributesOrContents) !== 'object'\n      || attributesOrContents._ === marker\n      || Array.isArray(attributesOrContents)\n    )\n  ) {\n    contents = attributesOrContents\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents,\n    c: arrayifyOrUndefined(contents),\n    t: type,\n  }\n}\n",
    "import { arrayify } from './array.js'\n\n/**\n * @typedef {import('./node.js').NodeContent} NodeContent\n * @typedef {import('./types.js').ResolveFunction} ResolveFunction\n */\n\n/**\n * Matches a key to a value in a lookup table, with a fallback option.\n *\n * @param {any} key The key to match.\n * @param {Record<any, NodeContent[] | NodeContent | ResolveFunction | null | undefined>} lookup The lookup table.\n * @param {NodeContent[] | NodeContent | ResolveFunction | null} [fallback] The fallback value.\n * @returns {NodeContent[]} The matched or fallback value, arrayified.\n */\nexport const match = (\n  key,\n  lookup,\n  fallback,\n) => {\n  let result\n  if (\n    lookup\n    && (key in lookup)\n    && lookup[key]\n  ) {\n    result = lookup[key]\n  } else {\n    result = fallback\n  }\n  if (typeof result === 'function') {\n    result = result()\n  }\n  return arrayify(result)\n}\n",
    "/**\n * Creates a deep clone of a JavaScript value.\n *\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n",
    "/**\n * Recursively checks if two values are equal.\n *\n * @param {*} valueA The first value to compare.\n * @param {*} valueB The second value to compare.\n * @returns {boolean} Returns true if the values are equal, otherwise false.\n */\nexport const equalRecursive = (\n  valueA,\n  valueB,\n) => {\n  if (valueA === valueB) {\n    return true\n  }\n\n  if (\n    !valueA\n    || !valueB\n    || typeof valueA !== 'object'\n    || typeof valueB !== 'object'\n  ) {\n    return valueA === valueB\n  }\n\n  if (valueA instanceof Date) {\n    return (\n      valueB instanceof Date\n      && valueA.getTime() === valueB.getTime()\n    )\n  }\n\n  // if (valueA.prototype !== valueB.prototype) {\n  //   return false\n  // }\n\n  const keys = Object.keys(valueA)\n  return (\n    keys.length === Object.keys(valueB).length\n    && keys.every(k => equalRecursive(valueA[k], valueB[k]))\n  )\n}\n",
    "import {\n  node,\n} from './node.js'\n\n/**\n * @typedef {import('./node.js').NodeContent} NodeContent\n */\n\n/**\n * @typedef {Object} Attribute An attribute of an element.\n * @property {string} name The name of the attribute.\n * @property {string} value The value of the attribute.\n */\n\n/**\n * Converts child nodes of an element to an array of abstract nodes.\n * @param {Element | ChildNode} element The element to convert.\n * @returns {NodeContent[]} The abstract nodes that are equivalent to the given element's child nodes.\n */\nexport const childrenToNodes = (\n  element,\n) => {\n  const abstractChildNodes = []\n  for (const childNode of element.childNodes) {\n    if (childNode instanceof Text) {\n      abstractChildNodes.push(\n        childNode.textContent ?? '',\n      )\n    } else {\n      const attributes = {}\n      for (const attribute of childNode.attributes) {\n        attributes[attribute.name] = attribute.value\n      }\n\n      abstractChildNodes.push(\n        node(\n          childNode.nodeName,\n          attributes,\n          childrenToNodes(childNode),\n        ),\n      )\n    }\n  }\n  return abstractChildNodes\n}\n",
    "/**\n * Creates a proxy for the given root object to track changes and invoke the onChange callback.\n *\n * @param {Record<string, any>} root - The root object to be proxified.\n * @param {() => void} onChange - The callback function to be invoked on changes.\n * @returns {Record<string, any>} - The proxified root object.\n */\nexport const proxify = (\n  root,\n  onChange,\n) => {\n  const handler = {\n    /**\n     * Deletes a property from the target object and invokes the onChange callback if the property existed.\n     *\n     * @param {Record<string, any>} target - The target object from which the property will be deleted.\n     * @param {string} key - The key of the property to be deleted.\n     * @returns {boolean} - True if the property was deleted, otherwise false.\n     */\n    deleteProperty: (\n      target,\n      key,\n    ) => {\n      if (Reflect.has(target, key)) {\n        const deleted = Reflect.deleteProperty(target, key)\n\n        if (deleted) {\n          onChange()\n        }\n\n        return deleted\n      }\n      return true\n    },\n\n    /**\n     * Sets a property on the target object and invokes the onChange callback if the value has changed.\n     *\n     * @param {Record<string, any>} target - The target object on which the property will be set.\n     * @param {string} key - The key of the property to be set.\n     * @param {any} value - The value to be set.\n     * @returns {boolean} - True if the property was set, otherwise false.\n     */\n    set: (\n      target,\n      key,\n      value,\n    ) => {\n      const existingValue = target[key]\n      if (existingValue !== value) {\n        // Add proxy if value is an object.\n        if (\n          value\n          && typeof value === 'object'\n        ) {\n          value = add(value)\n        }\n        target[key] = value\n\n        // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n        onChange()\n      }\n      return true\n    },\n  }\n\n  /**\n   * Recursively creates proxies for each property of the target object to track changes.\n   *\n   * @param {Record<string, any>} target - The object to be proxified.\n   * @returns {Record<string, any>} - The proxified object.\n   */\n  const add = (\n    target,\n  ) => {\n    // Recursively create proxies for each property.\n    for (const key in target) {\n      if (\n        target[key]\n        && typeof target[key] === 'object'\n      ) {\n        target[key] = add(target[key])\n      }\n    }\n\n    return new Proxy(target, handler)\n  }\n\n  return add(root)\n}\n",
    "import {\n    arrayifyOrUndefined,\n} from '@doars/staark-common/src/array.js'\nimport {\n    cloneRecursive,\n} from '@doars/staark-common/src/clone.js'\nimport {\n    equalRecursive,\n} from '@doars/staark-common/src/compare.js'\nimport {\n    childrenToNodes,\n} from '@doars/staark-common/src/element.js'\nimport {\n    proxify,\n} from './proxy.js'\n\n/**\n * @typedef {import('@doars/staark-common/src/node.js').NodeContent} NodeContent\n * @typedef {import('@doars/staark-common/src/node.js').NodeAttributes} NodeAttributes\n * @typedef {import('@doars/staark-common/src/node.js').NodeAttributeListener} NodeAttributeListener\n * @typedef {import('@doars/staark-common/src/memo.js').MemoFunction} MemoFunction\n * @typedef {import('@doars/staark-common/src/memo.js').MemoAbstract} MemoAbstract\n * @typedef {import('@doars/staark-common/src/node.js').NodeAbstract} NodeAbstract\n */\n\n/**\n * @typedef {Object} MemoData\n * @property {NodeContent[]} c Remembered abstract tree after rendering.\n * @property {any} m Remembered data to compare with.\n * @property {MemoFunction} r Render function to generated abstract tree.\n */\n\n/**\n * @param {HTMLElement | Element | string} rootElement Root element to mount the view on.\n * @param {function(Object<string, any>): (NodeContent[] | NodeContent)} renderView Function to render the view using the state.\n * @param {Object<string, any> | string} [initialState]  Initial state to use.\n * @param {NodeContent[] | string | null} [oldAbstractTree] Old abstract tree to compare with.\n * @returns {undefined | [function(string[]): void, function(): unknown, Object<string, any>]} Returns a trigger function to update the view, a function to unmount the view and the state object.\n */\nexport const mount = (\n  rootElement,\n  renderView,\n  initialState,\n  oldAbstractTree,\n) => {\n  if (typeof (initialState) === 'string') {\n    initialState = JSON.parse(initialState)\n  }\n  if (!initialState) {\n    initialState = {}\n  }\n  let updatePromise = null\n  const triggerUpdate = () => {\n    if (!updatePromise) {\n      updatePromise = Promise.resolve()\n        .then(updateAbstracts)\n    }\n    return updatePromise\n  }\n  const state = (\n    Object.getPrototypeOf(initialState) === Proxy.prototype\n      ? initialState\n      : proxify(\n        initialState,\n        triggerUpdate,\n      )\n  )\n\n  /**\n   * @param {Element} element Element to update.\n   * @param {NodeAttributes} newAttributes New attributes to set.\n   * @param {NodeAttributes} [oldAttributes] Old attributes to compare with.\n   */\n  const updateAttributes = (\n    element,\n    newAttributes,\n    oldAttributes,\n  ) => {\n    if (newAttributes) {\n      for (const name in newAttributes) {\n        let value = newAttributes[name]\n        if (value) {\n          const type = typeof (value)\n          if (type === 'function') {\n            const oldValue = oldAttributes?.[name]\n            if (oldValue?.f === value) {\n              newAttributes[name] = oldValue\n            } else {\n              if (oldValue) {\n                element.removeEventListener(\n                  name,\n                  oldValue,\n                )\n              }\n\n              const listener = newAttributes[name] =\n                (event) => {\n                  value(event, state)\n                }\n              element.addEventListener(\n                name,\n                listener,\n              )\n              listener.f = value\n            }\n          } else {\n            if (name === 'class') {\n              if (typeof (value) === 'object') {\n                if (Array.isArray(value)) {\n                  value = value.join(' ')\n                } else {\n                  let classNames = ''\n                  for (const className in value) {\n                    if (value[className]) {\n                      classNames += ' ' + className\n                    }\n                  }\n                  value = classNames\n                }\n              }\n              element.className = value\n            } else if (\n              name === 'style'\n              && typeof (value) === 'object'\n            ) {\n              for (let styleName in value) {\n                let styleValue = value[styleName]\n                if (styleName.includes('-', 1)) {\n                  element.style.setProperty(\n                    styleName,\n                    styleValue,\n                  )\n                } else {\n                  element.style[styleName] = styleValue\n                }\n              }\n\n              if (\n                oldAttributes\n                && oldAttributes[name]\n                && typeof (oldAttributes[name]) === 'object'\n                && !Array.isArray(oldAttributes[name])\n              ) {\n                for (let styleName in oldAttributes[name]) {\n                  if (!value[styleName]) {\n                    if (styleName.includes('-', 1)) {\n                      element.style.removeProperty(\n                        styleName,\n                      )\n                    } else {\n                      element.style[styleName] = null\n                    }\n                  }\n                }\n              }\n            } else {\n              if (value === true) {\n                value = 'true'\n              } else if (type !== 'string') {\n                value = value.toString()\n              }\n              element.setAttribute(name, value)\n              if (name === 'value') {\n                element.value = value\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (oldAttributes) {\n      for (const name in oldAttributes) {\n        const value = oldAttributes[name]\n        if (\n          !newAttributes\n          || !newAttributes[name]\n        ) {\n          if (typeof (value) === 'function') {\n            element.removeEventListener(\n              name,\n              oldAttributes[name],\n            )\n          } else if (name === 'class') {\n            element.className = ''\n          } else if (name === 'style') {\n            element.style.cssText = ''\n          } else if (name === 'value') {\n            element.value = ''\n          } else {\n            element.removeAttribute(name)\n          }\n        }\n      }\n    }\n  }\n\n  let oldMemoMap = new WeakMap()\n  let newMemoMap = new WeakMap()\n\n  /**\n   * @param {Element} element Element to update.\n   * @param {NodeContent[]} [newChildAbstracts] New children to set.\n   * @param {NodeContent[]} [oldChildAbstracts] Old children to compare with.\n   */\n  const updateChildren = (\n    element,\n    newChildAbstracts,\n    oldChildAbstracts,\n    inSvg,\n  ) => {\n    let newIndex = 0\n    let newCount = 0\n    if (newChildAbstracts) {\n      for (; newIndex < newChildAbstracts.length; newIndex++) {\n        const newAbstract = newChildAbstracts[newIndex]\n\n        if (newAbstract.r) {\n          let match = oldMemoMap.get(\n            newAbstract.r,\n          )\n          console.log('checking for memo')\n          if (\n            !match\n            || !equalRecursive(match.m, newAbstract.m)\n          ) {\n            match = {\n              c: arrayifyOrUndefined(\n                newAbstract.r(\n                  state,\n                  newAbstract.m,\n                ),\n              ),\n              m: newAbstract.m,\n              r: newAbstract.r,\n            }\n          }\n\n          newMemoMap.set(newAbstract.r, match)\n\n          // Splice nodes into the tree and re-run the loop again.\n          newChildAbstracts.splice(\n            newIndex,\n            1,\n            // NOTE: Is a recursive clone required here? Yes as long as the old abstract tree is mutated.\n            ...cloneRecursive(\n              match.c,\n            ),\n          )\n          // NOTE: Preferably we would skip re-rendering when the nodes were memoized, but because those nodes might have morphed we'll have to check. So we re-process the node again that was just inserted in. We could have the resolve memoization return whether it was re-rendered, but this also means the nodes are not allowed to be re-used when morphing the DOM and this needs to be prevented by marking them as such.\n          newIndex--\n          continue\n        }\n\n        let matched = false\n        if (oldChildAbstracts) {\n          for (let oldIndex = newIndex - newCount; oldIndex < oldChildAbstracts.length; oldIndex++) {\n            const oldAbstract = oldChildAbstracts[oldIndex]\n            if (\n              (\n                oldAbstract.t\n                && newAbstract.t === oldAbstract.t\n              )\n              || (\n                !oldAbstract.t\n                && !newAbstract.t\n              )\n            ) {\n              matched = true\n\n              if (newIndex !== (oldIndex + newCount)) {\n                element.insertBefore(\n                  element.childNodes[oldIndex + newCount],\n                  element.childNodes[newIndex],\n                )\n                oldChildAbstracts.splice(\n                  newIndex - newCount,\n                  0,\n                  oldChildAbstracts.splice(\n                    oldIndex,\n                    1,\n                  )[0],\n                )\n              }\n\n              if (newAbstract.t) {\n                updateAttributes(\n                  element.childNodes[newIndex],\n                  newAbstract.a,\n                  oldAbstract.a,\n                )\n                updateChildren(\n                  element.childNodes[newIndex],\n                  newAbstract.c,\n                  oldAbstract.c,\n                  inSvg || newAbstract.t === 'SVG' || newAbstract.t === 'svg',\n                )\n              } else if (oldAbstract !== newAbstract) {\n                element.childNodes[newIndex].textContent = newAbstract\n              }\n              break\n            }\n          }\n        }\n\n        if (!matched) {\n          let newNode\n          if (newAbstract.t) {\n            const _inSvg = inSvg || newAbstract.t === 'SVG' || newAbstract.t === 'svg'\n            if (_inSvg) {\n              newNode = document.createElementNS(\n                'http://www.w3.org/2000/svg',\n                newAbstract.t\n              )\n            } else {\n              newNode = document.createElement(\n                newAbstract.t,\n              )\n            }\n            updateAttributes(\n              newNode,\n              newAbstract.a,\n              undefined,\n              _inSvg,\n            )\n            updateChildren(\n              newNode,\n              newAbstract.c,\n              undefined,\n              _inSvg,\n            )\n          } else {\n            newNode = document.createTextNode(\n              newAbstract,\n            )\n          }\n\n          element.insertBefore(\n            newNode,\n            element.childNodes[newIndex],\n          )\n          newCount++\n        }\n      }\n    }\n\n    if (oldChildAbstracts) {\n      const elementLength = oldChildAbstracts.length + newCount\n      if (elementLength >= newIndex) {\n        for (let i = elementLength - 1; i >= newIndex; i--) {\n          element.childNodes[i].remove()\n        }\n      }\n    }\n  }\n\n  const _rootElement = (\n    typeof (rootElement) === 'string'\n      ? (\n        document.querySelector(rootElement)\n        || document.body.appendChild(\n          document.createElement('div'),\n        )\n      )\n      : rootElement\n  )\n\n  if (typeof (oldAbstractTree) === 'string') {\n    try {\n      oldAbstractTree = JSON.parse(oldAbstractTree)\n    } catch (error) {\n      oldAbstractTree = null\n    }\n  }\n  if (!oldAbstractTree) {\n    oldAbstractTree = childrenToNodes(_rootElement)\n  }\n\n  let active = true,\n    updating = false\n  const updateAbstracts = () => {\n    if (\n      active\n      && !updating\n      && updatePromise\n    ) {\n      updating = true\n      updatePromise = null\n\n      let newAbstractTree = arrayifyOrUndefined(\n        renderView(state),\n      )\n      updateChildren(\n        _rootElement,\n        newAbstractTree,\n        oldAbstractTree,\n      )\n      oldAbstractTree = newAbstractTree\n      oldMemoMap = newMemoMap\n      newMemoMap = new WeakMap()\n\n      updating = false\n    }\n  }\n  triggerUpdate()\n  updateAbstracts()\n\n  return [\n    triggerUpdate,\n    () => {\n      if (active) {\n        active = false\n\n        for (let i = _rootElement.childNodes.length - 1; i >= 0; i--) {\n          _rootElement.childNodes[i].remove()\n        }\n      }\n    },\n    state,\n  ]\n}\n",
    "export const CONNECTION_CONNECTED = 'CONNECTED'\nexport const CONNECTION_CONNECTING = 'CONNECTING'\nexport const CONNECTION_DISCONNECTED = 'DISCONNECTED'\nexport const CONNECTION_DISCONNECTING = 'DISCONNECTING'\nexport const CONNECTION_PENDING_VERIFICATION = 'PENDING_VERIFICATION'\n\nexport const ERROR = '_ER'\nexport const MESSAGE = '_MS'\n\nexport const EXCHANGE_0 = '_X0'\nexport const EXCHANGE_1 = '_X1'\nexport const EXCHANGE_2 = '_X2'\nexport const EXCHANGE_3 = '_X3'\nexport const EXCHANGE_4 = '_X4'\n\nexport const ROOM_CLOSED = '_RC'\nexport const ROOM_JOINED = '_RJ'\nexport const ROOM_LEFT = '_RL'\nexport const ROOM_REMOVED = '_RR'\n\nexport const STATE_UPDATE = '_SU'\nexport const STATE_SYNCH = '_SS'\n\nexport const USER_JOINED = '_UJ'\nexport const USER_KICK = '_UK'\nexport const USER_LEFT = '_UL'\nexport const USER_VERIFIED = '_UV'\n",
    "/**\n * A string containing the allowed characters for generating identifiers.\n * @type {string}\n */\nexport const ALPHANUMERIC_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n/**\n * A string containing the allowed characters for generating codes. Excludes easily confused characters such as 'I', 'O', 'L', '1', and '0'.\n * @type {string}\n */\nexport const IDENTIFIABLE_CHARACTERS = 'ABCDEFGHKMNPQRSTUVWXYZ23456789'\n\n/**\n * Generates a random code string of the specified length.\n *\n * @param {number} [length=6] - The length of the code to generate.\n * @param {string} [characters='ABCDEFGHKMNPQRSTUVWXYZ23456789'] - The characters the code can consist of.\n * @returns {string} A randomly generated code.\n */\nexport const generateCode = (\n  length = 24,\n  characters = ALPHANUMERIC_CHARACTERS,\n) => {\n  let code = ''\n  for (let i = 0; i < length; i++) {\n    code += characters.charAt(\n      Math.floor(\n        Math.random()\n        * characters.length\n      ),\n    )\n  }\n  return code\n}\n",
    "export const base64ToBuffer = (\n  base64,\n) => {\n  const binary = atob(base64)\n  return Uint8Array.from(\n    binary,\n    character => character.charCodeAt(0),\n  ).buffer\n}\n\nexport const base64ToString = (\n  base64,\n) => {\n  const binary = atob(base64)\n  const bytes = Uint8Array.from(\n    binary,\n    character => character.charCodeAt(0)\n  )\n  return new TextDecoder().decode(bytes)\n}\n\nexport const stringToBase64 = (\n  string,\n) => {\n  const bytes = new TextEncoder().encode(string)\n\n  if (bytes.length < 65536) {\n    return btoa(\n      String.fromCharCode(...bytes),\n    )\n  }\n\n  let binary = ''\n  const chunkSize = 65536\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode(...chunk)\n  }\n  return btoa(binary)\n}\n\nexport const bufferToBase64 = (\n  buffer,\n) => {\n  const bytes = new Uint8Array(buffer)\n\n  if (bytes.length < 65536) {\n    return btoa(\n      String.fromCharCode(...bytes),\n    )\n  }\n\n  let binary = ''\n  const chunkSize = 65536\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode(...chunk)\n  }\n  return btoa(binary)\n}\n",
    "/**\n * Type definition for event listener options.\n * @typedef {Object} EventListenerOptions\n * @property {boolean} [once] - If true, the listener will be removed after the first call.\n */\n\n/**\n * Type definition for an event listener callback.\n * @typedef {(data: any) => void} EventListenerCallback\n */\n\n/**\n * Type definition for the event object returned by createEvent.\n * @typedef {Object} Event\n * @property {(callback: EventListenerCallback, options?: EventListenerOptions) => void} addListener\n * @property {(callback: EventListenerCallback) => void} removeListener\n * @property {(data: any) => void} dispatch\n */\n\n/**\n * Creates a custom event system with add, remove, and dispatch capabilities.\n *\n * @returns {Event} An event object with methods to manage listeners.\n */\nexport const createEvent = (\n) => {\n  /** @type {Map<EventListenerCallback, EventListenerOptions | undefined>} */\n  const listeners = new Map()\n\n  return {\n    /**\n     * Adds a listener callback for the event.\n     * @param {EventListenerCallback} callback - The listener function to add.\n     * @param {EventListenerOptions} [options] - Optional options for the listener (e.g., { once: true }).\n     */\n    addListener: (\n      callback,\n      options,\n    ) => {\n      if (!listeners.has(callback)) {\n        listeners.set(callback, options)\n      }\n    },\n\n    /**\n     * Removes a listener callback from the event.\n     * @param {EventListenerCallback} callback - The listener function to remove.\n     */\n    removeListener: (\n      callback,\n    ) => {\n      listeners.delete(callback)\n    },\n\n    /**\n     * Dispatches the event to all registered listeners.\n     * @param {any} data - Data to pass to each listener callback.\n     */\n    dispatch: (\n      data,\n    ) => {\n      for (const [listener, options] of listeners.entries()) {\n        listener(data)\n        if (\n          options\n          && options.once\n        ) {\n          listeners.delete(listener)\n        }\n      }\n    },\n  }\n}\n",
    "const DELIMITER = '|'\nconst INFIX = ':'\n\nexport const encode = (\n  parts,\n  stringToBase64,\n) => {\n  const segments = []\n  for (const key in parts) {\n    const value = parts[key]\n    if (\n      value !== null\n      && value !== undefined\n    ) {\n      segments.push(key + INFIX + stringToBase64(\n        String(value)),\n      )\n    }\n  }\n  return segments.join(DELIMITER)\n}\n\nexport const decode = (\n  message,\n  base64ToString,\n) => {\n  const parts = {}\n  const segments = message.split(DELIMITER)\n  for (const segment of segments) {\n    const index = segment.indexOf(INFIX)\n    if (index > 0) {\n      const key = segment.substring(0, index)\n      const value = segment.substring(index + 1)\n      parts[key] = base64ToString(value)\n    }\n  }\n  return parts\n}\n",
    "\n/**\n * Calculates time synchronization values based on provided server and sender times.\n *\n * @param {string} serverTime - The date and time the server broadcasted the data.\n * @param {string} senderTime - The date and time the sender send the data.\n * @returns {{\n *   delay: number,\n *   offset: number,\n *   adjusted: number,\n * }} An object containing the calculated delay, offset, and adjusted time.\n */\nexport const calculateTime = (\n  serverTime,\n  senderTime,\n) => {\n  const receiverTime = Date.now()\n\n  if (!serverTime) {\n    return {\n      delay: 0,\n      offset: 0,\n      adjusted: receiverTime,\n    }\n  }\n\n  if (!senderTime) {\n    const offset = serverTime - receiverTime\n    return {\n      delay: 0,\n      offset: offset,\n      adjusted: (\n        receiverTime\n        + offset\n      ),\n    }\n  }\n\n  const delay = receiverTime - senderTime\n  const offset = (\n    (serverTime - senderTime)\n    + (serverTime - receiverTime)\n  ) / 2\n  return {\n    delay: delay,\n    offset: offset,\n    adjusted: (\n      receiverTime\n      - delay\n      + offset\n    ),\n  }\n}\n",
    "export const DIFFIE_HELLMAN_ALGORITHM = 'ECDH'\nexport const DIFFIE_HELLMAN_CURVE = 'P-256'\nexport const DIFFIE_HELLMAN_EXPORT_FORMAT = 'raw'\nexport const HASH_ALGORITHM = 'SHA-256'\nexport const PUBLIC_KEY_EXPORT_FORMAT = 'spki'\nexport const SHARED_ENCRYPTION_ALGORITHM = 'AES-GCM'\nexport const SHARED_KEY_LENGTH = 256\nexport const USER_ENCRYPTION_ALGORITHM = 'RSA-OAEP'\nexport const USER_SIGNATURE_ALGORITHM = 'RSASSA-PKCS1-v1_5'\n\n// Values are inlined because of the string generated by the toString call will not have the same context. It is not written in a string in order to allow the build tool to minify and post-process the function's contents.\n\nexport const USER_KEY_GENERATOR = 'self.addEventListener(\\'message\\',' + ((\n) => {\n  Promise.all([\n    crypto.subtle.generateKey({\n      name: 'RSA-OAEP',\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: { name: 'SHA-256', },\n    }, true, ['encrypt', 'decrypt',]),\n    crypto.subtle.generateKey({\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: { name: 'SHA-256', },\n    }, true, ['sign', 'verify',]),\n    crypto.subtle.generateKey({\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    }, true, ['deriveKey',]),\n  ])\n    .then(([\n      myEncryptKeys,\n      mySignKeys,\n      myExchangeKeys,\n    ]) => {\n      Promise.all([\n        crypto.subtle.exportKey(\n          'spki',\n          myEncryptKeys.publicKey,\n        ),\n        crypto.subtle.exportKey(\n          'spki',\n          mySignKeys.publicKey,\n        ),\n      ])\n        .then(([\n          myPublicEncryptKey,\n          myPublicSignKey,\n        ]) => {\n          self.postMessage({\n            success: true,\n            myEncryptKeys,\n            mySignKeys,\n            myExchangeKeys,\n            myPublicEncryptKey,\n            myPublicSignKey,\n          })\n        })\n        .catch((error) => {\n          self.postMessage({\n            success: false,\n            error: error.message,\n          })\n        })\n    })\n    .catch((error) => {\n      self.postMessage({\n        success: false,\n        error: error.message,\n      })\n    })\n}).toString() + ')'\n\nexport const SHARED_KEY_GENERATOR = 'self.addEventListener(\\'message\\',' + ((\n) => {\n  crypto.subtle.generateKey({\n    length: 256,\n    name: 'AES-GCM',\n  }, true, ['encrypt', 'decrypt'])\n    .then(sharedKey => {\n      self.postMessage({\n        success: true,\n        sharedKey,\n      })\n    })\n    .catch(error => {\n      self.postMessage({\n        success: false,\n        error: error.message,\n      })\n    })\n}).toString() + ')'\n",
    "export const SERVER_PAYLOAD = 'S'\nexport const SERVER_TIME = 'T'\n\nexport const SHARED_ENCRYPTION_PAYLOAD = 'E'\nexport const SHARED_ENCRYPTION_IV = 'I'\n\nexport const USER = 'U'\nexport const USER_DIRECT_PAYLOAD = 'D'\nexport const USER_ENCRYPTION_IV = 'V'\nexport const USER_ENCRYPTION_KEY = 'K'\nexport const USER_ENCRYPTION_PAYLOAD = 'P'\nexport const USER_ENCRYPTION_SIGNATURE = 'G'\n",
    "import {\n    CONNECTION_CONNECTED,\n    CONNECTION_CONNECTING,\n    CONNECTION_DISCONNECTED,\n    CONNECTION_DISCONNECTING,\n    CONNECTION_PENDING_VERIFICATION,\n\n    EXCHANGE_0,\n    EXCHANGE_1,\n    EXCHANGE_2,\n    EXCHANGE_3,\n    EXCHANGE_4,\n\n    ROOM_CLOSED,\n    ROOM_JOINED,\n\n    USER_JOINED,\n    USER_KICK,\n    USER_LEFT,\n    USER_VERIFIED,\n} from './message-types.js'\n\nimport {\n    IDENTIFIABLE_CHARACTERS,\n} from '../utilities/code.js'\nimport {\n    base64ToBuffer,\n    base64ToString,\n    bufferToBase64,\n    stringToBase64,\n} from '../utilities/encoding-client.js'\nimport {\n    createEvent,\n} from '../utilities/event.js'\nimport {\n    decode,\n    encode,\n} from '../utilities/protocol.js'\nimport {\n    calculateTime,\n} from '../utilities/time.js'\nimport {\n    DIFFIE_HELLMAN_ALGORITHM,\n    DIFFIE_HELLMAN_CURVE,\n    DIFFIE_HELLMAN_EXPORT_FORMAT,\n    HASH_ALGORITHM,\n    PUBLIC_KEY_EXPORT_FORMAT,\n    SHARED_ENCRYPTION_ALGORITHM,\n    SHARED_KEY_GENERATOR,\n    SHARED_KEY_LENGTH,\n    USER_ENCRYPTION_ALGORITHM,\n    USER_KEY_GENERATOR,\n    USER_SIGNATURE_ALGORITHM,\n} from './key-generator.js'\nimport {\n    SERVER_PAYLOAD,\n    SERVER_TIME,\n\n    SHARED_ENCRYPTION_IV,\n    SHARED_ENCRYPTION_PAYLOAD,\n    USER,\n    USER_DIRECT_PAYLOAD,\n\n    USER_ENCRYPTION_IV,\n    USER_ENCRYPTION_KEY,\n    USER_ENCRYPTION_PAYLOAD,\n    USER_ENCRYPTION_SIGNATURE\n} from './payload-keys.js'\n\n/**\n * @typedef {import('../utilities/event.js').Event} Event\n */\n\n/**\n * @typedef {Object} ConnectorOptions\n *\n * @property {string} [createRoomEndpoint='/create-room'] - HTTP endpoint for creating a room.\n * @property {string} [joinRoomEndpoint='/join-room'] - WebSocket endpoint for joining a room.\n *\n * @property {string} [contentType='application/json'] - Content-Type for HTTP requests.\n * @property {Function} [deserializeMessage=JSON.parse] - Function to deserialize incoming messages.\n * @property {Function} [serializeMessage=JSON.stringify] - Function to serialize outgoing messages.\n *\n * @property {string} [httpUrl='http://localhost:3000'] - Base HTTP URL for API requests.\n * @property {string} [wsUrl='http://localhost:3000'] - Base WebSocket URL for room connections.\n *\n * @property {any} [publicData={}] - Public data to be shared with other clients in the room.\n * @property {Function} [verifyPublicData] - Callback for verifying the public data of other users.\n * @property {any} [privateData={}] - Private data to be shared with other clients in the room.\n * @property {Function} [verifyPrivateData] - Callback for verifying the private data of other users.\n *\n * @property {number} [messageBufferMaxCount=50] - The maximum number of messages to store in the buffer.\n * @property {number} [messageBufferMaxDuration=60000] - The maximum duration in milliseconds to store a message in the buffer.\n */\n\n/**\n * @typedef {Object} ConnectorAPI\n *\n * @property {Event} onConnection - Event for connection state change notifications.\n * @property {Event} onError - Event for error handling.\n * @property {Event} onMessage - Event for receiving messages.\n * @property {Event} onRoomJoin - Event for room join notifications.\n * @property {Event} onRoomLeave - Event for room leave notifications.\n * @property {Event} onUserJoin - Event for user join notifications.\n * @property {Event} onUserLeave - Event for user leave notifications.\n * @property {Event} onUserVerified - Event for user verified notifications.\n *\n * @property {Function} createRoom - Creates a new room and joins it.\n * @property {Function} closeRoom - Closes the room for all. Only allowed by the creator.\n * @property {Function} joinRoom - Joins an existing room.\n * @property {Function} leaveRoom - Leaves the current room.\n * @property {Function} messageRoom - Sends a message to the current room.\n *\n * @property {Function} kickUser - Removes a player's connection. Only allowed by the creator.\n */\n\n/**\n * Creates a connector for managing room-based WebSocket communication.\n *\n * @param {ConnectorOptions} [options={}] - Configuration options for the connector.\n * @returns {ConnectorAPI} Connector API with event handlers and room management methods.\n */\nexport const createClientConnector = (\n  options = {},\n) => {\n  const {\n    contentType = 'application/json',\n    deserializeMessage = JSON.parse,\n    serializeMessage = JSON.stringify,\n\n    createRoomEndpoint = '/create-room',\n    joinRoomEndpoint = '/join-room',\n\n    httpUrl = 'http://localhost:3000',\n    wsUrl = 'http://localhost:3000',\n\n    messageBufferMaxCount = 50,\n    messageBufferMaxDuration = 60 * 1000,\n  } = options\n\n  let _connectionState = CONNECTION_DISCONNECTED,\n    _creatorId,\n    _generatedKeys,\n    _keyGenerationPromise,\n    _myEncryptKeys,\n    _myExchangeKeys,\n    _myId,\n    _myPublicEncryptKey,\n    _myPublicSignKey,\n    _mySignKeys,\n    _privateData,\n    _privateDataVerify,\n    _publicData,\n    _publicDataVerify,\n    _roomCode,\n    _sharedKey,\n    _sharedMessagesBuffer = [],\n    _socket,\n    _userDerivedKeys = new Map(),\n    _userEncryptKeys = new Map(),\n    _userSignKeys = new Map(),\n    _userVerification = new Map(),\n    _userVerified = new Map()\n  const _generateMyKeys = (\n  ) => {\n    if (\n      !_generatedKeys\n      && !_keyGenerationPromise\n    ) {\n      _keyGenerationPromise = new Promise((\n        resolve,\n        reject,\n      ) => {\n        const worker = new Worker(\n          URL.createObjectURL(\n            new Blob([USER_KEY_GENERATOR,], {\n              type: 'text/javascript',\n            }),\n          ),\n        )\n\n        worker.addEventListener('message', (\n          event,\n        ) => {\n          if (event.data.success) {\n            _myEncryptKeys = event.data.myEncryptKeys\n            _mySignKeys = event.data.mySignKeys\n            _myExchangeKeys = event.data.myExchangeKeys\n            _myPublicEncryptKey = event.data.myPublicEncryptKey\n            _myPublicSignKey = event.data.myPublicSignKey\n\n            _generatedKeys = true\n            _keyGenerationPromise = null\n            resolve()\n          } else {\n            const error = new Error(event.data.error)\n            onError.dispatch({\n              error,\n            })\n            reject(error)\n          }\n          worker.terminate()\n        })\n\n        worker.addEventListener('error', (\n          error,\n        ) => {\n          onError.dispatch({\n            error,\n          })\n          reject(error)\n          worker.terminate()\n        })\n\n        worker.postMessage({\n          type: 'USER_KEYS',\n        })\n      })\n    }\n    return _keyGenerationPromise\n  }\n  // Start generating new keys.\n  _generateMyKeys()\n\n  const onError = createEvent()\n  const onMessage = createEvent()\n  const onRoomJoin = createEvent()\n  const onRoomLeave = createEvent()\n  const onUserJoin = createEvent()\n  const onUserLeave = createEvent()\n  const onUserVerified = createEvent()\n  const onUserVerificationCode = createEvent()\n  const onConnection = createEvent()\n\n  const _setConnectionState = (\n    state,\n  ) => {\n    if (_connectionState !== state) {\n      _connectionState = state\n      onConnection.dispatch({\n        state,\n      })\n    }\n  }\n\n  const _generateVerificationCode = async (\n    userId,\n  ) => {\n    const derivedKey = _userDerivedKeys.get(userId)\n    if (!derivedKey) {\n      return\n    }\n\n    _userVerification.set(\n      userId,\n      Array.from(\n        new Uint8Array(\n          await crypto.subtle.digest(\n            HASH_ALGORITHM,\n            new TextEncoder().encode(\n              _roomCode\n              + bufferToBase64(\n                await crypto.subtle.exportKey(\n                  'raw',\n                  derivedKey,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    )\n\n    onUserVerificationCode.dispatch({\n      userId,\n      code: getVerificationCode(userId),\n    })\n  }\n\n  /**\n   * Closes the current socket connection and resets the socket reference. This function should be called when leaving a room to ensure that the socket connection is properly closed and the state is cleaned up.\n   */\n  const leaveRoom = (\n  ) => {\n    if (\n      _connectionState === CONNECTION_DISCONNECTED\n      || _connectionState === CONNECTION_DISCONNECTING\n    ) {\n      return\n    }\n    _setConnectionState(CONNECTION_DISCONNECTING)\n\n    if (_socket) {\n      _socket.close()\n    }\n\n    _creatorId = _generatedKeys = _keyGenerationPromise = _myId = _myEncryptKeys = _myExchangeKeys = _myPublicEncryptKey = _myPublicSignKey = _mySignKeys = _privateData = _privateDataVerify = _publicData = _publicDataVerify = _sharedKey = _sharedMessagesBuffer = _socket = null\n    _userDerivedKeys.clear()\n    _userEncryptKeys.clear()\n    _userSignKeys.clear()\n    _userVerification.clear()\n    _userVerified.clear()\n\n    // Setup new keys right away.\n    _generateMyKeys()\n\n    _setConnectionState(CONNECTION_DISCONNECTED)\n  }\n  const kickUser = (\n    userId,\n  ) => messageServer({\n    type: USER_KICK,\n    userId,\n  })\n\n  /**\n   * Joins a WebSocket room with the specified room code and optional credentials. Establishes a WebSocket connection to the server, appending the room code, password, and creator secret (if provided) as query parameters. Sets up event listeners for 'close', 'error', and 'message' events to handle room leave, errors, and incoming messages.\n   *\n   * @param {string} roomCode - The code of the room to join.\n   * @param {string|null} [password=null] - Optional password for the room.\n   * @param {string|null} [creatorSecret=null] - Optional creator secret for verifying this user is the creator of the room.\n   */\n  const _joinRoom = (\n    roomCode,\n    creatorSecret = null,\n  ) => {\n    if (\n      !creatorSecret\n      && _connectionState\n      && _connectionState !== CONNECTION_DISCONNECTED\n    ) {\n      return\n    }\n    _setConnectionState(CONNECTION_CONNECTING)\n\n    _roomCode = roomCode\n\n    const url = new URL(\n      wsUrl + joinRoomEndpoint,\n    )\n    url.searchParams.append(\n      'code',\n      _roomCode,\n    )\n    if (creatorSecret) {\n      url.searchParams.append(\n        'creator',\n        creatorSecret,\n      )\n    }\n\n    _socket = new WebSocket(\n      url.toString(),\n    )\n\n    _socket.addEventListener('close', (\n      event,\n    ) => {\n      onRoomLeave.dispatch({\n        event,\n      })\n\n      leaveRoom()\n    })\n\n    _socket.addEventListener('error', (\n      event,\n    ) => {\n      onError.dispatch({\n        event,\n      })\n      leaveRoom()\n    })\n\n    _socket.addEventListener('message', async (\n      event,\n    ) => {\n      _processMessage(\n        decode(\n          event.data,\n          base64ToString,\n        ),\n        event.data,\n      )\n    })\n  }\n\n  const _processMessage = async (\n    parts,\n    raw,\n    isBuffered = false,\n  ) => {\n    const {\n      [SERVER_PAYLOAD]: serverPayload,\n      [SERVER_TIME]: serverTime,\n\n      [SHARED_ENCRYPTION_IV]: sharedEncryptionIv,\n      [SHARED_ENCRYPTION_PAYLOAD]: sharedEncryptionPayload,\n\n      [USER_DIRECT_PAYLOAD]: userDirectPayload,\n      [USER_ENCRYPTION_IV]: userEncryptionIv,\n      [USER_ENCRYPTION_KEY]: userEncryptionKey,\n      [USER_ENCRYPTION_PAYLOAD]: userEncryptionPayload,\n      [USER_ENCRYPTION_SIGNATURE]: userEncryptionSignature,\n      [USER]: userReceiver,\n    } = parts\n\n    let data,\n      deserializedData,\n      payload,\n      wasEncrypted\n\n    if (serverPayload) {\n      payload = serverPayload\n    } else if (userDirectPayload) {\n      payload = userDirectPayload\n    } else {\n      payload = raw\n    }\n\n    if (sharedEncryptionPayload) {\n      if (\n        !_sharedKey\n        || (\n          !isBuffered\n          && _sharedMessagesBuffer.length > 0\n        )\n      ) {\n        // Can't decrypt without the key, store the messages for later.\n        _sharedMessagesBuffer.push({\n          time: Date.now(),\n          parts,\n          raw,\n        })\n\n        // Remove oldest message if buffer is full.\n        if (_sharedMessagesBuffer.length > messageBufferMaxCount) {\n          _sharedMessagesBuffer.shift()\n        }\n        return\n      }\n      if (!sharedEncryptionIv) {\n        onError.dispatch(\n          new Error('Missing IV to decrypt message')\n        )\n        return\n      }\n\n      data = await crypto.subtle.decrypt(\n        {\n          iv: base64ToBuffer(sharedEncryptionIv),\n          name: SHARED_ENCRYPTION_ALGORITHM,\n        },\n        _sharedKey,\n        base64ToBuffer(sharedEncryptionPayload),\n      )\n      data = new TextDecoder().decode(data)\n      wasEncrypted = true\n    } else if (userEncryptionPayload) {\n      if (\n        !userEncryptionKey\n        || !userEncryptionIv\n      ) {\n        // Assume the message is not encrypted just send as a user specific message.\n        onError.dispatch({\n          error: new Error('Missing signature or IV to decrypt message.'),\n        })\n        return\n      }\n      if (!_generatedKeys) {\n        await _generateMyKeys()\n      }\n\n      const encryptedPayload = base64ToBuffer(userEncryptionPayload)\n      const payloadData = deserializeMessage(\n        new TextDecoder()\n          .decode(\n            await crypto.subtle.decrypt(\n              {\n                iv: base64ToBuffer(userEncryptionIv),\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              await crypto.subtle.importKey(\n                'raw',\n                await crypto.subtle.decrypt(\n                  {\n                    name: USER_ENCRYPTION_ALGORITHM,\n                  },\n                  _myEncryptKeys.privateKey,\n                  base64ToBuffer(userEncryptionKey),\n                ),\n                {\n                  name: SHARED_ENCRYPTION_ALGORITHM,\n                },\n                true,\n                ['encrypt', 'decrypt',],\n              ),\n              encryptedPayload\n            ),\n          ),\n      )\n      wasEncrypted = true\n\n      if (payloadData.type === EXCHANGE_1) {\n        // We can't check the signature because we don't have the sender's public key yet.\n        deserializedData = payloadData\n      } else if (userEncryptionSignature) {\n        const senderId = payloadData.sender\n\n        if (!senderId) {\n          onError.dispatch({\n            error: new Error('Message from unknown sender'),\n          })\n          return\n        }\n\n        const senderPublicKey = _userSignKeys.get(senderId)\n        if (!senderPublicKey) {\n          onError.dispatch({\n            error: new Error('No public key for ' + senderId),\n          })\n          return\n        }\n\n        if (\n          !(await crypto.subtle.verify(\n            USER_SIGNATURE_ALGORITHM,\n            senderPublicKey,\n            base64ToBuffer(userEncryptionSignature),\n            encryptedPayload,\n          ))\n        ) {\n          onError.dispatch({\n            error: new Error('Invalid signature from ' + senderId),\n          })\n          return\n        }\n\n        deserializedData = payloadData\n      } else {\n        onError.dispatch({\n          error: new Error('Missing encryption signature'),\n        })\n        return\n      }\n    } else {\n      data = payload\n    }\n\n    if (!deserializedData) {\n      try {\n        deserializedData = deserializeMessage(data)\n      } catch (error) {\n        onError.dispatch({\n          error: new Error('Failed to parse message ' + raw),\n        })\n        return\n      }\n    }\n    data = deserializedData\n\n    switch (data.type) {\n      case ROOM_JOINED:\n        _creatorId = data.creatorId\n        _myId = data.userId\n\n        onRoomJoin.dispatch({\n          creatorId: data.creatorId,\n          roomCode: _roomCode,\n          userId: data.userId,\n          users: data.users,\n        })\n\n        if (_myId === _creatorId) {\n          _setConnectionState(CONNECTION_CONNECTED)\n        } else {\n          _setConnectionState(CONNECTION_PENDING_VERIFICATION)\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          const myPublicExchangeKey = await crypto.subtle.exportKey(\n            DIFFIE_HELLMAN_EXPORT_FORMAT,\n            _myExchangeKeys.publicKey,\n          )\n\n          _message({\n            type: EXCHANGE_0,\n            publicData: (\n              typeof(_publicData) === 'function'\n                ? _publicData()\n                : _publicData\n            ),\n            publicEncryptKey: bufferToBase64(_myPublicEncryptKey),\n            publicExchangeKey: bufferToBase64(myPublicExchangeKey),\n            publicSignKey: bufferToBase64(_myPublicSignKey),\n            // Explicitly add signature manually.\n            signature: bufferToBase64(\n              await crypto.subtle.sign(\n                USER_SIGNATURE_ALGORITHM,\n                _mySignKeys.privateKey,\n                myPublicExchangeKey,\n              ),\n            ),\n          }, {\n            allowUnencrypted: true,\n            receiver: _creatorId,\n          })\n        }\n        break\n\n      case EXCHANGE_0:\n        if (\n          userReceiver === _creatorId\n          && _myId === _creatorId\n        ) {\n          const newUserId = data.sender\n\n          if (\n            _publicDataVerify\n            && !_publicDataVerify({\n              data: data.publicData,\n              userId: newUserId,\n            })\n          ) {\n            kickUser(newUserId)\n            return\n          }\n\n          _userEncryptKeys.set(\n            newUserId,\n            await crypto.subtle.importKey(\n              PUBLIC_KEY_EXPORT_FORMAT,\n              base64ToBuffer(data.publicEncryptKey),\n              {\n                hash: HASH_ALGORITHM,\n                name: USER_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt',],\n            ),\n          )\n\n          const publicSignKey = await crypto.subtle.importKey(\n            PUBLIC_KEY_EXPORT_FORMAT,\n            base64ToBuffer(data.publicSignKey),\n            {\n              hash: HASH_ALGORITHM,\n              name: USER_SIGNATURE_ALGORITHM,\n            },\n            true,\n            ['verify',],\n          )\n\n          const publicExchangeKeyData = base64ToBuffer(\n            data.publicExchangeKey,\n          )\n          if (!(await crypto.subtle.verify(\n            USER_SIGNATURE_ALGORITHM,\n            publicSignKey,\n            base64ToBuffer(data.signature),\n            publicExchangeKeyData,\n          ))) {\n            onError.dispatch({\n              error: new Error('Invalid signature for exchange from ' + newUserId),\n            })\n            return\n          }\n\n          _userSignKeys.set(newUserId, publicSignKey)\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          _userDerivedKeys.set(\n            newUserId,\n            await crypto.subtle.deriveKey(\n              {\n                name: DIFFIE_HELLMAN_ALGORITHM,\n                public: await crypto.subtle.importKey(\n                  DIFFIE_HELLMAN_EXPORT_FORMAT,\n                  publicExchangeKeyData,\n                  {\n                    name: DIFFIE_HELLMAN_ALGORITHM,\n                    namedCurve: DIFFIE_HELLMAN_CURVE,\n                  },\n                  true,\n                  [],\n                ),\n              },\n              _myExchangeKeys.privateKey,\n              {\n                length: SHARED_KEY_LENGTH,\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt', 'decrypt',],\n            ),\n          )\n\n          const myPublicExchangeKey = await crypto.subtle.exportKey(\n            DIFFIE_HELLMAN_EXPORT_FORMAT,\n            _myExchangeKeys.publicKey,\n          )\n          _message({\n            type: EXCHANGE_1,\n            publicData: (\n              typeof(_publicData) === 'function'\n                ? _publicData()\n                : _publicData\n            ),\n            publicEncryptKey: bufferToBase64(_myPublicEncryptKey),\n            publicExchangeKey: bufferToBase64(myPublicExchangeKey),\n            publicSignKey: bufferToBase64(_myPublicSignKey),\n          }, {\n            receiver: newUserId,\n          })\n\n          _generateVerificationCode(newUserId)\n        }\n        break\n\n      case EXCHANGE_1:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (\n            _publicDataVerify\n            && !_publicDataVerify({\n              data: data.publicData,\n              userId: _creatorId,\n            })\n          ) {\n            leaveRoom()\n            return\n          }\n\n          const hostPublicSignKey = await crypto.subtle.importKey(\n            PUBLIC_KEY_EXPORT_FORMAT,\n            base64ToBuffer(data.publicSignKey),\n            {\n              hash: HASH_ALGORITHM,\n              name: USER_SIGNATURE_ALGORITHM,\n            },\n            true,\n            ['verify',],\n          )\n\n          if (\n            data.publicExchangeKey\n            && data.signature\n          ) {\n            if (!(await crypto.subtle.verify(\n              USER_SIGNATURE_ALGORITHM,\n              hostPublicSignKey,\n              base64ToBuffer(data.signature),\n              base64ToBuffer(data.publicExchangeKey),\n            ))) {\n              onError.dispatch({\n                error: new Error('Invalid signature for exchange from ' + _creatorId),\n              })\n              leaveRoom()\n              return\n            }\n          }\n          _userSignKeys.set(\n            _creatorId,\n            hostPublicSignKey,\n          )\n\n          _userEncryptKeys.set(\n            _creatorId,\n            await crypto.subtle.importKey(\n              PUBLIC_KEY_EXPORT_FORMAT,\n              base64ToBuffer(data.publicEncryptKey),\n              {\n                hash: HASH_ALGORITHM,\n                name: USER_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt',],\n            ),\n          )\n\n          if (!_generatedKeys) {\n            await _generateMyKeys()\n          }\n\n          _userDerivedKeys.set(\n            _creatorId,\n            await crypto.subtle.deriveKey(\n              {\n                name: DIFFIE_HELLMAN_ALGORITHM,\n                public: await crypto.subtle.importKey(\n                  DIFFIE_HELLMAN_EXPORT_FORMAT,\n                  base64ToBuffer(data.publicExchangeKey),\n                  {\n                    name: DIFFIE_HELLMAN_ALGORITHM,\n                    namedCurve: DIFFIE_HELLMAN_CURVE,\n                  },\n                  true,\n                  [],\n                ),\n              },\n              _myExchangeKeys.privateKey,\n              {\n                length: SHARED_KEY_LENGTH,\n                name: SHARED_ENCRYPTION_ALGORITHM,\n              },\n              true,\n              ['encrypt', 'decrypt',],\n            )\n          )\n\n          _generateVerificationCode(_creatorId)\n        }\n        break\n\n      case EXCHANGE_2:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (!wasEncrypted) {\n            onError.dispatch({\n              error: new Error('Message was not encrypted'),\n            })\n            return\n          }\n\n          if (\n            _privateDataVerify\n            && !_privateDataVerify({\n              data: data.privateData,\n              userId: _creatorId,\n            })\n          ) {\n            leaveRoom()\n            return\n          }\n\n          _message({\n            type: EXCHANGE_3,\n            privateData: _privateData,\n          }, {\n            receiver: _creatorId,\n          })\n        }\n        break\n\n      case EXCHANGE_3:\n        if (\n          userReceiver === _creatorId\n          && _myId === _creatorId\n        ) {\n          if (!wasEncrypted) {\n            onError.dispatch({\n              error: new Error('Message was not encrypted'),\n            })\n            return\n          }\n          const userId = data.sender\n\n          if (!_userVerified.get(userId)) {\n            onError.dispatch({\n              error: new Error('User not verified'),\n            })\n            kickUser(userId)\n            return\n          }\n\n          if (\n            _privateDataVerify\n            && !_privateDataVerify({\n              data: data.privateData,\n              userId,\n            })\n          ) {\n            kickUser(userId)\n            return\n          }\n\n          _message({\n            type: EXCHANGE_4,\n            sharedKey: bufferToBase64(\n              await crypto.subtle.exportKey(\n                'raw',\n                _sharedKey,\n              ),\n            ),\n          }, {\n            receiver: userId,\n          })\n\n          onUserVerified.dispatch({\n            userId,\n          })\n          messageServer({\n            type: USER_VERIFIED,\n            userId,\n          })\n        }\n        break\n\n      case EXCHANGE_4:\n        if (\n          userReceiver === _myId\n          && data.sender === _creatorId\n        ) {\n          if (!wasEncrypted) {\n            onError.dispatch({\n              error: new Error('Message was not encrypted'),\n            })\n            return\n          }\n\n          _sharedKey = await crypto.subtle.importKey(\n            'raw',\n            base64ToBuffer(\n              data.sharedKey,\n            ),\n            {\n              name: SHARED_ENCRYPTION_ALGORITHM,\n            },\n            true,\n            ['encrypt', 'decrypt',],\n          )\n\n          onUserVerified.dispatch({\n            userId: _myId,\n          })\n\n          // Replay stored messages to catch up.\n          if (_sharedMessagesBuffer.length > 0) {\n            const now = Date.now()\n            _sharedMessagesBuffer = _sharedMessagesBuffer.filter((item) => (\n              now - item.time < messageBufferMaxDuration\n            ))\n\n            while (_sharedMessagesBuffer.length > 0) {\n              const {\n                parts,\n                raw,\n              } = _sharedMessagesBuffer.shift()\n              _processMessage(\n                parts,\n                raw,\n                true,\n              )\n            }\n          }\n\n          _setConnectionState(CONNECTION_CONNECTED)\n        }\n      break\n\n      case USER_LEFT:\n        onUserLeave.dispatch({\n          userId: data.userId,\n        })\n        _userDerivedKeys.delete(data.userId)\n        _userEncryptKeys.delete(data.userId)\n        _userSignKeys.delete(data.userId)\n        break\n\n      case USER_JOINED:\n        onUserJoin.dispatch({\n          userId: data.userId,\n        })\n        break\n\n      case USER_VERIFIED:\n        onUserVerified.dispatch({\n          userId: data.userId,\n        })\n        break\n\n      default:\n        if (!wasEncrypted) {\n          onError.dispatch({\n            error: new Error('Message was not encrypted'),\n          })\n          return\n        }\n\n        onMessage.dispatch({\n          data,\n          time: calculateTime(\n            serverTime,\n            data?.senderTime,\n          ),\n        })\n        break\n    }\n  }\n\n  const _message = async (\n    data,\n    options = {},\n  ) => {\n    if (\n      !_socket\n      || _socket.readyState !== WebSocket.OPEN\n    ) {\n      onError.dispatch({\n        error: new Error('No open socket'),\n      })\n      return false\n    }\n\n    const message = serializeMessage({\n      ...data,\n      sender: _myId,\n      senderTime: Date.now(),\n    })\n    const parts = {}\n\n    const receiver = options.receiver\n    if (receiver) {\n      const receiverPublicKey = _userEncryptKeys.get(receiver)\n      if (receiverPublicKey) {\n        // Create a temporary symmetric encryption key that is only used once since asymmetric encryption is slower.\n        const tempKey = await crypto.subtle.generateKey(\n          {\n            name: SHARED_ENCRYPTION_ALGORITHM,\n            length: 256,\n          },\n          true,\n          ['encrypt', 'decrypt',],\n        )\n        const iv = crypto.getRandomValues(\n          new Uint8Array(12),\n        )\n        const encryptedPayload = await crypto.subtle.encrypt(\n          {\n            iv,\n            name: SHARED_ENCRYPTION_ALGORITHM,\n          },\n          tempKey,\n          new TextEncoder().encode(message),\n        )\n\n        if (!_generatedKeys) {\n          await _generateMyKeys()\n        }\n\n        parts[USER_ENCRYPTION_IV] = bufferToBase64(iv)\n        parts[USER_ENCRYPTION_KEY] = bufferToBase64(\n          await crypto.subtle.encrypt(\n            {\n              name: USER_ENCRYPTION_ALGORITHM,\n            },\n            receiverPublicKey,\n            await crypto.subtle.exportKey(\n              'raw',\n              tempKey,\n            ),\n          ),\n        )\n        parts[USER_ENCRYPTION_PAYLOAD] = bufferToBase64(encryptedPayload)\n        parts[USER_ENCRYPTION_SIGNATURE] = bufferToBase64(\n          await crypto.subtle.sign(\n            USER_SIGNATURE_ALGORITHM,\n            _mySignKeys.privateKey,\n            encryptedPayload,\n          ),\n        )\n      } else if (!options.allowUnencrypted) {\n        onError.dispatch({\n          error: new Error('No public key for ' + receiver),\n        })\n        return false\n      } else {\n        parts[USER_DIRECT_PAYLOAD] = message\n      }\n\n      parts[USER] = receiver\n    } else if (options.server) {\n      parts[SERVER_PAYLOAD] = message\n    } else if (_sharedKey) {\n      const iv = crypto.getRandomValues(\n        new Uint8Array(12),\n      )\n\n      parts[SHARED_ENCRYPTION_IV] = bufferToBase64(iv)\n      parts[SHARED_ENCRYPTION_PAYLOAD] = bufferToBase64(\n        await crypto.subtle.encrypt(\n          {\n            iv,\n            name: SHARED_ENCRYPTION_ALGORITHM,\n          },\n          _sharedKey,\n          new TextEncoder().encode(message),\n        ),\n      )\n    } else {\n      onError.dispatch(\n        new Error('Trying to send without valid destination')\n      )\n      return false\n    }\n\n    _socket.send(\n      encode(\n        parts,\n        stringToBase64,\n      ),\n    )\n    return true\n  }\n\n  const messageServer = (\n    data,\n  ) => (\n    _myId\n    && _myId === _creatorId\n    && _message(data, {\n      server: true,\n    })\n  )\n  const messageUser = (\n    data,\n    userId,\n  ) => (\n    userId\n    && _message(data, {\n      receiver: userId,\n    })\n  )\n\n  const getVerificationCode = (\n    userId,\n    codeLength = 6,\n  ) => {\n    if (!_userVerification.has(userId)) {\n      return false\n    }\n    const hashArray = _userVerification.get(userId)\n    let code = ''\n    for (let i = 0; i < codeLength; i++) {\n      const index = hashArray[i] % IDENTIFIABLE_CHARACTERS.length\n      code += IDENTIFIABLE_CHARACTERS[index]\n    }\n    return code\n  }\n\n  return {\n    onConnection,\n    onError,\n    onMessage,\n\n    onRoomJoin,\n    onRoomLeave,\n\n    onUserJoin,\n    onUserLeave,\n    onUserVerified,\n    onUserVerificationCode,\n\n    messageRoom: (\n      data,\n    ) => _message(data),\n    messageServer,\n    messageUser,\n\n    closeRoom: (\n    ) => messageServer({\n      type: ROOM_CLOSED,\n    }),\n    createRoom: async (\n      options = {},\n    ) => {\n      if (\n        _connectionState\n        && _connectionState !== CONNECTION_DISCONNECTED\n      ) {\n        return\n      }\n      _setConnectionState(CONNECTION_CONNECTING)\n\n      if (options.publicData) {\n        _publicData = options.publicData\n      }\n      if (options.verifyPublicData) {\n        _publicDataVerify = options.verifyPublicData\n      }\n\n      try {\n        await new Promise((\n          resolve,\n          reject,\n        ) => {\n          const worker = new Worker(\n            URL.createObjectURL(\n              new Blob([SHARED_KEY_GENERATOR,], {\n                type: 'text/javascript',\n              }),\n            ),\n          )\n\n          worker.addEventListener('message', (\n            event,\n          ) => {\n            if (event.data.success) {\n              _sharedKey = event.data.sharedKey\n              resolve()\n            } else {\n              reject(\n                new Error(event.data.error)\n              )\n            }\n            worker.terminate()\n          })\n\n          worker.addEventListener('error', (\n            error,\n          ) => {\n            reject(error)\n            worker.terminate()\n          })\n\n          worker.postMessage({\n            type: 'SHARED_KEY',\n          })\n        })\n      } catch (error) {\n        _setConnectionState(CONNECTION_DISCONNECTED)\n        onError.dispatch({\n          error,\n        })\n        return\n      }\n\n      const url = new URL(\n        httpUrl\n        + createRoomEndpoint\n      )\n      if (options.limit) {\n        url.searchParams.append(\n          'limit',\n          options.limit,\n        )\n      }\n\n      const response = await fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          Accept: contentType,\n        },\n      })\n      if (!response.ok) {\n        throw new Error('Failed to create room')\n      }\n\n      let data = await response.text()\n      data = deserializeMessage(data)\n\n      _myId = data.userId\n\n      _joinRoom(\n        data.roomCode,\n        data.creatorSecret,\n      )\n\n      return data\n    },\n    joinRoom: (\n      roomCode,\n      options = {},\n    ) => {\n      if (options.publicData) {\n        _publicData = options.publicData\n      }\n      if (options.verifyPublicData) {\n        _publicDataVerify = options.verifyPublicData\n      }\n      _joinRoom(\n        roomCode,\n      )\n    },\n    leaveRoom,\n    kickUser,\n\n    getVerificationCode,\n    verifyUser: async (\n      userId,\n      code,\n    ) => {\n      if (\n        _myId !== _creatorId\n        || !code\n      ) {\n        return false\n      }\n\n      const expectedCode = getVerificationCode(\n        userId,\n        code.length,\n      )\n      if (\n        !expectedCode\n        || !code\n        || expectedCode !== code\n      ) {\n        return false\n      }\n      _userVerified.set(userId, true)\n\n      const derivedKey = _userDerivedKeys.get(userId)\n      if (!derivedKey) {\n        return false\n      }\n\n      _message({\n        type: EXCHANGE_2,\n        privateData: _privateData,\n      }, {\n        receiver: userId,\n      })\n\n      return true\n    },\n  }\n}\n",
    "/**\n * Creates a deep clone of a javascript value.\n *\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n",
    "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\n\n/**\n * @typedef {Object} Change A change to a state object.\n * @property {'delete' | 'set'} type The type of change.\n * @property {string[]} path The path to the value that changed.\n * @property {*} [new] The new value.\n * @property {*} [old] The old value.\n */\n\n/**\n * Function to set a value at a given path.\n *\n * @param {Record<string, any>} record The record to update.\n * @param {string[]} path The path to the value to update.\n * @param {*} value The new value.\n */\nconst setValueAtPath = (\n  record,\n  path,\n  value,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n  current[path[path.length - 1]] = cloneRecursive(value)\n}\n\n/**\n * Function to delete a value at a given path.\n *\n * @param {Record<string, any>} record The record to update.\n * @param {string[]} path The path to the value to delete.\n */\nconst deleteValueAtPath = (\n  record,\n  path,\n) => {\n  let current = record\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]]\n    if (!current) {\n      // Path doesn't exist, so nothing to delete.\n      return\n    }\n  }\n  if (Array.isArray(current)) {\n    current.splice(parseInt(path[path.length - 1]), 1)\n  } else {\n    delete current[path[path.length - 1]]\n  }\n}\n\n/**\n * Determine the differences between two objects.\n *\n * @param {Record<string, any>} before The object before the change.\n * @param {Record<string, any>} after The object after the change.\n * @param {string[]} [path=[]] The path to the current object.\n * @returns {Change[]} The changes between the two objects.\n */\nexport const determineDiff = (\n  before,\n  after,\n  path = [],\n) => {\n  const changes = []\n\n  // Check for keys in the \"before\" object that are not in \"after\".\n  for (const key in before) {\n    const currentPath = [...path, key]\n\n    if (!(key in after)) {\n      changes.unshift({\n        type: 'delete',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n      })\n    } else if (\n      typeof before[key] === 'object'\n      && typeof after[key] === 'object'\n    ) {\n      // If both are objects, recurse deeper.\n      changes.unshift(\n        ...determineDiff(before[key], after[key], currentPath),\n      )\n    } else if (before[key] !== after[key]) {\n      // If the value has changed, record the new and old value.\n      changes.unshift({\n        type: 'set',\n        path: currentPath,\n        old: cloneRecursive(before[key]),\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  // Check for keys in the \"after\" object that were not in \"before\".\n  for (const key in after) {\n    if (!(key in before)) {\n      changes.unshift({\n        type: 'set',\n        path: [...path, key],\n        new: cloneRecursive(after[key]),\n      })\n    }\n  }\n\n  return changes\n}\n\n/**\n * Apply a diff to a state object.\n *\n * @param {Record<string, any>} state The state object to update.\n * @param {Change[]} diff The diff to apply.\n * @returns {Record<string, any>} The updated state object.\n */\nexport const applyDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      setValueAtPath(state, change.path, change.new)\n    } else if (change.type === 'delete') {\n      deleteValueAtPath(state, change.path)\n    }\n  }\n  return state\n}\n\n/**\n * Revert a diff on a state object.\n *\n * @param {Record<string, any>} state The state object to revert.\n * @param {Change[]} diff The diff to revert.\n * @returns {Record<string, any>} The updated state object.\n */\nexport const revertDiff = (\n  state,\n  diff,\n) => {\n  for (const change of diff) {\n    if (change.type === 'set') {\n      if (change.old === undefined) {\n        deleteValueAtPath(state, change.path)\n      } else {\n        setValueAtPath(state, change.path, change.old)\n      }\n    } else if (change.type === 'delete') {\n      setValueAtPath(state, change.path, change.old)\n    }\n  }\n  return state\n}\n",
    "import {\n    applyDiff,\n    cloneRecursive,\n    determineDiff,\n    revertDiff,\n} from '@doars/tiedliene'\n\nimport {\n    createClientConnector\n} from './client-connector.js'\nimport {\n    STATE_SYNCH,\n    STATE_UPDATE,\n} from './message-types.js'\n\nimport {\n    generateCode,\n} from '../utilities/code.js'\n\n/**\n * @typedef {import('../utilities/event.js').Event} Event\n */\n\n/**\n * Options for creating a synchronizer.\n * @typedef {Object} createClientSynchronizerOptions\n *\n * @property {string} [createRoomEndpoint='/create-room'] - HTTP endpoint for creating a room.\n * @property {string} [joinRoomEndpoint='/join-room'] - WebSocket endpoint for joining a room.\n *\n * @property {string} [contentType='application/json'] - Content-Type for HTTP requests.\n * @property {Function} [deserializeMessage=JSON.parse] - Function to deserialize incoming messages.\n * @property {Function} [serializeMessage=JSON.stringify] - Function to serialize outgoing messages.\n *\n * @property {string} [httpUrl='http://localhost:3000'] - Base HTTP URL for API requests.\n * @property {string} [wsUrl='http://localhost:3000'] - Base WebSocket URL for room connections.\n *\n * @property {any} [publicData={}] - Public data to be shared with other clients in the room.\n * @property {Function} [verifyPublicData] - Callback for verifying the public data of other users.\n * @property {any} [privateData={}] - Private data to be shared with other clients in the room.\n * @property {Function} [verifyPrivateData] - Callback for verifying the private data of other users.\n *\n * @property {number} [messageBufferMaxCount=50] - The maximum number of messages to store in the buffer.\n * @property {number} [messageBufferMaxDuration=60000] - The maximum duration in milliseconds to store a message in the buffer.\n *\n * @property {number} [windowPerUser=16] - Number of state updates to keep per joined user. Used in case of rollbacks.\n * @property {number} [synchronisationInterval=60000] - Interval in milliseconds for a full state synchronisation.\n */\n\n/**\n * The object returned by createClientSynchronizer.\n * @typedef {Object} Synchronizer\n *\n * @property {Event} onConnection - Event for connection state change notifications.\n * @property {Event} onError - Event for error handling.\n * @property {Event} onMessage - Event for receiving messages.\n * @property {Event} onRoomJoin - Event for room join notifications.\n * @property {Event} onRoomLeave - Event for room leave notifications.\n * @property {Event} onUserJoin - Event for user join notifications.\n * @property {Event} onUserLeave - Event for user leave notifications.\n * @property {Event} onUserVerified - Event for user verified notifications.\n * @property {Event} onUserVerificationCode - Event for verification code ready notifications.\n *\n * @property {Object} privateState - Internal state, including user and room information.\n * @property {Object} publicState - Shared state object synchronized across users.\n *\n * @property {Function} getConnectionState - Get the current connection state.\n *\n * @property {Function} closeRoom - Closes the room for all. Only allowed by the creator.\n * @property {Function} createRoom - Creates a new room and joins it.\n * @property {Function} joinRoom - Joins an existing room.\n * @property {Function} leaveRoom - Leaves the current room.\n * @property {Function} messageRoom - Sends a message to the current room.\n *\n * @property {Function} kickUser - Remove's a player's connection. Only allowed by the creator.\n *\n * @property {Function} sendUpdate - Sends the current state delta to other users.\n */\n\n/**\n * Creates a synchronizer for collaborative state management across users in a room.\n *\n * @param {createClientSynchronizerOptions} [options={}] - Configuration options for the synchronizer.\n * @param {Object} [privateState={}] - Internal state object for private data.\n * @param {Object} [publicState={}] - Shared state object to be synchronized.\n * @returns {Synchronizer} The synchronizer instance with state and synchronization methods.\n */\nexport const createClientSynchronizer = (\n  options = {},\n  privateState = {},\n  publicState = {},\n) => {\n  const connector = createClientConnector(options)\n  const {\n    messageRoom,\n  } = connector\n\n  const {\n    windowPerUser = 16,\n    synchronisationInterval = 60 * 1e3,\n  } = options\n  const _stateUpdates = []\n  let _synchronisationIntervalId,\n    _messageDelay = 0,\n    _messageOffset = 0,\n    _stateUpdatesWindow = windowPerUser\n\n  const _sendDelta = (\n    stateDelta,\n  ) => {\n    const identifier = generateCode()\n    const previous = (\n      stateDelta.length > 0\n        ? stateDelta[0].identifier\n        : null\n    )\n\n    // Store the update for reference later.\n    _stateUpdates.unshift({\n      identifier,\n      previous,\n      sender: privateState.userId,\n      stateDelta,\n      time: {\n        adjusted: (\n          Date.now()\n          + _messageDelay\n          - _messageOffset\n        ),\n      },\n    })\n    if (_stateUpdates.length > _stateUpdatesWindow) {\n      _stateUpdates.splice(\n        _stateUpdatesWindow,\n      )\n    }\n    messageRoom({\n      identifier,\n      previous,\n      stateDelta,\n      type: STATE_UPDATE,\n    })\n\n    _updatePreviousState()\n  }\n  const sendUpdate = (\n  ) => {\n    if (privateState.previousState) {\n      const stateDelta = determineDiff(\n        privateState.previousState,\n        publicState,\n      )\n      if (stateDelta.length > 0) {\n        _sendDelta(\n          stateDelta,\n        )\n      }\n    }\n  }\n\n  const _synchroniseState = (\n  ) => {\n    if (privateState.users.length > 1) {\n      messageRoom({\n        type: STATE_SYNCH,\n        state: cloneRecursive(\n          publicState,\n        ),\n      })\n    }\n  }\n\n  const _updatePreviousState = (\n  ) => {\n    privateState.previousState = cloneRecursive(\n      publicState,\n    )\n  }\n\n  connector.onMessage.addListener(({\n    data,\n    time,\n  }) => {\n    // Check if the message is not from yourself, or is not intended for the current user.\n    if (\n      data.sender === privateState.userId\n      || (\n        data.receiver\n        && data.receiver !== privateState.userId\n      )\n    ) {\n      return\n    }\n\n    // Update the estimated message delay and offset.\n    _messageDelay = (\n      _messageDelay\n      + time.delay\n    ) / 2\n    _messageOffset = (\n      _messageOffset\n      + time.offset\n    ) / 2\n\n    if (data.type === STATE_SYNCH) {\n      // Remove any state updates older than the given synch data.\n      let index = 0\n      for (; index < _stateUpdates.length; index++) {\n        const previousUpdate = _stateUpdates[index]\n        if (previousUpdate.time.adjusted >= time.adjusted) {\n          break\n        }\n      }\n      _stateUpdates.splice(0, index)\n\n      // Replace the existing state with the given state.\n      for (const key in publicState) {\n        delete publicState[key]\n      }\n      for (const key in data.state) {\n        publicState[key] = data.state[key]\n      }\n\n      // Apply any newer state updates.\n      for (let index = 0; index < _stateUpdates.length; index++) {\n        applyDiff(\n          publicState,\n          _stateUpdates[index].stateDelta,\n        )\n      }\n\n      _updatePreviousState()\n    } else if (data.type === STATE_UPDATE) {\n      let failedToInsert = true\n      for (let index = 0; index < _stateUpdates.length; index++) {\n        const previousUpdate = _stateUpdates[index]\n        if (\n          // If the update's identifier matches the data's previous, we can insert it here.\n          previousUpdate.identifier === data.previous\n          || (\n            // If the previous updates are the same. If the time of this update is newer than the previous one, we can insert it before the previous one.\n            previousUpdate.previous === data.previous\n            && previousUpdate.time.adjusted < time.adjusted\n          )\n        ) {\n          _stateUpdates.splice(index, 0, {\n            ...data,\n            time,\n          })\n          failedToInsert = false\n          break\n        }\n      }\n      if (failedToInsert) {\n        // If the update was not inserted just assume it will make sense later.\n        _stateUpdates.unshift({\n          ...data,\n          time,\n        })\n      }\n\n      // Undo the state until the new given diff is reached the apply the diff's in order.\n      for (let index = 0; index < _stateUpdates.length; index++) {\n        const update = _stateUpdates[index]\n        if (update.identifier === data.identifier) {\n          // We found the update, we can stop searching.\n          break\n        }\n        revertDiff(\n          publicState,\n          update.stateDelta,\n        )\n      }\n\n      // Redo the state including the new given diff.\n      for (let index = 0; index < _stateUpdates.length; index++) {\n        const update = _stateUpdates[index]\n        // Revert the previous state to the current state.\n        applyDiff(\n          publicState,\n          update.stateDelta,\n        )\n        if (update.identifier === data.identifier) {\n          // We found the update, we can stop searching.\n          break\n        }\n      }\n\n      _updatePreviousState()\n    }\n  })\n\n  connector.onConnection.addListener(({\n    state,\n  }) => {\n    privateState.connectionState = state\n  })\n\n  connector.onRoomJoin.addListener(({\n    creatorId,\n    roomCode,\n    userId,\n    users,\n  }) => {\n    // Set new room data.\n    privateState.creatorId = creatorId\n    privateState.roomCode = roomCode\n    privateState.userId = userId\n    privateState.users = users\n    privateState.verifiedUsers = []\n    privateState.previousState = cloneRecursive(\n      publicState,\n    )\n\n    if (userId === creatorId) {\n      privateState.verifiedUsers.push(userId)\n\n      // Let the creator send resynchronisation messages every once in a well to get all users in sync.\n      _synchronisationIntervalId = setInterval(\n        _synchroniseState,\n        synchronisationInterval,\n      )\n    }\n  })\n  connector.onRoomLeave.addListener((\n  ) => {\n    for (const key in privateState) {\n      delete privateState[key]\n    }\n    if (_synchronisationIntervalId) {\n      clearInterval(_synchronisationIntervalId)\n    }\n  })\n\n  connector.onUserJoin.addListener(({\n    userId,\n  }) => {\n    privateState.users.push(\n      userId,\n    )\n\n    // Update the amount state updates to store.\n    _stateUpdatesWindow = windowPerUser + (\n      windowPerUser * privateState.users.length\n    )\n  })\n  connector.onUserVerificationCode.addListener((\n    event\n  ) => {\n    if (event.userId === privateState.creatorId) {\n      privateState.verificationCode = event.code\n    }\n  })\n  connector.onUserVerified.addListener(({\n    userId,\n  }) => {\n    privateState.verifiedUsers.push(\n      userId,\n    )\n\n    // Update the amount state updates to store.\n    _stateUpdatesWindow = windowPerUser + (\n      windowPerUser * privateState.users.length\n    )\n\n    // Synchronise the state when a new user joins, if the user is the creator.\n    if (privateState.userId === privateState.creatorId) {\n      _synchroniseState()\n    }\n  })\n  connector.onUserLeave.addListener(({\n    userId,\n  }) => {\n    for (let index = 0; index < privateState.users.length; index++) {\n      if (privateState.users[index] === userId) {\n        privateState.users.splice(index, 1)\n        break\n      }\n    }\n    for (let index = 0; index < privateState.verifiedUsers.length; index++) {\n      if (privateState.verifiedUsers[index] === userId) {\n        privateState.verifiedUsers.splice(index, 1)\n        break\n      }\n    }\n\n    // Update the amount state updates to store.\n    _stateUpdatesWindow = windowPerUser + (\n      windowPerUser * privateState.users.length\n    )\n  })\n\n  return Object.assign({\n    privateState,\n    publicState,\n    sendUpdate,\n  }, connector)\n}\n",
    "/**\n * Example script demonstrating the usage of the `@doars/roupn` library with `@doars/staark` for real-time room-based synchronization and rendering. The UI is rendered using a declarative approach, with state-driven updates and event handlers for user interactions. This script mounts a UI to the provided `rootElement` and manages the state of a chat room, including:\n * - Creating and joining rooms\n * - Displaying users and their validation status\n * - Validating users as the room creator\n * - Sending and displaying messages in real-time\n * - Handling connection states (connected, connecting, disconnecting, pending verification)\n * - Leaving the room.\n *\n * @see {@link https://github.com/doars/roupn} for more information about `@doars/roupn`.\n * @see {@link https://github.com/doars/staark} for more information about `@doars/staark`.\n */\n\nimport {\n    conditional as c,\n    match as m,\n    mount,\n    node as n,\n} from '@doars/staark'\n\nimport {\n    createClientSynchronizer,\n} from '../src/index.js'\n\nimport {\n    CONNECTION_CONNECTED,\n    CONNECTION_CONNECTING,\n    CONNECTION_DISCONNECTING,\n    CONNECTION_PENDING_VERIFICATION,\n} from '../src/library/message-types.js'\n\n(function () {\n  let synchronizer = null\n\n  // Updates the verification code for a user as the creator types it in the input field.\n  const handleVerificationInput = (\n    event,\n    state,\n  ) => {\n    const userId = event.target.closest('li').getAttribute('data-user-id')\n    state.verificationCodes[userId] = event.target.value\n  }\n\n  // Submits the verification code for a user, triggering validation via the synchronizer.\n  const handleVerificationSubmit = (\n    event,\n    state,\n  ) => {\n    const userId = event.target.closest('li').getAttribute('data-user-id')\n    synchronizer.verifyUser(\n      userId,\n      state.verificationCodes[userId],\n    )\n  }\n\n  // Updates the current chat message as the user types in the textarea.\n  const handleMessageInput = (\n    event,\n    state,\n  ) => {\n    state.message = event.target.value\n  }\n\n  // Sends the current chat message to the room and clears the input field.\n  const handleMessageSubmit = (\n    _event,\n    state,\n  ) => {\n    state.publicState.messages.push({\n      message: state.message,\n      timestamp: Date.now(),\n      userId: state.privateState.userId,\n    })\n    state.message = null\n  }\n\n  // Requests the synchronizer to create a new room for the user.\n  const handleRoomCreate = (\n    _event,\n    _state,\n  ) => {\n    synchronizer.createRoom({\n      publicData: {\n        appName: 'example',\n      },\n      verifyPublicData: ({\n        userId,\n        data,\n      }) => {\n        console.log('Verify public user data:', userId, data)\n        return data.appName === 'example'\n      },\n      privateData: {\n        userKey: 'creator',\n      },\n      verifyPrivateData: ({ data, userId }) => {\n        console.log('Verify private user data:', userId, data)\n        return data.userKey === 'joiner'\n      },\n    })\n  }\n\n  // Requests the synchronizer to leave the current room.\n  const handleRoomLeave = (\n    _event,\n    _state,\n  ) => {\n    synchronizer.leaveRoom()\n  }\n\n  // Updates the room code as the user types it in the join room input field.\n  const handleRoomCodeInput = (\n    event,\n    state,\n  ) => {\n    state.roomCode = event.target.value\n  }\n\n  // Attempts to join a room using the entered room code, then clears the input.\n  const handleRoomCodeSubmit = (\n    _event,\n    state,\n  ) => {\n    synchronizer.joinRoom(\n      state.roomCode,\n      {\n        publicData: {\n          appName: 'example',\n        },\n        verifyPublicData: ({ data, userId }) => {\n          console.log('Verify public user data:', userId, data)\n          return data.appName === 'example'\n        },\n        privateData: {\n          userKey: 'joiner',\n        },\n        verifyPrivateData: ({ data, userId }) => {\n          console.log('Verify private user data:', userId, data)\n          return data.userKey === 'creator'\n        },\n      },\n    )\n    state.roomCode = ''\n  }\n\n  // Creates the root element for the application and appends it to the document body.\n  const rootElement = document.createElement('div')\n  rootElement.setAttribute('id', 'app')\n  document.body.appendChild(rootElement)\n\n  // Mounts the UI using staark, providing the state and a render function that describes the UI tree.\n  const [\n    _update,\n    _unmount,\n    state,\n  ] = mount(\n    rootElement,\n    (state) => {\n      // Notifies the synchronizer of state changes after each render.\n      synchronizer?.sendUpdate()\n\n      // Renders the UI based on the current connection state.\n      return [\n        n('h1', 'roupn example'),\n        ...m(state.privateState.connectionState,\n          {\n            [CONNECTION_CONNECTED]: () => [\n              // Shows the user's ID and the room code when connected.\n              n('p', [\n                'You are user ',\n                n('code', state.privateState.userId),\n                ' in room ',\n                n('code', state.privateState.roomCode),\n                '.',\n              ]),\n              n('hr'),\n\n              // Displays a list of users in the room, indicating their validation status.\n              n('p', 'Users in the room:'),\n              n('ul',\n                state.privateState.users.map((userId) => (\n                  n('li', [\n                    n('code', userId),\n                    ...c(\n                      state.privateState.verifiedUsers.includes(userId),\n                      () => n('span', ' (verified)'),\n                      () => n('span', ' (unverified)'),\n                    ),\n                  ])\n                )),\n              ),\n\n              // If the current user is the room creator, show UI to verify joining users.\n              ...c(\n                state.privateState.userId === state.privateState.creatorId,\n                () => {\n                  const unverifiedUsers = state.privateState.users.filter((userId) => !state.privateState.verifiedUsers.includes(userId))\n                  return c(\n                    unverifiedUsers.length > 0,\n                    () => [\n                      n('hr'),\n                      n('p', 'The following users need to be verified:'),\n                      n('ul',\n                        unverifiedUsers.map((userId) => (\n                          n('li', {\n                            'data-user-id': userId,\n                          }, [\n                            n('code', userId),\n                            n('label', {\n                              for: 'user-verification-code-input-' + userId,\n                            }, 'Verification code:'),\n                            n('input', {\n                              id: 'user-verification-code-input-' + userId,\n                              type: 'text',\n                              required: true,\n                              input: handleVerificationInput,\n                              value: state.verificationCodes[userId],\n                            }),\n                            n('button', {\n                              click: handleVerificationSubmit,\n                            }, 'Validate'),\n                          ])\n                        )),\n                      ),\n                    ]\n                  )\n                }\n              ),\n\n              n('hr'),\n\n              // Shows chat messages if present, otherwise displays a placeholder message.\n              ...c(state.publicState.messages.length,\n                () => [\n                  n('p', 'Messages in the room:'),\n                  n('ul',\n                    state.publicState.messages.map(\n                      (message) => (\n                        n('li', [\n                          ' (',\n                          n('time', {\n                            datetime: new Date(message.timestamp).toISOString(),\n                          }, new Date(message.timestamp).toLocaleString()),\n                          ') ',\n                          n('code', message.userId),\n                          ': ',\n                          n('span', message.message),\n                        ])\n                      ),\n                    ),\n                  ),\n                ],\n                () => n('p', 'No messages have been send yet.'),\n              ),\n\n              // Provides a textarea for composing messages and a button to send them.\n              n('label', {\n                for: 'message-input',\n              }, 'Message:'),\n              n('textarea', {\n                id: 'message-input',\n                type: 'text',\n                required: true,\n                input: handleMessageInput,\n              }, state.message),\n              n('button', {\n                click: handleMessageSubmit,\n              }, 'Send message'),\n\n              n('hr'),\n\n              // Allows the user to leave the room.\n              n('p', 'You can leave the room.'),\n              n('button', {\n                click: handleRoomLeave,\n              }, 'Leave room'),\n            ],\n            [CONNECTION_CONNECTING]: () => [\n              // Indicates that the client is connecting to a room.\n              n('p', 'Connecting to room...'),\n            ],\n            [CONNECTION_DISCONNECTING]: () => [\n              // Indicates that the client is disconnecting from a room.\n              n('p', 'Disconnecting from room...'),\n            ],\n            [CONNECTION_PENDING_VERIFICATION]: () => [\n              // Shows the verification code for the user to provide to the room creator.\n              n('p', [\n                'You are not yet verified, please provide the following code to the room creator: ',\n                n('code', state.privateState.verificationCode || 'Generating...'),\n              ]),\n            ],\n          },\n          // Default UI shown when not connected: options to create or join a room.\n          () => [\n            n('p', [\n              'This is a simple example of using ',\n              n('code', '@doars/roupn'),\n              '\\'s auto synchronizer in conjunction with ',\n              n('code', '@doars/staark'),\n              ' for rendering.',\n            ]),\n\n            n('hr'),\n\n            n('p', 'You can create a new room.'),\n            n('button', {\n              click: handleRoomCreate,\n            }, 'Create room'),\n\n            n('hr'),\n\n            n('p', 'Or join an existing room.'),\n            n('label', {\n              for: 'room-code-input',\n            }, 'Room code:'),\n            n('input', {\n              id: 'room-code-input',\n              type: 'text',\n              required: true,\n              input: handleRoomCodeInput,\n              value: state.roomCode,\n            }),\n            n('button', {\n              click: handleRoomCodeSubmit,\n            }, 'Join room'),\n          ],\n        ),\n      ]\n    },\n    {\n      // Initial state for the application, including message input, room code, and verification codes.\n      message: '',\n      roomCode: '',\n      verificationCodes: {},\n\n      privateState: {},\n      publicState: {\n        messages: [],\n      },\n    },\n  )\n\n  // Instantiates the synchronizer to manage real-time state synchronization between clients.\n  synchronizer = createClientSynchronizer(\n    {},\n    state.privateState,\n    state.publicState,\n  )\n\n  // Logs information from the synchronizer for debugging purposes.\n  synchronizer.onError.addListener((event) => {\n    console.warn('Error:', event)\n  })\n  // Logs all messages received from the synchronizer.\n  synchronizer.onMessage.addListener((event) => {\n    console.log('Message received:', event)\n  })\n  // Logs connection state changes.\n  synchronizer.onConnection.addListener((event) => {\n    console.log('Connection state received:', event)\n  })\n  // Logs when the client joins a room.\n  synchronizer.onRoomJoin.addListener((event) => {\n    console.log('Room joined:', event)\n  })\n  // Logs when the client leaves a room.\n  synchronizer.onRoomLeave.addListener((event) => {\n    console.log('Room left:', event)\n  })\n  // Logs when a new user joins the room.\n  synchronizer.onUserJoin.addListener((event) => {\n    console.log('User joined:', event)\n  })\n  // Logs when a user is verified by the creator.\n  synchronizer.onUserVerified.addListener((event) => {\n    console.log('User verified:', event)\n  })\n  // Logs when a user leaves the room.\n  synchronizer.onUserLeave.addListener((event) => {\n    console.log('User left:', event)\n  })\n}())\n"
  ],
  "mappings": "MAOO,IAAM,GAAW,CACtB,IACG,EAAoB,CAAI,GAAK,CAAC,EAStB,EAAsB,CACjC,IACG,EACH,MAAM,QAAQ,CAAI,EACd,EACA,CAAC,CAAI,EACP,OCTG,IAAM,GAAc,CACzB,EACA,EACA,IACG,CACH,IAAI,EACF,EACI,EACA,EAEN,GAAI,OAAQ,IAAY,WACtB,EAAS,EAAO,EAElB,OAAO,GAAS,CAAM,GCzBjB,IAAM,GAAS,ICiCf,IAAM,EAAO,CAClB,EACA,EACA,IACG,CACH,GACE,IAEE,OAAQ,IAA0B,UAC/B,EAAqB,IAAM,IAC3B,MAAM,QAAQ,CAAoB,GAGvC,EAAW,EACX,EAAuB,OAGzB,MAAO,CACL,EAAG,GACH,EAAG,EACH,EAAG,EAAoB,CAAQ,EAC/B,EAAG,CACL,GC3CK,IAAM,GAAQ,CACnB,EACA,EACA,IACG,CACH,IAAI,EACJ,GACE,GACI,KAAO,GACR,EAAO,GAEV,EAAS,EAAO,GAEhB,OAAS,EAEX,GAAI,OAAO,IAAW,WACpB,EAAS,EAAO,EAElB,OAAO,GAAS,CAAM,GC3BjB,IAAM,GAAiB,CAC5B,IACG,CACH,GAAI,OAAQ,IAAW,SAAU,CAC/B,IAAM,EACJ,MAAM,QAAQ,CAAK,EACf,CAAC,EACD,CAAC,EAEP,QAAW,KAAO,EAChB,EAAM,GAAO,GAAe,EAAM,EAAI,EAExC,OAAO,EAET,OAAO,GCbF,IAAM,GAAiB,CAC5B,EACA,IACG,CACH,GAAI,IAAW,EACb,MAAO,GAGT,GACE,CAAC,GACE,CAAC,GACD,OAAO,IAAW,UAClB,OAAO,IAAW,SAErB,OAAO,IAAW,EAGpB,GAAI,aAAkB,KACpB,OACE,aAAkB,MACf,EAAO,QAAQ,IAAM,EAAO,QAAQ,EAQ3C,IAAM,EAAO,OAAO,KAAK,CAAM,EAC/B,OACE,EAAK,SAAW,OAAO,KAAK,CAAM,EAAE,QACjC,EAAK,MAAM,KAAK,GAAe,EAAO,GAAI,EAAO,EAAE,CAAC,GCnBpD,IAAM,GAAkB,CAC7B,IACG,CACH,IAAM,EAAqB,CAAC,EAC5B,QAAW,KAAa,EAAQ,WAC9B,GAAI,aAAqB,KACvB,EAAmB,KACjB,EAAU,aAAe,EAC3B,EACK,KACL,IAAM,EAAa,CAAC,EACpB,QAAW,KAAa,EAAU,WAChC,EAAW,EAAU,MAAQ,EAAU,MAGzC,EAAmB,KACjB,EACE,EAAU,SACV,EACA,GAAgB,CAAS,CAC3B,CACF,EAGJ,OAAO,GCpCF,IAAM,GAAU,CACrB,EACA,IACG,CACH,IAAM,EAAU,CAQd,eAAgB,CACd,EACA,IACG,CACH,GAAI,QAAQ,IAAI,EAAQ,CAAG,EAAG,CAC5B,IAAM,EAAU,QAAQ,eAAe,EAAQ,CAAG,EAElD,GAAI,EACF,EAAS,EAGX,OAAO,EAET,MAAO,IAWT,IAAK,CACH,EACA,EACA,IACG,CAEH,GADsB,EAAO,KACP,EAAO,CAE3B,GACE,GACG,OAAO,IAAU,SAEpB,EAAQ,EAAI,CAAK,EAEnB,EAAO,GAAO,EAGd,EAAS,EAEX,MAAO,GAEX,EAQM,EAAM,CACV,IACG,CAEH,QAAW,KAAO,EAChB,GACE,EAAO,IACJ,OAAO,EAAO,KAAS,SAE1B,EAAO,GAAO,EAAI,EAAO,EAAI,EAIjC,OAAO,IAAI,MAAM,EAAQ,CAAO,GAGlC,OAAO,EAAI,CAAI,GCjDV,IAAM,GAAQ,CACnB,EACA,EACA,EACA,IACG,CACH,GAAI,OAAQ,IAAkB,SAC5B,EAAe,KAAK,MAAM,CAAY,EAExC,GAAI,CAAC,EACH,EAAe,CAAC,EAElB,IAAI,EAAgB,KACd,EAAgB,IAAM,CAC1B,GAAI,CAAC,EACH,EAAgB,QAAQ,QAAQ,EAC7B,KAAK,CAAe,EAEzB,OAAO,GAEH,EACJ,OAAO,eAAe,CAAY,IAAM,MAAM,UAC1C,EACA,GACA,EACA,CACF,EAQE,EAAmB,CACvB,EACA,EACA,IACG,CACH,GAAI,EACF,QAAW,KAAQ,EAAe,CAChC,IAAI,EAAQ,EAAc,GAC1B,GAAI,EAAO,CACT,IAAM,EAAO,OAAQ,EACrB,GAAI,IAAS,WAAY,CACvB,IAAM,EAAW,IAAgB,GACjC,GAAI,GAAU,IAAM,EAClB,EAAc,GAAQ,EACjB,KACL,GAAI,EACF,EAAQ,oBACN,EACA,CACF,EAGF,IAAM,EAAW,EAAc,GAC7B,CAAC,IAAU,CACT,EAAM,EAAO,CAAK,GAEtB,EAAQ,iBACN,EACA,CACF,EACA,EAAS,EAAI,GAGf,QAAI,IAAS,QAAS,CACpB,GAAI,OAAQ,IAAW,SACrB,GAAI,MAAM,QAAQ,CAAK,EACrB,EAAQ,EAAM,KAAK,GAAG,EACjB,KACL,IAAI,EAAa,GACjB,QAAW,KAAa,EACtB,GAAI,EAAM,GACR,GAAc,IAAM,EAGxB,EAAQ,EAGZ,EAAQ,UAAY,EACf,QACL,IAAS,SACN,OAAQ,IAAW,SACtB,CACA,QAAS,KAAa,EAAO,CAC3B,IAAI,EAAa,EAAM,GACvB,GAAI,EAAU,SAAS,IAAK,CAAC,EAC3B,EAAQ,MAAM,YACZ,EACA,CACF,EAEA,OAAQ,MAAM,GAAa,EAI/B,GACE,GACG,EAAc,IACd,OAAQ,EAAc,KAAW,UACjC,CAAC,MAAM,QAAQ,EAAc,EAAK,GAErC,QAAS,KAAa,EAAc,GAClC,GAAI,CAAC,EAAM,GACT,GAAI,EAAU,SAAS,IAAK,CAAC,EAC3B,EAAQ,MAAM,eACZ,CACF,EAEA,OAAQ,MAAM,GAAa,MAK9B,KACL,GAAI,IAAU,GACZ,EAAQ,OACH,QAAI,IAAS,SAClB,EAAQ,EAAM,SAAS,EAGzB,GADA,EAAQ,aAAa,EAAM,CAAK,EAC5B,IAAS,QACX,EAAQ,MAAQ,IAQ5B,GAAI,EACF,QAAW,KAAQ,EAAe,CAChC,IAAM,EAAQ,EAAc,GAC5B,GACE,CAAC,GACE,CAAC,EAAc,GAElB,GAAI,OAAQ,IAAW,WACrB,EAAQ,oBACN,EACA,EAAc,EAChB,EACK,QAAI,IAAS,QAClB,EAAQ,UAAY,GACf,QAAI,IAAS,QAClB,EAAQ,MAAM,QAAU,GACnB,QAAI,IAAS,QAClB,EAAQ,MAAQ,GAEhB,OAAQ,gBAAgB,CAAI,IAOlC,EAAa,IAAI,QACjB,EAAa,IAAI,QAOf,EAAiB,CACrB,EACA,EACA,EACA,IACG,CACH,IAAI,EAAW,EACX,EAAW,EACf,GAAI,EACF,KAAO,EAAW,EAAkB,OAAQ,IAAY,CACtD,IAAM,EAAc,EAAkB,GAEtC,GAAI,EAAY,EAAG,CACjB,IAAI,EAAQ,EAAW,IACrB,EAAY,CACd,EAEA,GACE,CAAC,GACE,CAAC,GAAe,EAAM,EAAG,EAAY,CAAC,EAEzC,EAAQ,CACN,EAAG,EACD,EAAY,EACV,EACA,EAAY,CACd,CACF,EACA,EAAG,EAAY,EACf,EAAG,EAAY,CACjB,EAGF,EAAW,IAAI,EAAY,EAAG,CAAK,EAGnC,EAAkB,OAChB,EACA,EAEA,GAAG,GACD,EAAM,CACR,CACF,EAEA,IACA,SAGF,IAAI,EAAU,GACd,GAAI,EACF,QAAS,EAAW,EAAW,EAAU,EAAW,EAAkB,OAAQ,IAAY,CACxF,IAAM,EAAc,EAAkB,GACtC,GAEI,EAAY,GACT,EAAY,IAAM,EAAY,GAGjC,CAAC,EAAY,GACV,CAAC,EAAY,EAElB,CAGA,GAFA,EAAU,GAEN,IAAc,EAAW,EAC3B,EAAQ,aACN,EAAQ,WAAW,EAAW,GAC9B,EAAQ,WAAW,EACrB,EACA,EAAkB,OAChB,EAAW,EACX,EACA,EAAkB,OAChB,EACA,CACF,EAAE,EACJ,EAGF,GAAI,EAAY,EACd,EACE,EAAQ,WAAW,GACnB,EAAY,EACZ,EAAY,CACd,EACA,EACE,EAAQ,WAAW,GACnB,EAAY,EACZ,EAAY,EACZ,GAAS,EAAY,IAAM,OAAS,EAAY,IAAM,KACxD,EACK,QAAI,IAAgB,EACzB,EAAQ,WAAW,GAAU,YAAc,EAE7C,OAKN,GAAI,CAAC,EAAS,CACZ,IAAI,EACJ,GAAI,EAAY,EAAG,CACjB,IAAM,EAAS,GAAS,EAAY,IAAM,OAAS,EAAY,IAAM,MACrE,GAAI,EACF,EAAU,SAAS,gBACjB,6BACA,EAAY,CACd,EAEA,OAAU,SAAS,cACjB,EAAY,CACd,EAEF,EACE,EACA,EAAY,EACZ,OACA,CACF,EACA,EACE,EACA,EAAY,EACZ,OACA,CACF,EAEA,OAAU,SAAS,eACjB,CACF,EAGF,EAAQ,aACN,EACA,EAAQ,WAAW,EACrB,EACA,KAKN,GAAI,EAAmB,CACrB,IAAM,EAAgB,EAAkB,OAAS,EACjD,GAAI,GAAiB,EACnB,QAAS,EAAI,EAAgB,EAAG,GAAK,EAAU,IAC7C,EAAQ,WAAW,GAAG,OAAO,IAM/B,EACJ,OAAQ,IAAiB,SAErB,SAAS,cAAc,CAAW,GAC/B,SAAS,KAAK,YACf,SAAS,cAAc,KAAK,CAC9B,EAEA,EAGN,GAAI,OAAQ,IAAqB,SAC/B,GAAI,CACF,EAAkB,KAAK,MAAM,CAAe,EAC5C,MAAO,EAAO,CACd,EAAkB,KAGtB,GAAI,CAAC,EACH,EAAkB,GAAgB,CAAY,EAGhD,IAAI,EAAS,GACX,EAAW,GACP,EAAkB,IAAM,CAC5B,GACE,GACG,CAAC,GACD,EACH,CACA,EAAW,GACX,EAAgB,KAEhB,IAAI,EAAkB,EACpB,EAAW,CAAK,CAClB,EACA,EACE,EACA,EACA,CACF,EACA,EAAkB,EAClB,EAAa,EACb,EAAa,IAAI,QAEjB,EAAW,KAMf,OAHA,EAAc,EACd,EAAgB,EAET,CACL,EACA,IAAM,CACJ,GAAI,EAAQ,CACV,EAAS,GAET,QAAS,EAAI,EAAa,WAAW,OAAS,EAAG,GAAK,EAAG,IACvD,EAAa,WAAW,GAAG,OAAO,IAIxC,CACF,GCnaK,IAAM,GAAuB,YACvB,GAAwB,aACxB,EAA0B,eAC1B,GAA2B,gBAC3B,GAAkC,uBAKxC,IAAM,GAAa,MACb,GAAa,MACb,GAAa,MACb,GAAa,MACb,GAAa,MAEb,GAAc,MACd,GAAc,MAIpB,IAAM,GAAe,MACf,GAAc,MAEd,GAAc,MACd,GAAY,MACZ,GAAY,MACZ,GAAgB,MChBtB,IAAM,GAA0B,iCAS1B,GAAe,CAC1B,EAAS,GACT,EAjBqC,mEAkBlC,CACH,IAAI,EAAO,GACX,QAAS,EAAI,EAAG,EAAI,EAAQ,IAC1B,GAAQ,EAAW,OACjB,KAAK,MACH,KAAK,OAAO,EACV,EAAW,MACf,CACF,EAEF,OAAO,GChCF,IAAM,EAAiB,CAC5B,IACG,CACH,IAAM,EAAS,KAAK,CAAM,EAC1B,OAAO,WAAW,KAChB,EACA,KAAa,EAAU,WAAW,CAAC,CACrC,EAAE,QAGS,GAAiB,CAC5B,IACG,CACH,IAAM,EAAS,KAAK,CAAM,EACpB,EAAQ,WAAW,KACvB,EACA,KAAa,EAAU,WAAW,CAAC,CACrC,EACA,OAAO,IAAI,YAAY,EAAE,OAAO,CAAK,GAG1B,GAAiB,CAC5B,IACG,CACH,IAAM,EAAQ,IAAI,YAAY,EAAE,OAAO,CAAM,EAE7C,GAAI,EAAM,OAAS,MACjB,OAAO,KACL,OAAO,aAAa,GAAG,CAAK,CAC9B,EAGF,IAAI,EAAS,GACP,EAAY,MAClB,QAAS,EAAI,EAAG,EAAI,EAAM,OAAQ,GAAK,EAAW,CAChD,IAAM,EAAQ,EAAM,SAAS,EAAG,EAAI,CAAS,EAC7C,GAAU,OAAO,aAAa,GAAG,CAAK,EAExC,OAAO,KAAK,CAAM,GAGP,EAAiB,CAC5B,IACG,CACH,IAAM,EAAQ,IAAI,WAAW,CAAM,EAEnC,GAAI,EAAM,OAAS,MACjB,OAAO,KACL,OAAO,aAAa,GAAG,CAAK,CAC9B,EAGF,IAAI,EAAS,GACP,EAAY,MAClB,QAAS,EAAI,EAAG,EAAI,EAAM,OAAQ,GAAK,EAAW,CAChD,IAAM,EAAQ,EAAM,SAAS,EAAG,EAAI,CAAS,EAC7C,GAAU,OAAO,aAAa,GAAG,CAAK,EAExC,OAAO,KAAK,CAAM,GClCb,IAAM,EAAc,IACtB,CAEH,IAAM,EAAY,IAAI,IAEtB,MAAO,CAML,YAAa,CACX,EACA,IACG,CACH,GAAI,CAAC,EAAU,IAAI,CAAQ,EACzB,EAAU,IAAI,EAAU,CAAO,GAQnC,eAAgB,CACd,IACG,CACH,EAAU,OAAO,CAAQ,GAO3B,SAAU,CACR,IACG,CACH,QAAY,EAAU,KAAY,EAAU,QAAQ,EAElD,GADA,EAAS,CAAI,EAEX,GACG,EAAQ,KAEX,EAAU,OAAO,CAAQ,EAIjC,GCpEK,IAAM,GAAS,CACpB,EACA,IACG,CACH,IAAM,EAAW,CAAC,EAClB,QAAW,KAAO,EAAO,CACvB,IAAM,EAAQ,EAAM,GACpB,GACE,IAAU,MACP,IAAU,OAEb,EAAS,KAAK,EAbN,IAaoB,EAC1B,OAAO,CAAK,CAAC,CACf,EAGJ,OAAO,EAAS,KAnBA,GAmBc,GAGnB,GAAS,CACpB,EACA,IACG,CACH,IAAM,EAAQ,CAAC,EACT,EAAW,EAAQ,MA3BT,GA2BwB,EACxC,QAAW,KAAW,EAAU,CAC9B,IAAM,EAAQ,EAAQ,QA5BZ,GA4ByB,EACnC,GAAI,EAAQ,EAAG,CACb,IAAM,EAAM,EAAQ,UAAU,EAAG,CAAK,EAChC,EAAQ,EAAQ,UAAU,EAAQ,CAAC,EACzC,EAAM,GAAO,EAAe,CAAK,GAGrC,OAAO,GCxBF,IAAM,GAAgB,CAC3B,EACA,IACG,CACH,IAAM,EAAe,KAAK,IAAI,EAE9B,GAAI,CAAC,EACH,MAAO,CACL,MAAO,EACP,OAAQ,EACR,SAAU,CACZ,EAGF,GAAI,CAAC,EAAY,CACf,IAAM,EAAS,EAAa,EAC5B,MAAO,CACL,MAAO,EACP,OAAQ,EACR,SACE,EACE,CAEN,EAGF,IAAM,EAAQ,EAAe,EACvB,GACH,EAAa,GACX,EAAa,IACd,EACJ,MAAO,CACL,MAAO,EACP,OAAQ,EACR,SACE,EACE,EACA,CAEN,GCnDK,IAAM,GAA2B,OAC3B,GAAuB,QACvB,GAA+B,MAC/B,GAAiB,UACjB,GAA2B,OAC3B,EAA8B,UAC9B,GAAoB,IACpB,GAA4B,WAC5B,EAA2B,oBAI3B,GAAqB,oCAAwC,IACrE,CACH,QAAQ,IAAI,CACV,OAAO,OAAO,YAAY,CACxB,KAAM,WACN,cAAe,KACf,eAAgB,IAAI,WAAW,CAAC,EAAG,EAAG,CAAC,CAAC,EACxC,KAAM,CAAE,KAAM,SAAW,CAC3B,EAAG,GAAM,CAAC,UAAW,SAAU,CAAC,EAChC,OAAO,OAAO,YAAY,CACxB,KAAM,oBACN,cAAe,KACf,eAAgB,IAAI,WAAW,CAAC,EAAG,EAAG,CAAC,CAAC,EACxC,KAAM,CAAE,KAAM,SAAW,CAC3B,EAAG,GAAM,CAAC,OAAQ,QAAS,CAAC,EAC5B,OAAO,OAAO,YAAY,CACxB,KAAM,OACN,WAAY,OACd,EAAG,GAAM,CAAC,WAAY,CAAC,CACzB,CAAC,EACE,KAAK,EACJ,EACA,EACA,KACI,CACJ,QAAQ,IAAI,CACV,OAAO,OAAO,UACZ,OACA,EAAc,SAChB,EACA,OAAO,OAAO,UACZ,OACA,EAAW,SACb,CACF,CAAC,EACE,KAAK,EACJ,EACA,KACI,CACJ,KAAK,YAAY,CACf,QAAS,GACT,gBACA,aACA,iBACA,qBACA,iBACF,CAAC,EACF,EACA,MAAM,CAAC,IAAU,CAChB,KAAK,YAAY,CACf,QAAS,GACT,MAAO,EAAM,OACf,CAAC,EACF,EACJ,EACA,MAAM,CAAC,IAAU,CAChB,KAAK,YAAY,CACf,QAAS,GACT,MAAO,EAAM,OACf,CAAC,EACF,IACF,SAAS,EAAI,IAEH,GAAuB,oCAAwC,IACvE,CACH,OAAO,OAAO,YAAY,CACxB,OAAQ,IACR,KAAM,SACR,EAAG,GAAM,CAAC,UAAW,SAAS,CAAC,EAC5B,KAAK,KAAa,CACjB,KAAK,YAAY,CACf,QAAS,GACT,WACF,CAAC,EACF,EACA,MAAM,KAAS,CACd,KAAK,YAAY,CACf,QAAS,GACT,MAAO,EAAM,OACf,CAAC,EACF,IACF,SAAS,EAAI,IC7FT,IAAM,GAAiB,IACjB,GAAc,IAEd,GAA4B,IAC5B,GAAuB,IAEvB,GAAO,IACP,GAAsB,IACtB,GAAqB,IACrB,GAAsB,IACtB,GAA0B,IAC1B,GAA4B,IC+GlC,IAAM,GAAwB,CACnC,EAAU,CAAC,IACR,CACH,IACE,cAAc,mBACd,qBAAqB,KAAK,MAC1B,mBAAmB,KAAK,UAExB,qBAAqB,eACrB,mBAAmB,aAEnB,UAAU,wBACV,QAAQ,wBAER,wBAAwB,GACxB,2BAA2B,OACzB,EAEA,EAAmB,EACrB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAwB,CAAC,EACzB,EACA,EAAmB,IAAI,IACvB,GAAmB,IAAI,IACvB,GAAgB,IAAI,IACpB,GAAoB,IAAI,IACxB,GAAgB,IAAI,IAChB,EAAkB,IACnB,CACH,GACE,CAAC,GACE,CAAC,EAEJ,EAAwB,IAAI,QAAQ,CAClC,EACA,IACG,CACH,IAAM,EAAS,IAAI,OACjB,IAAI,gBACF,IAAI,KAAK,CAAC,EAAmB,EAAG,CAC9B,KAAM,iBACR,CAAC,CACH,CACF,EAEA,EAAO,iBAAiB,UAAW,CACjC,IACG,CACH,GAAI,EAAM,KAAK,QACb,EAAiB,EAAM,KAAK,cAC5B,EAAc,EAAM,KAAK,WACzB,EAAkB,EAAM,KAAK,eAC7B,EAAsB,EAAM,KAAK,mBACjC,EAAmB,EAAM,KAAK,gBAE9B,EAAiB,GACjB,EAAwB,KACxB,EAAQ,EACH,KACL,IAAM,EAAY,MAAM,EAAM,KAAK,KAAK,EACxC,EAAQ,SAAS,CACf,OACF,CAAC,EACD,EAAO,CAAK,EAEd,EAAO,UAAU,EAClB,EAED,EAAO,iBAAiB,QAAS,CAC/B,IACG,CACH,EAAQ,SAAS,CACf,OACF,CAAC,EACD,EAAO,CAAK,EACZ,EAAO,UAAU,EAClB,EAED,EAAO,YAAY,CACjB,KAAM,WACR,CAAC,EACF,EAEH,OAAO,GAGT,EAAgB,EAEhB,IAAM,EAAU,EAAY,EACtB,GAAY,EAAY,EACxB,GAAa,EAAY,EACzB,GAAc,EAAY,EAC1B,GAAa,EAAY,EACzB,GAAc,EAAY,EAC1B,GAAiB,EAAY,EAC7B,GAAyB,EAAY,EACrC,GAAe,EAAY,EAE3B,EAAsB,CAC1B,IACG,CACH,GAAI,IAAqB,EACvB,EAAmB,EACnB,GAAa,SAAS,CACpB,OACF,CAAC,GAIC,GAA4B,MAChC,IACG,CACH,IAAM,EAAa,EAAiB,IAAI,CAAM,EAC9C,GAAI,CAAC,EACH,OAGF,GAAkB,IAChB,EACA,MAAM,KACJ,IAAI,WACF,MAAM,OAAO,OAAO,OAClB,GACA,IAAI,YAAY,EAAE,OAChB,EACE,EACA,MAAM,OAAO,OAAO,UAClB,MACA,CACF,CACF,CACF,CACF,CACF,CACF,CACF,EAEA,GAAuB,SAAS,CAC9B,SACA,KAAM,GAAoB,CAAM,CAClC,CAAC,GAMG,GAAY,IACb,CACH,GACE,IAAqB,GAClB,IAAqB,GAExB,OAIF,GAFA,EAAoB,EAAwB,EAExC,EACF,EAAQ,MAAM,EAGhB,EAAa,EAAiB,EAAwB,EAAQ,EAAiB,EAAkB,EAAsB,EAAmB,EAAc,EAAe,EAAqB,EAAc,EAAoB,EAAa,EAAwB,EAAU,KAC7Q,EAAiB,MAAM,EACvB,GAAiB,MAAM,EACvB,GAAc,MAAM,EACpB,GAAkB,MAAM,EACxB,GAAc,MAAM,EAGpB,EAAgB,EAEhB,EAAoB,CAAuB,GAEvC,GAAW,CACf,IACG,GAAc,CACjB,KAAM,GACN,QACF,CAAC,EASK,GAAY,CAChB,EACA,EAAgB,OACb,CACH,GACE,CAAC,GACE,GACA,IAAqB,EAExB,OAEF,EAAoB,EAAqB,EAEzC,EAAY,EAEZ,IAAM,EAAM,IAAI,IACd,EAAQ,CACV,EAKA,GAJA,EAAI,aAAa,OACf,OACA,CACF,EACI,EACF,EAAI,aAAa,OACf,UACA,CACF,EAGF,EAAU,IAAI,UACZ,EAAI,SAAS,CACf,EAEA,EAAQ,iBAAiB,QAAS,CAChC,IACG,CACH,GAAY,SAAS,CACnB,OACF,CAAC,EAED,GAAU,EACX,EAED,EAAQ,iBAAiB,QAAS,CAChC,IACG,CACH,EAAQ,SAAS,CACf,OACF,CAAC,EACD,GAAU,EACX,EAED,EAAQ,iBAAiB,UAAW,MAClC,IACG,CACH,GACE,GACE,EAAM,KACN,EACF,EACA,EAAM,IACR,EACD,GAGG,GAAkB,MACtB,EACA,EACA,EAAa,KACV,CACH,KACG,IAAiB,GACjB,IAAc,GAEd,IAAuB,GACvB,IAA4B,GAE5B,IAAsB,GACtB,IAAqB,IACrB,IAAsB,IACtB,IAA0B,IAC1B,IAA4B,IAC5B,IAAO,IACN,EAEA,EACF,GACA,GACA,GAEF,GAAI,EACF,GAAU,EACL,QAAI,EACT,GAAU,EAEV,QAAU,EAGZ,GAAI,EAAyB,CAC3B,GACE,CAAC,GAEC,CAAC,GACE,EAAsB,OAAS,EAEpC,CASA,GAPA,EAAsB,KAAK,CACzB,KAAM,KAAK,IAAI,EACf,QACA,KACF,CAAC,EAGG,EAAsB,OAAS,EACjC,EAAsB,MAAM,EAE9B,OAEF,GAAI,CAAC,EAAoB,CACvB,EAAQ,SACF,MAAM,+BAA+B,CAC3C,EACA,OAGF,EAAO,MAAM,OAAO,OAAO,QACzB,CACE,GAAI,EAAe,CAAkB,EACrC,KAAM,CACR,EACA,EACA,EAAe,CAAuB,CACxC,EACA,EAAO,IAAI,YAAY,EAAE,OAAO,CAAI,EACpC,GAAe,GACV,QAAI,GAAuB,CAChC,GACE,CAAC,IACE,CAAC,GACJ,CAEA,EAAQ,SAAS,CACf,MAAW,MAAM,6CAA6C,CAChE,CAAC,EACD,OAEF,GAAI,CAAC,EACH,MAAM,EAAgB,EAGxB,IAAM,EAAmB,EAAe,EAAqB,EACvD,EAAc,EAClB,IAAI,YAAY,EACb,OACC,MAAM,OAAO,OAAO,QAClB,CACE,GAAI,EAAe,EAAgB,EACnC,KAAM,CACR,EACA,MAAM,OAAO,OAAO,UAClB,MACA,MAAM,OAAO,OAAO,QAClB,CACE,KAAM,EACR,EACA,EAAe,WACf,EAAe,EAAiB,CAClC,EACA,CACE,KAAM,CACR,EACA,GACA,CAAC,UAAW,SAAU,CACxB,EACA,CACF,CACF,CACJ,EAGA,GAFA,GAAe,GAEX,EAAY,OAAS,GAEvB,GAAmB,EACd,QAAI,GAAyB,CAClC,IAAM,EAAW,EAAY,OAE7B,GAAI,CAAC,EAAU,CACb,EAAQ,SAAS,CACf,MAAW,MAAM,6BAA6B,CAChD,CAAC,EACD,OAGF,IAAM,GAAkB,GAAc,IAAI,CAAQ,EAClD,GAAI,CAAC,GAAiB,CACpB,EAAQ,SAAS,CACf,MAAW,MAAM,qBAAuB,CAAQ,CAClD,CAAC,EACD,OAGF,GACE,CAAE,MAAM,OAAO,OAAO,OACpB,EACA,GACA,EAAe,EAAuB,EACtC,CACF,EACA,CACA,EAAQ,SAAS,CACf,MAAW,MAAM,0BAA4B,CAAQ,CACvD,CAAC,EACD,OAGF,GAAmB,EACd,KACL,EAAQ,SAAS,CACf,MAAW,MAAM,8BAA8B,CACjD,CAAC,EACD,QAGF,OAAO,GAGT,GAAI,CAAC,GACH,GAAI,CACF,GAAmB,EAAmB,CAAI,EAC1C,MAAO,EAAO,CACd,EAAQ,SAAS,CACf,MAAW,MAAM,2BAA6B,CAAG,CACnD,CAAC,EACD,OAKJ,OAFA,EAAO,GAEC,EAAK,WACN,GAWH,GAVA,EAAa,EAAK,UAClB,EAAQ,EAAK,OAEb,GAAW,SAAS,CAClB,UAAW,EAAK,UAChB,SAAU,EACV,OAAQ,EAAK,OACb,MAAO,EAAK,KACd,CAAC,EAEG,IAAU,EACZ,EAAoB,EAAoB,EACnC,KAGL,GAFA,EAAoB,EAA+B,EAE/C,CAAC,EACH,MAAM,EAAgB,EAGxB,IAAM,EAAsB,MAAM,OAAO,OAAO,UAC9C,GACA,EAAgB,SAClB,EAEA,EAAS,CACP,KAAM,GACN,WACE,OAAO,IAAiB,WACpB,EAAY,EACZ,EAEN,iBAAkB,EAAe,CAAmB,EACpD,kBAAmB,EAAe,CAAmB,EACrD,cAAe,EAAe,CAAgB,EAE9C,UAAW,EACT,MAAM,OAAO,OAAO,KAClB,EACA,EAAY,WACZ,CACF,CACF,CACF,EAAG,CACD,iBAAkB,GAClB,SAAU,CACZ,CAAC,EAEH,WAEG,GACH,GACE,KAAiB,GACd,IAAU,EACb,CACA,IAAM,EAAY,EAAK,OAEvB,GACE,GACG,CAAC,EAAkB,CACpB,KAAM,EAAK,WACX,OAAQ,CACV,CAAC,EACD,CACA,GAAS,CAAS,EAClB,OAGF,GAAiB,IACf,EACA,MAAM,OAAO,OAAO,UAClB,GACA,EAAe,EAAK,gBAAgB,EACpC,CACE,KAAM,GACN,KAAM,EACR,EACA,GACA,CAAC,SAAU,CACb,CACF,EAEA,IAAM,EAAgB,MAAM,OAAO,OAAO,UACxC,GACA,EAAe,EAAK,aAAa,EACjC,CACE,KAAM,GACN,KAAM,CACR,EACA,GACA,CAAC,QAAS,CACZ,EAEM,EAAwB,EAC5B,EAAK,iBACP,EACA,GAAI,CAAE,MAAM,OAAO,OAAO,OACxB,EACA,EACA,EAAe,EAAK,SAAS,EAC7B,CACF,EAAI,CACF,EAAQ,SAAS,CACf,MAAW,MAAM,uCAAyC,CAAS,CACrE,CAAC,EACD,OAKF,GAFA,GAAc,IAAI,EAAW,CAAa,EAEtC,CAAC,EACH,MAAM,EAAgB,EAGxB,EAAiB,IACf,EACA,MAAM,OAAO,OAAO,UAClB,CACE,KAAM,GACN,OAAQ,MAAM,OAAO,OAAO,UAC1B,GACA,EACA,CACE,KAAM,GACN,WAAY,EACd,EACA,GACA,CAAC,CACH,CACF,EACA,EAAgB,WAChB,CACE,OAAQ,GACR,KAAM,CACR,EACA,GACA,CAAC,UAAW,SAAU,CACxB,CACF,EAEA,IAAM,GAAsB,MAAM,OAAO,OAAO,UAC9C,GACA,EAAgB,SAClB,EACA,EAAS,CACP,KAAM,GACN,WACE,OAAO,IAAiB,WACpB,EAAY,EACZ,EAEN,iBAAkB,EAAe,CAAmB,EACpD,kBAAmB,EAAe,EAAmB,EACrD,cAAe,EAAe,CAAgB,CAChD,EAAG,CACD,SAAU,CACZ,CAAC,EAED,GAA0B,CAAS,EAErC,WAEG,GACH,GACE,KAAiB,GACd,EAAK,SAAW,EACnB,CACA,GACE,GACG,CAAC,EAAkB,CACpB,KAAM,EAAK,WACX,OAAQ,CACV,CAAC,EACD,CACA,GAAU,EACV,OAGF,IAAM,EAAoB,MAAM,OAAO,OAAO,UAC5C,GACA,EAAe,EAAK,aAAa,EACjC,CACE,KAAM,GACN,KAAM,CACR,EACA,GACA,CAAC,QAAS,CACZ,EAEA,GACE,EAAK,mBACF,EAAK,WAER,GAAI,CAAE,MAAM,OAAO,OAAO,OACxB,EACA,EACA,EAAe,EAAK,SAAS,EAC7B,EAAe,EAAK,iBAAiB,CACvC,EAAI,CACF,EAAQ,SAAS,CACf,MAAW,MAAM,uCAAyC,CAAU,CACtE,CAAC,EACD,GAAU,EACV,QAsBJ,GAnBA,GAAc,IACZ,EACA,CACF,EAEA,GAAiB,IACf,EACA,MAAM,OAAO,OAAO,UAClB,GACA,EAAe,EAAK,gBAAgB,EACpC,CACE,KAAM,GACN,KAAM,EACR,EACA,GACA,CAAC,SAAU,CACb,CACF,EAEI,CAAC,EACH,MAAM,EAAgB,EAGxB,EAAiB,IACf,EACA,MAAM,OAAO,OAAO,UAClB,CACE,KAAM,GACN,OAAQ,MAAM,OAAO,OAAO,UAC1B,GACA,EAAe,EAAK,iBAAiB,EACrC,CACE,KAAM,GACN,WAAY,EACd,EACA,GACA,CAAC,CACH,CACF,EACA,EAAgB,WAChB,CACE,OAAQ,GACR,KAAM,CACR,EACA,GACA,CAAC,UAAW,SAAU,CACxB,CACF,EAEA,GAA0B,CAAU,EAEtC,WAEG,GACH,GACE,KAAiB,GACd,EAAK,SAAW,EACnB,CACA,GAAI,CAAC,GAAc,CACjB,EAAQ,SAAS,CACf,MAAW,MAAM,2BAA2B,CAC9C,CAAC,EACD,OAGF,GACE,GACG,CAAC,EAAmB,CACrB,KAAM,EAAK,YACX,OAAQ,CACV,CAAC,EACD,CACA,GAAU,EACV,OAGF,EAAS,CACP,KAAM,GACN,YAAa,CACf,EAAG,CACD,SAAU,CACZ,CAAC,EAEH,WAEG,GACH,GACE,KAAiB,GACd,IAAU,EACb,CACA,GAAI,CAAC,GAAc,CACjB,EAAQ,SAAS,CACf,MAAW,MAAM,2BAA2B,CAC9C,CAAC,EACD,OAEF,IAAM,EAAS,EAAK,OAEpB,GAAI,CAAC,GAAc,IAAI,CAAM,EAAG,CAC9B,EAAQ,SAAS,CACf,MAAW,MAAM,mBAAmB,CACtC,CAAC,EACD,GAAS,CAAM,EACf,OAGF,GACE,GACG,CAAC,EAAmB,CACrB,KAAM,EAAK,YACX,QACF,CAAC,EACD,CACA,GAAS,CAAM,EACf,OAGF,EAAS,CACP,KAAM,GACN,UAAW,EACT,MAAM,OAAO,OAAO,UAClB,MACA,CACF,CACF,CACF,EAAG,CACD,SAAU,CACZ,CAAC,EAED,GAAe,SAAS,CACtB,QACF,CAAC,EACD,GAAc,CACZ,KAAM,GACN,QACF,CAAC,EAEH,WAEG,GACH,GACE,KAAiB,GACd,EAAK,SAAW,EACnB,CACA,GAAI,CAAC,GAAc,CACjB,EAAQ,SAAS,CACf,MAAW,MAAM,2BAA2B,CAC9C,CAAC,EACD,OAoBF,GAjBA,EAAa,MAAM,OAAO,OAAO,UAC/B,MACA,EACE,EAAK,SACP,EACA,CACE,KAAM,CACR,EACA,GACA,CAAC,UAAW,SAAU,CACxB,EAEA,GAAe,SAAS,CACtB,OAAQ,CACV,CAAC,EAGG,EAAsB,OAAS,EAAG,CACpC,IAAM,EAAM,KAAK,IAAI,EACrB,EAAwB,EAAsB,OAAO,CAAC,IACpD,EAAM,EAAK,KAAO,CACnB,EAED,MAAO,EAAsB,OAAS,EAAG,CACvC,IACE,QACA,OACE,EAAsB,MAAM,EAChC,GACE,EACA,EACA,EACF,GAIJ,EAAoB,EAAoB,EAE5C,WAEK,GACH,GAAY,SAAS,CACnB,OAAQ,EAAK,MACf,CAAC,EACD,EAAiB,OAAO,EAAK,MAAM,EACnC,GAAiB,OAAO,EAAK,MAAM,EACnC,GAAc,OAAO,EAAK,MAAM,EAChC,WAEG,GACH,GAAW,SAAS,CAClB,OAAQ,EAAK,MACf,CAAC,EACD,WAEG,GACH,GAAe,SAAS,CACtB,OAAQ,EAAK,MACf,CAAC,EACD,cAGA,GAAI,CAAC,GAAc,CACjB,EAAQ,SAAS,CACf,MAAW,MAAM,2BAA2B,CAC9C,CAAC,EACD,OAGF,GAAU,SAAS,CACjB,OACA,KAAM,GACJ,EACA,GAAM,UACR,CACF,CAAC,EACD,QAIA,EAAW,MACf,EACA,EAAU,CAAC,IACR,CACH,GACE,CAAC,GACE,EAAQ,aAAe,UAAU,KAKpC,OAHA,EAAQ,SAAS,CACf,MAAW,MAAM,gBAAgB,CACnC,CAAC,EACM,GAGT,IAAM,EAAU,EAAiB,IAC5B,EACH,OAAQ,EACR,WAAY,KAAK,IAAI,CACvB,CAAC,EACK,EAAQ,CAAC,EAET,EAAW,EAAQ,SACzB,GAAI,EAAU,CACZ,IAAM,EAAoB,GAAiB,IAAI,CAAQ,EACvD,GAAI,EAAmB,CAErB,IAAM,EAAU,MAAM,OAAO,OAAO,YAClC,CACE,KAAM,EACN,OAAQ,GACV,EACA,GACA,CAAC,UAAW,SAAU,CACxB,EACM,EAAK,OAAO,gBAChB,IAAI,WAAW,EAAE,CACnB,EACM,GAAmB,MAAM,OAAO,OAAO,QAC3C,CACE,KACA,KAAM,CACR,EACA,EACA,IAAI,YAAY,EAAE,OAAO,CAAO,CAClC,EAEA,GAAI,CAAC,EACH,MAAM,EAAgB,EAGxB,EAAM,IAAsB,EAAe,CAAE,EAC7C,EAAM,IAAuB,EAC3B,MAAM,OAAO,OAAO,QAClB,CACE,KAAM,EACR,EACA,EACA,MAAM,OAAO,OAAO,UAClB,MACA,CACF,CACF,CACF,EACA,EAAM,IAA2B,EAAe,EAAgB,EAChE,EAAM,IAA6B,EACjC,MAAM,OAAO,OAAO,KAClB,EACA,EAAY,WACZ,EACF,CACF,EACK,QAAI,CAAC,EAAQ,iBAIlB,OAHA,EAAQ,SAAS,CACf,MAAW,MAAM,qBAAuB,CAAQ,CAClD,CAAC,EACM,GAEP,OAAM,IAAuB,EAG/B,EAAM,IAAQ,EACT,QAAI,EAAQ,OACjB,EAAM,IAAkB,EACnB,QAAI,EAAY,CACrB,IAAM,EAAK,OAAO,gBAChB,IAAI,WAAW,EAAE,CACnB,EAEA,EAAM,IAAwB,EAAe,CAAE,EAC/C,EAAM,IAA6B,EACjC,MAAM,OAAO,OAAO,QAClB,CACE,KACA,KAAM,CACR,EACA,EACA,IAAI,YAAY,EAAE,OAAO,CAAO,CAClC,CACF,EAKA,YAHA,EAAQ,SACF,MAAM,0CAA0C,CACtD,EACO,GAST,OANA,EAAQ,KACN,GACE,EACA,EACF,CACF,EACO,IAGH,GAAgB,CACpB,IAEA,GACG,IAAU,GACV,EAAS,EAAM,CAChB,OAAQ,EACV,CAAC,EAEG,GAAc,CAClB,EACA,IAEA,GACG,EAAS,EAAM,CAChB,SAAU,CACZ,CAAC,EAGG,GAAsB,CAC1B,EACA,EAAa,IACV,CACH,GAAI,CAAC,GAAkB,IAAI,CAAM,EAC/B,MAAO,GAET,IAAM,EAAY,GAAkB,IAAI,CAAM,EAC1C,EAAO,GACX,QAAS,EAAI,EAAG,EAAI,EAAY,IAAK,CACnC,IAAM,EAAQ,EAAU,GAAK,GAAwB,OACrD,GAAQ,GAAwB,GAElC,OAAO,GAGT,MAAO,CACL,gBACA,UACA,aAEA,cACA,eAEA,cACA,eACA,kBACA,0BAEA,YAAa,CACX,IACG,EAAS,CAAI,EAClB,iBACA,eAEA,UAAW,IACN,GAAc,CACjB,KAAM,EACR,CAAC,EACD,WAAY,MACV,EAAU,CAAC,IACR,CACH,GACE,GACG,IAAqB,EAExB,OAIF,GAFA,EAAoB,EAAqB,EAErC,EAAQ,WACV,EAAc,EAAQ,WAExB,GAAI,EAAQ,iBACV,EAAoB,EAAQ,iBAG9B,GAAI,CACF,MAAM,IAAI,QAAQ,CAChB,EACA,IACG,CACH,IAAM,EAAS,IAAI,OACjB,IAAI,gBACF,IAAI,KAAK,CAAC,EAAqB,EAAG,CAChC,KAAM,iBACR,CAAC,CACH,CACF,EAEA,EAAO,iBAAiB,UAAW,CACjC,IACG,CACH,GAAI,EAAM,KAAK,QACb,EAAa,EAAM,KAAK,UACxB,EAAQ,EAER,OACM,MAAM,EAAM,KAAK,KAAK,CAC5B,EAEF,EAAO,UAAU,EAClB,EAED,EAAO,iBAAiB,QAAS,CAC/B,IACG,CACH,EAAO,CAAK,EACZ,EAAO,UAAU,EAClB,EAED,EAAO,YAAY,CACjB,KAAM,YACR,CAAC,EACF,EACD,MAAO,EAAO,CACd,EAAoB,CAAuB,EAC3C,EAAQ,SAAS,CACf,OACF,CAAC,EACD,OAGF,IAAM,EAAM,IAAI,IACd,EACE,CACJ,EACA,GAAI,EAAQ,MACV,EAAI,aAAa,OACf,QACA,EAAQ,KACV,EAGF,IAAM,EAAW,MAAM,MAAM,EAAI,SAAS,EAAG,CAC3C,OAAQ,MACR,QAAS,CACP,OAAQ,CACV,CACF,CAAC,EACD,GAAI,CAAC,EAAS,GACZ,MAAU,MAAM,uBAAuB,EAGzC,IAAI,EAAO,MAAM,EAAS,KAAK,EAU/B,OATA,EAAO,EAAmB,CAAI,EAE9B,EAAQ,EAAK,OAEb,GACE,EAAK,SACL,EAAK,aACP,EAEO,GAET,SAAU,CACR,EACA,EAAU,CAAC,IACR,CACH,GAAI,EAAQ,WACV,EAAc,EAAQ,WAExB,GAAI,EAAQ,iBACV,EAAoB,EAAQ,iBAE9B,GACE,CACF,GAEF,aACA,YAEA,uBACA,WAAY,MACV,EACA,IACG,CACH,GACE,IAAU,GACP,CAAC,EAEJ,MAAO,GAGT,IAAM,EAAe,GACnB,EACA,EAAK,MACP,EACA,GACE,CAAC,GACE,CAAC,GACD,IAAiB,EAEpB,MAAO,GAKT,GAHA,GAAc,IAAI,EAAQ,EAAI,EAG1B,CADe,EAAiB,IAAI,CAAM,EAE5C,MAAO,GAUT,OAPA,EAAS,CACP,KAAM,GACN,YAAa,CACf,EAAG,CACD,SAAU,CACZ,CAAC,EAEM,GAEX,GCvyCK,IAAM,EAAiB,CAC5B,IACG,CACH,GAAI,OAAQ,IAAW,SAAU,CAC/B,IAAM,EACJ,MAAM,QAAQ,CAAK,EACf,CAAC,EACD,CAAC,EAEP,QAAW,KAAO,EAChB,EAAM,GAAO,EAAe,EAAM,EAAI,EAExC,OAAO,EAET,OAAO,GCDT,IAAM,GAAiB,CACrB,EACA,EACA,IACG,CACH,IAAI,EAAU,EACd,QAAS,EAAI,EAAG,EAAI,EAAK,OAAS,EAAG,IAAK,CACxC,IAAM,EAAM,EAAK,GACjB,GAAI,EAAE,KAAO,GACX,EAAQ,GAAO,CAAC,EAElB,EAAU,EAAQ,GAEpB,EAAQ,EAAK,EAAK,OAAS,IAAM,EAAe,CAAK,GASjD,GAAoB,CACxB,EACA,IACG,CACH,IAAI,EAAU,EACd,QAAS,EAAI,EAAG,EAAI,EAAK,OAAS,EAAG,IAEnC,GADA,EAAU,EAAQ,EAAK,IACnB,CAAC,EAEH,OAGJ,GAAI,MAAM,QAAQ,CAAO,EACvB,EAAQ,OAAO,SAAS,EAAK,EAAK,OAAS,EAAE,EAAG,CAAC,EAEjD,YAAO,EAAQ,EAAK,EAAK,OAAS,KAYzB,GAAgB,CAC3B,EACA,EACA,EAAO,CAAC,IACL,CACH,IAAM,EAAU,CAAC,EAGjB,QAAW,KAAO,EAAQ,CACxB,IAAM,EAAc,CAAC,GAAG,EAAM,CAAG,EAEjC,GAAI,EAAE,KAAO,GACX,EAAQ,QAAQ,CACd,KAAM,SACN,KAAM,EACN,IAAK,EAAe,EAAO,EAAI,CACjC,CAAC,EACI,QACL,OAAO,EAAO,KAAS,UACpB,OAAO,EAAM,KAAS,SAGzB,EAAQ,QACN,GAAG,GAAc,EAAO,GAAM,EAAM,GAAM,CAAW,CACvD,EACK,QAAI,EAAO,KAAS,EAAM,GAE/B,EAAQ,QAAQ,CACd,KAAM,MACN,KAAM,EACN,IAAK,EAAe,EAAO,EAAI,EAC/B,IAAK,EAAe,EAAM,EAAI,CAChC,CAAC,EAKL,QAAW,KAAO,EAChB,GAAI,EAAE,KAAO,GACX,EAAQ,QAAQ,CACd,KAAM,MACN,KAAM,CAAC,GAAG,EAAM,CAAG,EACnB,IAAK,EAAe,EAAM,EAAI,CAChC,CAAC,EAIL,OAAO,GAUI,GAAY,CACvB,EACA,IACG,CACH,QAAW,KAAU,EACnB,GAAI,EAAO,OAAS,MAClB,GAAe,EAAO,EAAO,KAAM,EAAO,GAAG,EACxC,QAAI,EAAO,OAAS,SACzB,GAAkB,EAAO,EAAO,IAAI,EAGxC,OAAO,GAUI,GAAa,CACxB,EACA,IACG,CACH,QAAW,KAAU,EACnB,GAAI,EAAO,OAAS,MAClB,GAAI,EAAO,MAAQ,OACjB,GAAkB,EAAO,EAAO,IAAI,EAEpC,QAAe,EAAO,EAAO,KAAM,EAAO,GAAG,EAE1C,QAAI,EAAO,OAAS,SACzB,GAAe,EAAO,EAAO,KAAM,EAAO,GAAG,EAGjD,OAAO,GC1EF,IAAM,GAA2B,CACtC,EAAU,CAAC,EACX,EAAe,CAAC,EAChB,EAAc,CAAC,IACZ,CACH,IAAM,EAAY,GAAsB,CAAO,GAE7C,eACE,GAGF,gBAAgB,GAChB,0BAA0B,OACxB,EACE,EAAgB,CAAC,EACnB,EACF,EAAgB,EAChB,EAAiB,EACjB,EAAsB,EAElB,EAAa,CACjB,IACG,CACH,IAAM,EAAa,GAAa,EAC1B,EACJ,EAAW,OAAS,EAChB,EAAW,GAAG,WACd,KAiBN,GAbA,EAAc,QAAQ,CACpB,aACA,WACA,OAAQ,EAAa,OACrB,aACA,KAAM,CACJ,SACE,KAAK,IAAI,EACP,EACA,CAEN,CACF,CAAC,EACG,EAAc,OAAS,EACzB,EAAc,OACZ,CACF,EAEF,EAAY,CACV,aACA,WACA,aACA,KAAM,EACR,CAAC,EAED,EAAqB,GAEjB,EAAa,IACd,CACH,GAAI,EAAa,cAAe,CAC9B,IAAM,EAAa,GACjB,EAAa,cACb,CACF,EACA,GAAI,EAAW,OAAS,EACtB,EACE,CACF,IAKA,EAAoB,IACrB,CACH,GAAI,EAAa,MAAM,OAAS,EAC9B,EAAY,CACV,KAAM,GACN,MAAO,EACL,CACF,CACF,CAAC,GAIC,EAAuB,IACxB,CACH,EAAa,cAAgB,EAC3B,CACF,GAwNF,OArNA,EAAU,UAAU,YAAY,EAC9B,OACA,UACI,CAEJ,GACE,EAAK,SAAW,EAAa,QAE3B,EAAK,UACF,EAAK,WAAa,EAAa,OAGpC,OAaF,GATA,GACE,EACE,EAAK,OACL,EACJ,GACE,EACE,EAAK,QACL,EAEA,EAAK,OAAS,GAAa,CAE7B,IAAI,EAAQ,EACZ,KAAO,EAAQ,EAAc,OAAQ,IAEnC,GADuB,EAAc,GAClB,KAAK,UAAY,EAAK,SACvC,MAGJ,EAAc,OAAO,EAAG,CAAK,EAG7B,QAAW,KAAO,EAChB,OAAO,EAAY,GAErB,QAAW,KAAO,EAAK,MACrB,EAAY,GAAO,EAAK,MAAM,GAIhC,QAAS,EAAQ,EAAG,EAAQ,EAAc,OAAQ,IAChD,GACE,EACA,EAAc,GAAO,UACvB,EAGF,EAAqB,EAChB,QAAI,EAAK,OAAS,GAAc,CACrC,IAAI,EAAiB,GACrB,QAAS,EAAQ,EAAG,EAAQ,EAAc,OAAQ,IAAS,CACzD,IAAM,EAAiB,EAAc,GACrC,GAEE,EAAe,aAAe,EAAK,UAGjC,EAAe,WAAa,EAAK,UAC9B,EAAe,KAAK,SAAW,EAAK,SAEzC,CACA,EAAc,OAAO,EAAO,EAAG,IAC1B,EACH,MACF,CAAC,EACD,EAAiB,GACjB,OAGJ,GAAI,EAEF,EAAc,QAAQ,IACjB,EACH,MACF,CAAC,EAIH,QAAS,EAAQ,EAAG,EAAQ,EAAc,OAAQ,IAAS,CACzD,IAAM,EAAS,EAAc,GAC7B,GAAI,EAAO,aAAe,EAAK,WAE7B,MAEF,GACE,EACA,EAAO,UACT,EAIF,QAAS,EAAQ,EAAG,EAAQ,EAAc,OAAQ,IAAS,CACzD,IAAM,EAAS,EAAc,GAM7B,GAJA,GACE,EACA,EAAO,UACT,EACI,EAAO,aAAe,EAAK,WAE7B,MAIJ,EAAqB,GAExB,EAED,EAAU,aAAa,YAAY,EACjC,WACI,CACJ,EAAa,gBAAkB,EAChC,EAED,EAAU,WAAW,YAAY,EAC/B,YACA,WACA,SACA,WACI,CAWJ,GATA,EAAa,UAAY,EACzB,EAAa,SAAW,EACxB,EAAa,OAAS,EACtB,EAAa,MAAQ,EACrB,EAAa,cAAgB,CAAC,EAC9B,EAAa,cAAgB,EAC3B,CACF,EAEI,IAAW,EACb,EAAa,cAAc,KAAK,CAAM,EAGtC,EAA6B,YAC3B,EACA,CACF,EAEH,EACD,EAAU,YAAY,YAAY,IAC7B,CACH,QAAW,KAAO,EAChB,OAAO,EAAa,GAEtB,GAAI,EACF,cAAc,CAA0B,EAE3C,EAED,EAAU,WAAW,YAAY,EAC/B,YACI,CACJ,EAAa,MAAM,KACjB,CACF,EAGA,EAAsB,EACpB,EAAgB,EAAa,MAAM,OAEtC,EACD,EAAU,uBAAuB,YAAY,CAC3C,IACG,CACH,GAAI,EAAM,SAAW,EAAa,UAChC,EAAa,iBAAmB,EAAM,KAEzC,EACD,EAAU,eAAe,YAAY,EACnC,YACI,CAWJ,GAVA,EAAa,cAAc,KACzB,CACF,EAGA,EAAsB,EACpB,EAAgB,EAAa,MAAM,OAIjC,EAAa,SAAW,EAAa,UACvC,EAAkB,EAErB,EACD,EAAU,YAAY,YAAY,EAChC,YACI,CACJ,QAAS,EAAQ,EAAG,EAAQ,EAAa,MAAM,OAAQ,IACrD,GAAI,EAAa,MAAM,KAAW,EAAQ,CACxC,EAAa,MAAM,OAAO,EAAO,CAAC,EAClC,MAGJ,QAAS,EAAQ,EAAG,EAAQ,EAAa,cAAc,OAAQ,IAC7D,GAAI,EAAa,cAAc,KAAW,EAAQ,CAChD,EAAa,cAAc,OAAO,EAAO,CAAC,EAC1C,MAKJ,EAAsB,EACpB,EAAgB,EAAa,MAAM,OAEtC,EAEM,OAAO,OAAO,CACnB,eACA,cACA,YACF,EAAG,CAAS,IC7Wb,QAAS,EAAG,CACX,IAAI,EAAe,KAGb,EAA0B,CAC9B,EACA,IACG,CACH,IAAM,EAAS,EAAM,OAAO,QAAQ,IAAI,EAAE,aAAa,cAAc,EACrE,EAAM,kBAAkB,GAAU,EAAM,OAAO,OAI3C,EAA2B,CAC/B,EACA,IACG,CACH,IAAM,EAAS,EAAM,OAAO,QAAQ,IAAI,EAAE,aAAa,cAAc,EACrE,EAAa,WACX,EACA,EAAM,kBAAkB,EAC1B,GAII,EAAqB,CACzB,EACA,IACG,CACH,EAAM,QAAU,EAAM,OAAO,OAIzB,EAAsB,CAC1B,EACA,IACG,CACH,EAAM,YAAY,SAAS,KAAK,CAC9B,QAAS,EAAM,QACf,UAAW,KAAK,IAAI,EACpB,OAAQ,EAAM,aAAa,MAC7B,CAAC,EACD,EAAM,QAAU,MAIZ,EAAmB,CACvB,EACA,IACG,CACH,EAAa,WAAW,CACtB,WAAY,CACV,QAAS,SACX,EACA,iBAAkB,EAChB,SACA,UACI,CAEJ,OAAO,EAAK,UAAY,WAE1B,YAAa,CACX,QAAS,SACX,EACA,kBAAmB,EAAG,OAAM,YAAa,CAEvC,OAAO,EAAK,UAAY,SAE5B,CAAC,GAIG,EAAkB,CACtB,EACA,IACG,CACH,EAAa,UAAU,GAInB,EAAsB,CAC1B,EACA,IACG,CACH,EAAM,SAAW,EAAM,OAAO,OAI1B,EAAuB,CAC3B,EACA,IACG,CACH,EAAa,SACX,EAAM,SACN,CACE,WAAY,CACV,QAAS,SACX,EACA,iBAAkB,EAAG,OAAM,YAAa,CAEtC,OAAO,EAAK,UAAY,WAE1B,YAAa,CACX,QAAS,QACX,EACA,kBAAmB,EAAG,OAAM,YAAa,CAEvC,OAAO,EAAK,UAAY,UAE5B,CACF,EACA,EAAM,SAAW,IAIb,EAAc,SAAS,cAAc,KAAK,EAChD,EAAY,aAAa,KAAM,KAAK,EACpC,SAAS,KAAK,YAAY,CAAW,EAGrC,IACE,EACA,EACA,GACE,GACF,EACA,CAAC,IAAU,CAKT,OAHA,GAAc,WAAW,EAGlB,CACL,EAAE,KAAM,eAAe,EACvB,GAAG,GAAE,EAAM,aAAa,gBACtB,EACG,IAAuB,IAAM,CAE5B,EAAE,IAAK,CACL,gBACA,EAAE,OAAQ,EAAM,aAAa,MAAM,EACnC,YACA,EAAE,OAAQ,EAAM,aAAa,QAAQ,EACrC,GACF,CAAC,EACD,EAAE,IAAI,EAGN,EAAE,IAAK,oBAAoB,EAC3B,EAAE,KACA,EAAM,aAAa,MAAM,IAAI,CAAC,IAC5B,EAAE,KAAM,CACN,EAAE,OAAQ,CAAM,EAChB,GAAG,GACD,EAAM,aAAa,cAAc,SAAS,CAAM,EAChD,IAAM,EAAE,OAAQ,aAAa,EAC7B,IAAM,EAAE,OAAQ,eAAe,CACjC,CACF,CAAC,CACF,CACH,EAGA,GAAG,GACD,EAAM,aAAa,SAAW,EAAM,aAAa,UACjD,IAAM,CACJ,IAAM,EAAkB,EAAM,aAAa,MAAM,OAAO,CAAC,IAAW,CAAC,EAAM,aAAa,cAAc,SAAS,CAAM,CAAC,EACtH,OAAO,GACL,EAAgB,OAAS,EACzB,IAAM,CACJ,EAAE,IAAI,EACN,EAAE,IAAK,0CAA0C,EACjD,EAAE,KACA,EAAgB,IAAI,CAAC,IACnB,EAAE,KAAM,CACN,eAAgB,CAClB,EAAG,CACD,EAAE,OAAQ,CAAM,EAChB,EAAE,QAAS,CACT,IAAK,gCAAkC,CACzC,EAAG,oBAAoB,EACvB,EAAE,QAAS,CACT,GAAI,gCAAkC,EACtC,KAAM,OACN,SAAU,GACV,MAAO,EACP,MAAO,EAAM,kBAAkB,EACjC,CAAC,EACD,EAAE,SAAU,CACV,MAAO,CACT,EAAG,UAAU,CACf,CAAC,CACF,CACH,CACF,CACF,EAEJ,EAEA,EAAE,IAAI,EAGN,GAAG,GAAE,EAAM,YAAY,SAAS,OAC9B,IAAM,CACJ,EAAE,IAAK,uBAAuB,EAC9B,EAAE,KACA,EAAM,YAAY,SAAS,IACzB,CAAC,IACC,EAAE,KAAM,CACN,KACA,EAAE,OAAQ,CACR,SAAU,IAAI,KAAK,EAAQ,SAAS,EAAE,YAAY,CACpD,EAAG,IAAI,KAAK,EAAQ,SAAS,EAAE,eAAe,CAAC,EAC/C,KACA,EAAE,OAAQ,EAAQ,MAAM,EACxB,KACA,EAAE,OAAQ,EAAQ,OAAO,CAC3B,CAAC,CAEL,CACF,CACF,EACA,IAAM,EAAE,IAAK,iCAAiC,CAChD,EAGA,EAAE,QAAS,CACT,IAAK,eACP,EAAG,UAAU,EACb,EAAE,WAAY,CACZ,GAAI,gBACJ,KAAM,OACN,SAAU,GACV,MAAO,CACT,EAAG,EAAM,OAAO,EAChB,EAAE,SAAU,CACV,MAAO,CACT,EAAG,cAAc,EAEjB,EAAE,IAAI,EAGN,EAAE,IAAK,yBAAyB,EAChC,EAAE,SAAU,CACV,MAAO,CACT,EAAG,YAAY,CACjB,GACC,IAAwB,IAAM,CAE7B,EAAE,IAAK,uBAAuB,CAChC,GACC,IAA2B,IAAM,CAEhC,EAAE,IAAK,4BAA4B,CACrC,GACC,IAAkC,IAAM,CAEvC,EAAE,IAAK,CACL,oFACA,EAAE,OAAQ,EAAM,aAAa,kBAAoB,eAAe,CAClE,CAAC,CACH,CACF,EAEA,IAAM,CACJ,EAAE,IAAK,CACL,qCACA,EAAE,OAAQ,cAAc,EACxB,4CACA,EAAE,OAAQ,eAAe,EACzB,iBACF,CAAC,EAED,EAAE,IAAI,EAEN,EAAE,IAAK,4BAA4B,EACnC,EAAE,SAAU,CACV,MAAO,CACT,EAAG,aAAa,EAEhB,EAAE,IAAI,EAEN,EAAE,IAAK,2BAA2B,EAClC,EAAE,QAAS,CACT,IAAK,iBACP,EAAG,YAAY,EACf,EAAE,QAAS,CACT,GAAI,kBACJ,KAAM,OACN,SAAU,GACV,MAAO,EACP,MAAO,EAAM,QACf,CAAC,EACD,EAAE,SAAU,CACV,MAAO,CACT,EAAG,WAAW,CAChB,CACF,CACF,GAEF,CAEE,QAAS,GACT,SAAU,GACV,kBAAmB,CAAC,EAEpB,aAAc,CAAC,EACf,YAAa,CACX,SAAU,CAAC,CACb,CACF,CACF,EAGA,EAAe,GACb,CAAC,EACD,EAAM,aACN,EAAM,WACR,EAGA,EAAa,QAAQ,YAAY,CAAC,IAAU,EAE3C,EAED,EAAa,UAAU,YAAY,CAAC,IAAU,EAE7C,EAED,EAAa,aAAa,YAAY,CAAC,IAAU,EAEhD,EAED,EAAa,WAAW,YAAY,CAAC,IAAU,EAE9C,EAED,EAAa,YAAY,YAAY,CAAC,IAAU,EAE/C,EAED,EAAa,WAAW,YAAY,CAAC,IAAU,EAE9C,EAED,EAAa,eAAe,YAAY,CAAC,IAAU,EAElD,EAED,EAAa,YAAY,YAAY,CAAC,IAAU,EAE/C,IACD",
  "debugId": "59BD7A7B514C7CC164756E2164756E21",
  "names": []
}