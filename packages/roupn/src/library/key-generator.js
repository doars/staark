export const DIFFIE_HELLMAN_ALGORITHM = 'ECDH'
export const DIFFIE_HELLMAN_CURVE = 'P-256'
export const DIFFIE_HELLMAN_EXPORT_FORMAT = 'raw'
export const HASH_ALGORITHM = 'SHA-256'
export const PUBLIC_KEY_EXPORT_FORMAT = 'spki'
export const SHARED_ENCRYPTION_ALGORITHM = 'AES-GCM'
export const SHARED_KEY_LENGTH = 256
export const USER_ENCRYPTION_ALGORITHM = 'RSA-OAEP'
export const USER_SIGNATURE_ALGORITHM = 'RSASSA-PKCS1-v1_5'

// Values are inlined because of the string generated by the toString call will not have the same context. It is not written in a string in order to allow the build tool to minify and post-process the function's contents.

export const USER_KEY_GENERATOR = 'self.addEventListener(\'message\',' + ((
) => {
  Promise.all([
    crypto.subtle.generateKey({
      name: 'RSA-OAEP',
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: 'SHA-256', },
    }, true, ['encrypt', 'decrypt',]),
    crypto.subtle.generateKey({
      name: 'RSASSA-PKCS1-v1_5',
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: 'SHA-256', },
    }, true, ['sign', 'verify',]),
    crypto.subtle.generateKey({
      name: 'ECDH',
      namedCurve: 'P-256',
    }, true, ['deriveKey',]),
  ])
    .then(([
      myEncryptKeys,
      mySignKeys,
      myExchangeKeys,
    ]) => {
      Promise.all([
        crypto.subtle.exportKey(
          'spki',
          myEncryptKeys.publicKey,
        ),
        crypto.subtle.exportKey(
          'spki',
          mySignKeys.publicKey,
        ),
      ])
        .then(([
          myPublicEncryptKey,
          myPublicSignKey,
        ]) => {
          self.postMessage({
            success: true,
            myEncryptKeys,
            mySignKeys,
            myExchangeKeys,
            myPublicEncryptKey,
            myPublicSignKey,
          })
        })
        .catch((error) => {
          self.postMessage({
            success: false,
            error: error.message,
          })
        })
    })
    .catch((error) => {
      self.postMessage({
        success: false,
        error: error.message,
      })
    })
}).toString() + ')'

export const SHARED_KEY_GENERATOR = 'self.addEventListener(\'message\',' + ((
) => {
  crypto.subtle.generateKey({
    length: 256,
    name: 'AES-GCM',
  }, true, ['encrypt', 'decrypt'])
    .then(sharedKey => {
      self.postMessage({
        success: true,
        sharedKey,
      })
    })
    .catch(error => {
      self.postMessage({
        success: false,
        error: error.message,
      })
    })
}).toString() + ')'
