{
  "version": 3,
  "sources": ["../src/utilities/clone.ts", "../src/utilities/delay.ts", "../src/utilities/type.ts", "../src/library/request.ts"],
  "sourcesContent": ["\nexport const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const delay = async (\n  time: number,\n): Promise<null> => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time)\n    )\n  }\n  return null\n}\n", "const normalizeContentType = (\n  contentType: string,\n): string => contentType.split(';')[0].trim().toLowerCase()\n\nconst getFileExtension = (\n  url: string,\n): string | null => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\nexport const getType = function (\n  url: string,\n  responseHeaders: Headers,\n  requestHeaders?: Record<string, string>,\n): string {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n", "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\nimport {\n  delay,\n} from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\nexport interface ResponseParser {\n  types: string[],\n  parser: (\n    response: Response,\n    options: RequestOptions,\n  ) => any,\n}\n\nexport interface SendOptions {\n  body?: any\n  credentials?: RequestCredentials\n  domain?: string\n  headers?: Record<string, string>\n  method?: 'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'\n  mode?: RequestMode\n  path?: string\n  priority?: 'high' | 'normal' | 'low'\n  queryParams?: Record<string, string>\n  redirect?: RequestRedirect,\n  responseParsers?: ResponseParser[],\n  type?: string,\n\n  abort?: AbortController\n  cache?: RequestCache\n\n  debounce?: number\n  delay?: number\n  throttle?: number\n  timeout?: number\n  retryAttempts?: number\n  retryCodes?: number[]\n  retryDelay?: number\n}\n\nexport interface RequestOptions extends SendOptions {\n  maxConcurrency?: number\n  maxRequests?: number\n}\n\nconst DEFAULT_VALUES: RequestOptions = {\n  method: 'get',\n  retryCodes: [429, 503, 504,],\n  retryDelay: 500,\n}\n\n// TODO: If the response is \"429 Too Many Requests\" or \"503 Service unavailable\" and retry after is later than the retry delay than use that moment instead. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n\nexport const create = (\n  initialOptions: RequestOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0 // TODO: Add support for max requests options.\n  let debounceTimeout: number | null = null\n\n  const throttle = async (\n    throttleValue: number,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (\n      waitTime > 0\n        ? waitTime\n        : 0\n    )\n    await delay(waitTime)\n  }\n\n  const debounce = (\n    debounceValue: number,\n  ): Promise<void> => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(\n        resolve,\n        debounceValue,\n      )\n    })\n  }\n\n  const sendRequest = async (\n    options: RequestOptions,\n  ): Promise<[Response, any]> => {\n    const config: RequestInit = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n\n      body: (\n        options.body\n          ? JSON.stringify(options.body)\n          : undefined\n      ),\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(\n        options.queryParams,\n      ).toString()\n    }\n\n    if (options.timeout) {\n      const controller = (\n        options.abort\n        || new AbortController()\n      )\n      config.signal = controller.signal\n      setTimeout(\n        () => controller.abort(),\n        options.timeout,\n      );\n    }\n\n    const executeFetch = async (\n    ): Promise<[Response, any]> => {\n      const response = await fetch(\n        url,\n        config,\n      )\n\n      let result\n      let foundParser = false\n      const type = options.type || getType(url, response.headers, options.headers)\n      if (options.responseParsers) {\n        for (const parser of options.responseParsers) {\n          foundParser = parser.types.includes(type)\n          if (foundParser) {\n            result = await parser.parser(\n              response,\n              options,\n            )\n            break\n          }\n        }\n      }\n      if (!foundParser) {\n        switch (type.toLowerCase()) {\n          case 'arraybuffer':\n            result = await response.arrayBuffer()\n            break\n\n          case 'blob':\n            result = await response.blob()\n            break\n\n          case 'formdata':\n            result = await response.formData()\n            break\n\n          case 'text/plain':\n          case 'text':\n          case 'txt':\n            result = await response.text()\n            break\n\n          case 'text/html-partial':\n          case 'html-partial':\n            result = await response.text()\n            const template = document.createElement('template')\n            template.innerHTML = result\n            result = template.content.childNodes[0]\n            break\n\n          case 'text/html':\n          case 'html':\n            result = await response.text()\n            result = (new DOMParser()).parseFromString(result, 'text/html')\n            break\n\n          case 'application/json':\n          case 'text/json':\n          case 'json':\n            result = await response.json()\n            break\n\n          case 'image/svg+xml':\n          case 'svg':\n            result = await response.text()\n            result = (new DOMParser()).parseFromString(result, 'image/svg+xml')\n            break\n\n          case 'application/xml':\n          case 'text/xml':\n          case 'xml':\n            result = await response.text()\n            result = (new DOMParser()).parseFromString(result, 'application/xml')\n            break\n        }\n      }\n\n      return [response, result]\n    }\n\n    const retryRequest = async (\n    ): Promise<[Response, any]> => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        try {\n          return await executeFetch()\n        } catch (error) {\n          // TODO: Only do on certain responses: retryCodes.\n\n          attempt++\n          if (attempt >= retryAttempts) {\n            throw error\n          }\n\n          // Exponentially increase the retry delay.\n          await delay(retryDelay * Math.pow(2, attempt - 1))\n        }\n      }\n      return executeFetch()\n    }\n\n    try {\n      const [response, result] = await retryRequest()\n      if (!response.ok) {\n        throw new Error(response.statusText)\n      }\n      return [response, result]\n    } catch (error) {\n      throw error\n    }\n  }\n\n  return async (\n    sendOptions: SendOptions,\n  ): Promise<[Response, any]> => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise((resolve) => {\n        let interval: number | null = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency!) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    try {\n      return await sendRequest(\n        options,\n      )\n    } finally {\n      activeRequests--\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
