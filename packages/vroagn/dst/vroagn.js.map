{
  "version": 3,
  "sources": ["../src/utilities/clone.js", "../src/utilities/delay.js", "../src/utilities/type.js", "../src/library/request.js", "../src/library/parsers/csv.js", "../src/library/parsers/ini.js", "../src/library/parsers/toml.js", "../src/library/parsers/yaml.js"],
  "sourcesContent": ["/**\n * Creates a deep clone of a javascript value.\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n", "/**\n * Delays the execution for a specified amount of time.\n * @param {number} time - The amount of time to delay in milliseconds.\n * @returns {Promise<null>} A promise that resolves after the delay.\n */\nexport const delay = async (\n  time,\n) => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time),\n    )\n  }\n  return null\n}\n", "/**\n * Normalize the content type by removing any parameters and converting to lowercase.\n * @param {string} contentType - The content type to normalize.\n * @returns {string} - The normalized content type.\n */\nconst normalizeContentType = (contentType) => contentType.split(';')[0].trim().toLowerCase()\n\n/**\n * Extract the file extension from a URL.\n * @param {string} url - The URL to extract the file extension from.\n * @returns {string|null} - The file extension or null if not found.\n */\nconst getFileExtension = (\n  url,\n) => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\n/**\n * Get the type of the resource based on the URL, response headers, and request headers.\n * @param {string} url - The URL of the resource.\n * @param {Headers} responseHeaders - The response headers.\n * @param {Record<string, string>} [requestHeaders] - The request headers.\n * @returns {string} - The type of the resource.\n */\nexport const getType = (\n  url,\n  responseHeaders,\n  requestHeaders,\n) => {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n", "import { cloneRecursive } from '../utilities/clone.js'\nimport { delay } from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\n/**\n * @typedef {Object} ResponseParser\n * @property {string[]} types\n * @property {(response: Response, options: RequestOptions, type: string) => any} parser\n */\n\n/**\n * @typedef {Object} SendOptions\n * @property {any} [body]\n * @property {RequestCredentials} [credentials]\n * @property {string} [domain]\n * @property {Record<string, string>} [headers]\n * @property {'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'} [method]\n * @property {RequestMode} [mode]\n * @property {string} [path]\n * @property {'high' | 'normal' | 'low'} [priority]\n * @property {Record<string, string>} [queryParams]\n * @property {RequestRedirect} [redirect]\n * @property {ResponseParser[]} [parsers]\n * @property {string} [type]\n * @property {AbortController} [abort]\n * @property {RequestCache} [cache]\n * @property {(request: Request | string, requestOptions?: RequestInit) => Promise<Response>} [fetch]\n * @property {number} [debounce]\n * @property {number} [delay]\n * @property {number} [throttle]\n * @property {number} [timeout]\n * @property {number} [retryAttempts]\n * @property {number[]} [retryCodes]\n * @property {number} [retryDelay]\n */\n\n/**\n * @typedef {SendOptions & { maxConcurrency?: number, maxRequests?: number }} RequestOptions\n */\n\nconst DEFAULT_VALUES = {\n  method: 'get',\n  retryCodes: [429, 503, 504],\n  retryDelay: 500,\n}\n\n/**\n * @param {RequestOptions} initialOptions\n */\nexport const create = (\n  initialOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0\n  let debounceTimeout = null\n\n  /**\n   * @param {number} throttleValue\n   */\n  const throttle = async (\n    throttleValue,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (waitTime > 0 ? waitTime : 0)\n    await delay(waitTime)\n  }\n\n  /**\n   * @param {number} debounceValue\n   * @returns {Promise<void>}\n   */\n  const debounce = (\n    debounceValue,\n  ) => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(resolve, debounceValue)\n    })\n  }\n\n  /**\n   * @param {RequestOptions} options\n   * @returns {Promise<[Error | null, Response | null, any]>}\n   */\n  const sendRequest = async (\n    options,\n  ) => {\n    if (\n      options.maxRequests !== undefined\n      && totalRequests >= options.maxRequests\n    ) {\n      return [new Error('Maximum request limit reached'), null, null]\n    }\n\n    totalRequests++\n\n    const config = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n      body: options.body ? JSON.stringify(options.body) : undefined,\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(options.queryParams).toString()\n    }\n\n    if (options.timeout) {\n      const controller = options.abort || new AbortController()\n      config.signal = controller.signal\n      setTimeout(() => controller.abort(), options.timeout)\n    }\n\n    /**\n     * @returns {Promise<[Error | null, Response, any]>}\n     */\n    const executeFetch = async () => {\n      const response = await (options.fetch ?? fetch)(url, config)\n      if (!response.ok) {\n        return [new Error('Invalid response'), response, null]\n      }\n\n      try {\n        let result\n        let foundParser = false\n        const type = options.type || getType(url, response.headers, options.headers)\n        if (options.parsers) {\n          for (const parser of options.parsers) {\n            foundParser = parser.types.includes(type)\n            if (foundParser) {\n              result = await parser.parser(response, options, type)\n              break\n            }\n          }\n        }\n        if (!foundParser) {\n          switch (type.toLowerCase()) {\n            case 'arraybuffer':\n              result = await response.arrayBuffer()\n              break\n            case 'blob':\n              result = await response.blob()\n              break\n            case 'formdata':\n              result = await response.formData()\n              break\n            case 'text/plain':\n            case 'text':\n            case 'txt':\n              result = await response.text()\n              break\n            case 'text/html-partial':\n            case 'html-partial':\n              result = await response.text()\n              const template = document.createElement('template')\n              template.innerHTML = result\n              result = template.content.childNodes\n              break\n            case 'text/html':\n            case 'html':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'text/html')\n              break\n            case 'application/json':\n            case 'text/json':\n            case 'json':\n              result = await response.json()\n              break\n            case 'image/svg+xml':\n            case 'svg':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'image/svg+xml')\n              break\n            case 'application/xml':\n            case 'text/xml':\n            case 'xml':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'application/xml')\n              break\n          }\n        }\n\n        return [null, response, result]\n      } catch (error) {\n        return [error || new Error('Thrown parsing error is falsy'), response, null]\n      }\n    }\n\n    /**\n     * @returns {Promise<[Error | null, Response, any]>}\n     */\n    const retryRequest = async () => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        const [error, response, result] = await executeFetch()\n        if (!error) {\n          return [error, response, result]\n        }\n        if (!options.retryCodes?.includes(response.status || 200)) {\n          return [new Error('Invalid status code'), response, result]\n        }\n\n        attempt++\n        if (attempt >= retryAttempts) {\n          return [new Error('Too many retry attempts'), response, result]\n        }\n\n        let delayTime = retryDelay * Math.pow(2, attempt - 1)\n\n        const retryAfter = response.headers.get('Retry-After')\n        if (retryAfter) {\n          const retryAfterSeconds = parseInt(retryAfter, 10)\n          if (!isNaN(retryAfterSeconds)) {\n            delayTime = Math.max(delayTime, retryAfterSeconds * 1000)\n          } else {\n            const retryAfterDate = new Date(retryAfter).getTime()\n            if (!isNaN(retryAfterDate)) {\n              const currentTime = Date.now()\n              delayTime = Math.max(delayTime, retryAfterDate - currentTime)\n            }\n          }\n        }\n\n        await delay(delayTime)\n      }\n      return executeFetch()\n    }\n\n    const [error, response, result] = await retryRequest()\n    if (!response.ok) {\n      return [new Error(response.statusText), response, result]\n    }\n    return [error, response, result]\n  }\n\n  /**\n   * @param {SendOptions} sendOptions\n   * @returns {Promise<[Error | null, Response | null, any]>}\n   */\n  return async (\n    sendOptions,\n  ) => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise(resolve => {\n        let interval = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    const results = await sendRequest(options)\n    activeRequests--\n    return results\n  }\n}\n", "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} CsvOptions\n * @property {string[]} [types]\n * @property {boolean} [hasHeaders]\n * @property {string} [columnDelimiter]\n * @property {string} [rowDelimiter]\n * @property {string} [escapeCharacter]\n */\n\nconst tsvTypes = [\n  'tsv',\n  'text/tab-separated-values',\n]\n\n/**\n * @param {CsvOptions} options\n * @returns {ResponseParser}\n */\nexport const csvParser = (options) => {\n  return {\n    types: options?.types || [\n      'csv', 'text/csv',\n      ...tsvTypes,\n    ],\n\n    /**\n     * @param {Response} response\n     * @param {RequestOptions} requestOptions\n     * @param {string} type\n     * @returns {Promise<any>}\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const optionsTemp = {\n        columnDelimiter: (\n          tsvTypes.includes(type)\n            ? '\t'\n            : ','\n        ),\n        rowDelimiter: '\\n',\n        escapeCharacter: '\"',\n\n        ...options,\n      }\n\n      const string = await response.text()\n\n      const rows = []\n      let currentRow = []\n      let currentField = ''\n      let insideQuotes = false\n\n      for (let i = 0; i < string.length; i++) {\n        const character = string[i]\n        const nextCharacter = string[i + 1]\n\n        if (character === optionsTemp.escapeCharacter) {\n          if (\n            nextCharacter === optionsTemp.escapeCharacter\n            && insideQuotes\n          ) {\n            // Double quotes inside quotes.\n            currentField += optionsTemp.escapeCharacter\n            i++ // Skip next quote.\n          } else {\n            // Toggle insideQuotes.\n            insideQuotes = !insideQuotes\n          }\n        } else if (\n          character === optionsTemp.columnDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n        } else if (\n          character === optionsTemp.rowDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n\n          rows.push(currentRow)\n          currentRow = []\n        } else {\n          currentField += character\n        }\n      }\n\n      // Push the last field and row if there's any.\n      if (currentField) {\n        currentRow.push(\n          currentField,\n        )\n        currentField = ''\n      }\n      if (currentRow.length > 0) {\n        rows.push(currentRow)\n      }\n\n      if (optionsTemp.hasHeaders) {\n        // Extract headers and create objects.\n        const headers = rows[0]\n        return rows.slice(1).map(row => {\n          return headers.reduce((\n            object,\n            header,\n            index,\n          ) => {\n            object[header] = row[index] || ''\n            return object\n          }, {})\n        })\n      }\n\n      return rows\n    }\n  }\n}\n", "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} IniOptions\n * @property {string[]} [types]\n */\n\n/**\n * @typedef {Object} IniObject\n * @property {Object.<string, Object.<string, string>>} IniObject\n */\n\n/**\n * @param {IniOptions} [options={}]\n * @returns {ResponseParser}\n */\nexport const iniParser = (\n  options = {},\n) => {\n  return {\n    types: options.types || ['ini'],\n\n    /**\n     * @param {Response} response\n     * @param {RequestOptions} requestOptions\n     * @returns {Promise<IniObject>}\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const text = await response.text()\n\n      const result = {}\n      const lines = text\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n\n      let currentSection = ''\n      for (const line of lines) {\n        if (\n          line === ''\n          || line.startsWith(';')\n          || line.startsWith('#')\n        ) {\n          // Skip empty lines and comments.\n          continue\n        }\n\n        if (\n          line.startsWith('[')\n          && line.endsWith(']')\n        ) {\n          // New section.\n          currentSection = line.slice(1, -1).trim()\n          if (!result[currentSection]) {\n            result[currentSection] = {}\n          }\n        } else {\n          // Key-value pair.\n          const [key, ...valueParts] = line.split('=')\n          const value = valueParts.join('=').trim()\n\n          if (currentSection === '') {\n            // Global section (outside any named section).\n            if (!result['global']) {\n              result['global'] = {}\n            }\n            result['global'][key.trim()] = value\n          } else {\n            result[currentSection][key.trim()] = value\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n", "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} TomlOptions\n * @property {string[]} [types]\n */\n\n/**\n * @typedef {string | number | boolean | Date | TomlObject | TomlValue[]} TomlValue\n */\n\n/**\n * @typedef {Object.<string, TomlValue>} TomlObject\n */\n\n/**\n * @param {string} value\n * @returns {TomlValue}\n */\nconst parseTomlValue = (value) => {\n  if (value.startsWith('\"') && value.endsWith('\"')) {\n    return value.slice(1, -1)\n  }\n  if (value.startsWith(\"'\") && value.endsWith(\"'\")) {\n    return value.slice(1, -1)\n  }\n  if (value === 'true' || value === 'false') {\n    return value === 'true'\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (value.match(/^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(.\\d+)?(Z|[+-]\\d{2}:\\d{2})?)?$/)) {\n    return new Date(value)\n  }\n  return value\n}\n\n/**\n * @param {string} tableString\n * @returns {TomlObject}\n */\nconst parseInlineTable = (tableString) => {\n  const result = {}\n  let key = ''\n  let value = ''\n  let inQuotes = false\n  let quoteChar = ''\n  let inValue = false\n\n  for (let i = 1; i < tableString.length - 1; i++) {\n    const character = tableString[i]\n    if (!inQuotes && (character === '\"' || character === \"'\")) {\n      inQuotes = true\n      quoteChar = character\n    } else if (inQuotes && character === quoteChar) {\n      inQuotes = false\n    } else if (!inQuotes && character === '=') {\n      inValue = true\n    } else if (!inQuotes && character === ',') {\n      result[key.trim()] = parseTomlValue(value.trim())\n      key = ''\n      value = ''\n      inValue = false\n    } else {\n      if (inValue) {\n        value += character\n      } else {\n        key += character\n      }\n    }\n  }\n\n  if (key) {\n    result[key.trim()] = parseTomlValue(value.trim())\n  }\n\n  return result\n}\n\n/**\n * @param {TomlOptions} [options={}]\n * @returns {ResponseParser}\n */\nexport const tomlParser = (\n  options = {},\n) => {\n  return {\n    types: options.types || [\n      'toml',\n      'application/toml',\n    ],\n\n    /**\n     * @param {Response} response\n     * @param {RequestOptions} requestOptions\n     * @param {string} type\n     * @returns {Promise<TomlObject>}\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const text = await response.text()\n\n      const result = {}\n      let currentTable = result\n      let currentArray = null\n      let multilineString = null\n      let multilineStringDelimiter = null\n\n      const lines = text.split(/\\r?\\n/)\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trim()\n\n        if (line === '' || line.startsWith('#')) {\n          continue // Skip empty lines and comments\n        }\n\n        if (multilineString !== null) {\n          if (line.endsWith(multilineStringDelimiter)) {\n            multilineString += line.slice(0, -multilineStringDelimiter.length)\n            currentTable[Object.keys(currentTable).pop()] = multilineString\n            multilineString = null\n            multilineStringDelimiter = null\n          } else {\n            multilineString += line + '\\n'\n          }\n          continue\n        }\n\n        if (line.startsWith('[') && line.endsWith(']')) {\n          // Table\n          const tableName = line.slice(1, -1).trim()\n          currentTable = result\n          const parts = tableName.split('.')\n          for (const part of parts) {\n            if (!currentTable[part]) currentTable[part] = {}\n            currentTable = currentTable[part]\n          }\n          currentArray = null\n        } else if (line.startsWith('[[') && line.endsWith(']]')) {\n          // Array of Tables\n          const arrayName = line.slice(2, -2).trim()\n          const parts = arrayName.split('.')\n          let parent = result\n          for (let i = 0; i < parts.length - 1; i++) {\n            if (!parent[parts[i]]) parent[parts[i]] = {}\n            parent = parent[parts[i]]\n          }\n          const lastPart = parts[parts.length - 1]\n          if (!parent[lastPart]) parent[lastPart] = []\n          const newTable = {}\n          parent[lastPart].push(newTable)\n          currentTable = newTable\n          currentArray = null\n        } else {\n          // Key-value pair\n          const [key, ...valueParts] = line.split('=')\n          let value = valueParts.join('=').trim()\n\n          if (value.startsWith('\"\"\"') || value.startsWith(\"'''\")) {\n            // Multi-line string\n            multilineStringDelimiter = value.slice(0, 3)\n            multilineString = value.slice(3)\n            if (value.endsWith(multilineStringDelimiter)) {\n              currentTable[key.trim()] = multilineString.slice(0, -3)\n              multilineString = null\n              multilineStringDelimiter = null\n            }\n          } else if (value.startsWith('{') && value.endsWith('}')) {\n            // Inline table\n            currentTable[key.trim()] = parseInlineTable(value)\n          } else if (value.startsWith('[') && !value.endsWith(']')) {\n            // Multi-line array\n            currentArray = []\n            value = value.slice(1).trim()\n          } else {\n            if (currentArray !== null) {\n              if (value.endsWith(']')) {\n                currentArray.push(parseTomlValue(value.slice(0, -1).trim()))\n                currentTable[key.trim()] = currentArray\n                currentArray = null\n              } else {\n                currentArray.push(parseTomlValue(value))\n              }\n            } else {\n              currentTable[key.trim()] = parseTomlValue(value)\n            }\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n", "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} YamlOptions\n * @property {string[]} [types]\n * @property {number} [indentSize]\n */\n\n/**\n * @typedef {string | number | boolean | null | YamlObject | YamlValue[]} YamlValue\n */\n\n/**\n * @typedef {Object.<string, YamlValue>} YamlObject\n */\n\n/**\n * Parses a YAML value.\n * @param {string} value\n * @param {Record<string, YamlValue>} anchors\n * @returns {YamlValue}\n */\nconst parseValue = (value, anchors) => {\n  if (value === 'null' || value === '~') {\n    return null\n  }\n  if (value === 'true') {\n    return true\n  }\n  if (value === 'false') {\n    return false\n  }\n  if (value.startsWith('\"') && value.endsWith('\"')) {\n    return value.slice(1, -1)\n  }\n  if (value.startsWith(\"'\") && value.endsWith(\"'\")) {\n    return value.slice(1, -1)\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (value.startsWith('[') && value.endsWith(']')) {\n    return value.slice(1, -1).split(',').map(item => parseValue(item.trim(), anchors))\n  }\n  if (value.startsWith('*')) {\n    const anchorName = value.slice(1).trim()\n    return anchors[anchorName]\n  }\n  if (value.includes('!!')) {\n    const [tag, tagValue] = value.split(' ')\n    switch (tag) {\n      case '!!int':\n        return parseInt(tagValue)\n      case '!!float':\n        return parseFloat(tagValue)\n      case '!!str':\n        return tagValue\n      case '!!bool':\n        return tagValue.toLowerCase() === 'true'\n      default:\n        return tagValue\n    }\n  }\n  return value\n}\n\n/**\n * YAML parser.\n * @param {YamlOptions} [options={}]\n * @returns {ResponseParser}\n */\nexport const yamlParser = (\n  options = {},\n) => {\n  return {\n    types: options.types || [\n      'yaml',\n      'application/yaml',\n      'text/yaml',\n    ],\n\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const lines = (await response.text()).split('\\n')\n      const result = {}\n      let currentObject = result\n      let indentStack = [result]\n      let currentIndent = 0\n      let multilineKey = null\n      let multilineValue = []\n      const anchors = {}\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trimEnd()\n        if (line.trim().startsWith('#')) {\n          continue\n        }\n\n        const indent = line.search(/\\S/)\n\n        if (multilineKey !== null) {\n          if (indent > currentIndent) {\n            multilineValue.push(line.trim())\n            continue\n          } else {\n            currentObject[multilineKey] = multilineValue.join('\\n')\n            multilineKey = null\n            multilineValue = []\n          }\n        }\n\n        if (indent > currentIndent) {\n          indentStack.push(currentObject)\n          currentObject = currentObject[Object.keys(currentObject).pop()]\n        } else if (indent < currentIndent) {\n          while (indent < currentIndent) {\n            indentStack.pop()\n            currentObject = indentStack[indentStack.length - 1]\n            currentIndent -= options.indentSize || 2\n          }\n        }\n\n        currentIndent = indent\n\n        if (line.trim() === '-') {\n          if (!Array.isArray(currentObject)) {\n            const lastKey = Object.keys(currentObject).pop()\n            currentObject[lastKey] = []\n            currentObject = currentObject[lastKey]\n          }\n          currentObject.push({})\n          currentObject = currentObject[currentObject.length - 1]\n          continue\n        }\n\n        const colonIndex = line.indexOf(':')\n        if (colonIndex === -1) {\n          continue\n        }\n\n        const key = line.slice(0, colonIndex).trim()\n        let value = line.slice(colonIndex + 1).trim()\n\n        if (value.startsWith('&')) {\n          const anchorName = value.slice(1).split(' ')[0]\n          value = value.slice(anchorName.length + 2).trim()\n          const parsedValue = parseValue(value, anchors)\n          anchors[anchorName] = parsedValue\n          currentObject[key] = parsedValue\n        } else if (value.startsWith('*')) {\n          const anchorName = value.slice(1).trim()\n          currentObject[key] = anchors[anchorName]\n        } else if (value === '|' || value === '>') {\n          multilineKey = key\n          currentIndent += options.indentSize || 2\n        } else if (value) {\n          currentObject[key] = parseValue(value, anchors)\n        } else {\n          currentObject[key] = {}\n        }\n      }\n\n      return result\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["response", "result", "error", "i"]
}
