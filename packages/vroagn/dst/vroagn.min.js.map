{
  "version": 3,
  "sources": ["../src/utilities/clone.js", "../src/utilities/delay.js", "../src/utilities/type.js", "../src/library/request.js", "../src/library/parsers/csv.js", "../src/library/parsers/ini.js", "../src/library/parsers/toml.js", "../src/library/parsers/yaml.js"],
  "sourcesContent": [
    "/**\n * Creates a deep clone of a javascript value.\n *\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n",
    "/**\n * Delays the execution for a specified amount of time.\n *\n * @param {number} time The amount of time to delay in milliseconds.\n * @returns {Promise<null>} A promise that resolves after the delay.\n */\nexport const delay = async (\n  time,\n) => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time),\n    )\n  }\n  return null\n}\n",
    "/**\n * Normalize the content type by removing any parameters and converting to lowercase.\n *\n * @param {string} contentType The content type to normalize.\n * @returns {string} The normalized content type.\n */\nconst normalizeContentType = (\n  contentType,\n) => contentType.split(';')[0].trim().toLowerCase()\n\n/**\n * Extract the file extension from a URL.\n *\n * @param {string} url The URL to extract the file extension from.\n * @returns {string|null} The file extension or null if not found.\n */\nconst getFileExtension = (\n  url,\n) => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\n/**\n * Get the type of the resource based on the URL, response headers, and request headers.\n *\n * @param {string} url The URL of the resource.\n * @param {Headers} responseHeaders The response headers.\n * @param {Record<string, string>} [requestHeaders] The request headers.\n * @returns {string} The type of the resource.\n */\nexport const getType = (\n  url,\n  responseHeaders,\n  requestHeaders,\n) => {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n",
    "import { cloneRecursive } from '../utilities/clone.js'\nimport { delay } from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\n/**\n * @typedef {Object} ResponseParser Defines a response parser.\n * @property {string[]} types The types of responses the parser can handle.\n * @property {(response: Response, options: RequestOptions, type: string) => any} parser The function to parse the response.\n **/\n\n/**\n * @typedef {Object} SendOptions Defines the options for sending a request.\n * @property {any} [body] The body of the request.\n * @property {RequestCredentials} [credentials] The credentials for the request.\n * @property {string} [domain] The domain for the request.\n * @property {Record<string, string>} [headers] The headers for the request.\n * @property {'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'} [method] The HTTP method for the request.\n * @property {RequestMode} [mode] The mode for the request.\n * @property {string} [path] The path for the request.\n * @property {'high' | 'normal' | 'low'} [priority] The priority of the request.\n * @property {Record<string, string>} [queryParams] The query parameters for the request.\n * @property {RequestRedirect} [redirect] The redirect mode for the request.\n * @property {ResponseParser[]} [parsers] The parsers for the response.\n * @property {string} [type] The expected response type.\n * @property {AbortController} [abort] The abort controller for the request.\n * @property {RequestCache} [cache] The cache mode for the request.\n * @property {(request: Request | string, requestOptions?: RequestInit) => Promise<Response>} [fetch] The fetch function to use for the request.\n * @property {number} [debounce] The debounce time for the request.\n * @property {number} [delay] The delay time for the request.\n * @property {number} [throttle] The throttle time for the request.\n * @property {number} [timeout] The timeout for the request.\n * @property {number} [retryAttempts] The number of retry attempts for the request.\n * @property {number[]} [retryCodes] The HTTP status codes that should trigger a retry.\n * @property {number} [retryDelay] The delay between retry attempts.\n **/\n\n/**\n * @typedef {SendOptions & { maxConcurrency?: number, maxRequests?: number }} RequestOptions Defines the options for creating a request handler.\n */\n\n// Default values for the request handler.\nconst DEFAULT_VALUES = {\n  method: 'get',\n  retryCodes: [429, 503, 504],\n  retryDelay: 500,\n}\n\n/**\n * Creates a request handler.\n *\n * @param {RequestOptions} initialOptions The initial options for the request handler.\n * @returns {(sendOptions: SendOptions) => Promise<[Error | null, Response | null, any]>} The request handler.\n */\nexport const create = (\n  initialOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0\n  let debounceTimeout = null\n\n  /**\n   * @param {number} throttleValue\n   */\n  const throttle = async (\n    throttleValue,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (waitTime > 0 ? waitTime : 0)\n    await delay(waitTime)\n  }\n\n  /**\n   * Debounces the request handler.\n   *\n   * @param {number} debounceValue The debounce time in milliseconds.\n   * @returns {Promise<void>} A promise that resolves after the debounce time.\n   */\n  const debounce = (\n    debounceValue,\n  ) => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(resolve, debounceValue)\n    })\n  }\n\n  /**\n   * Sends a request.\n   *\n   * @param {RequestOptions} options The options for the request.\n   * @returns {Promise<[Error | null, Response | null, any]>} The error, response and result of the request.\n   */\n  const sendRequest = async (\n    options,\n  ) => {\n    if (\n      options.maxRequests !== undefined\n      && totalRequests >= options.maxRequests\n    ) {\n      return [new Error('Maximum request limit reached'), null, null]\n    }\n\n    totalRequests++\n\n    const config = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n      body: options.body ? JSON.stringify(options.body) : undefined,\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(options.queryParams).toString()\n    }\n\n    if (options.timeout) {\n      const controller = options.abort || new AbortController()\n      config.signal = controller.signal\n      setTimeout(() => controller.abort(), options.timeout)\n    }\n\n    /**\n     * @returns {Promise<[Error | null, Response, any]>}\n     */\n    const executeFetch = async () => {\n      const response = await (options.fetch ?? fetch)(url, config)\n      if (!response.ok) {\n        return [new Error('Invalid response'), response, null]\n      }\n\n      try {\n        let result\n        let foundParser = false\n        const type = options.type || getType(url, response.headers, options.headers)\n        if (options.parsers) {\n          for (const parser of options.parsers) {\n            foundParser = parser.types.includes(type)\n            if (foundParser) {\n              result = await parser.parser(response, options, type)\n              break\n            }\n          }\n        }\n        if (!foundParser) {\n          switch (type.toLowerCase()) {\n            case 'arraybuffer':\n              result = await response.arrayBuffer()\n              break\n            case 'blob':\n              result = await response.blob()\n              break\n            case 'formdata':\n              result = await response.formData()\n              break\n            case 'text/plain':\n            case 'text':\n            case 'txt':\n              result = await response.text()\n              break\n            case 'text/html-partial':\n            case 'html-partial':\n              result = await response.text()\n              const template = document.createElement('template')\n              template.innerHTML = result\n              result = template.content.childNodes\n              break\n            case 'text/html':\n            case 'html':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'text/html')\n              break\n            case 'application/json':\n            case 'text/json':\n            case 'json':\n              result = await response.json()\n              break\n            case 'image/svg+xml':\n            case 'svg':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'image/svg+xml')\n              break\n            case 'application/xml':\n            case 'text/xml':\n            case 'xml':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'application/xml')\n              break\n          }\n        }\n\n        return [null, response, result]\n      } catch (error) {\n        return [error || new Error('Thrown parsing error is falsy'), response, null]\n      }\n    }\n\n    /**\n     * Retries the request.\n     *\n     * @returns {Promise<[Error | null, Response, any]>} The error, response and result of the request.\n     */\n    const retryRequest = async () => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        const [error, response, result] = await executeFetch()\n        if (!error) {\n          return [error, response, result]\n        }\n        if (!options.retryCodes?.includes(response.status || 200)) {\n          return [new Error('Invalid status code'), response, result]\n        }\n\n        attempt++\n        if (attempt >= retryAttempts) {\n          return [new Error('Too many retry attempts'), response, result]\n        }\n\n        let delayTime = retryDelay * Math.pow(2, attempt - 1)\n\n        const retryAfter = response.headers.get('Retry-After')\n        if (retryAfter) {\n          const retryAfterSeconds = parseInt(retryAfter, 10)\n          if (!isNaN(retryAfterSeconds)) {\n            delayTime = Math.max(delayTime, retryAfterSeconds * 1000)\n          } else {\n            const retryAfterDate = new Date(retryAfter).getTime()\n            if (!isNaN(retryAfterDate)) {\n              const currentTime = Date.now()\n              delayTime = Math.max(delayTime, retryAfterDate - currentTime)\n            }\n          }\n        }\n\n        await delay(delayTime)\n      }\n      return executeFetch()\n    }\n\n    const [error, response, result] = await retryRequest()\n    if (!response.ok) {\n      return [new Error(response.statusText), response, result]\n    }\n    return [error, response, result]\n  }\n\n  /**\n   * Sends a request.\n   *\n   * @param {SendOptions} sendOptions The options for sending the request.\n   * @returns {Promise<[Error | null, Response | null, any]>} The error, response and result of the request.\n   */\n  return async (\n    sendOptions,\n  ) => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise(resolve => {\n        let interval = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    const results = await sendRequest(options)\n    activeRequests--\n    return results\n  }\n}\n",
    "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} CsvOptions Options for the CSV parser.\n * @property {string[]} [types] MIME types to parse as CSV.\n * @property {boolean} [hasHeaders] Whether the CSV has headers.\n * @property {string} [columnDelimiter] The column delimiter.\n * @property {string} [rowDelimiter] The row delimiter.\n * @property {string} [escapeCharacter] The escape character.\n */\n\nconst tsvTypes = [\n  'tsv',\n  'text/tab-separated-values',\n]\n\n/**\n * CSV parser.\n *\n * @param {CsvOptions} options Options for the CSV parser.\n * @returns {ResponseParser} A response parser.\n */\nexport const csvParser = (\n  options,\n) => {\n  return {\n    types: options?.types || [\n      'csv',\n      'text/csv',\n      ...tsvTypes,\n    ],\n\n    /**\n     * Parse the response as CSV.\n     *\n     * @param {Response} response The response to parse.\n     * @param {RequestOptions} requestOptions The request options.\n     * @param {string} type The MIME type of the response.\n     * @returns {Promise<any>} The parsed response.\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const optionsTemp = {\n        columnDelimiter: (\n          tsvTypes.includes(type)\n            ? '\\t'\n            : ','\n        ),\n        rowDelimiter: '\\n',\n        escapeCharacter: '\"',\n\n        ...options,\n      }\n\n      const string = await response.text()\n\n      const rows = []\n      let currentRow = []\n      let currentField = ''\n      let insideQuotes = false\n\n      for (let i = 0; i < string.length; i++) {\n        const character = string[i]\n        const nextCharacter = string[i + 1]\n\n        if (character === optionsTemp.escapeCharacter) {\n          if (\n            nextCharacter === optionsTemp.escapeCharacter\n            && insideQuotes\n          ) {\n            // Double quotes inside quotes.\n            currentField += optionsTemp.escapeCharacter\n            i++ // Skip next quote.\n          } else {\n            // Toggle insideQuotes.\n            insideQuotes = !insideQuotes\n          }\n        } else if (\n          character === optionsTemp.columnDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n        } else if (\n          character === optionsTemp.rowDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n\n          rows.push(currentRow)\n          currentRow = []\n        } else {\n          currentField += character\n        }\n      }\n\n      // Push the last field and row if there's any.\n      if (currentField) {\n        currentRow.push(\n          currentField,\n        )\n        currentField = ''\n      }\n      if (currentRow.length > 0) {\n        rows.push(currentRow)\n      }\n\n      if (optionsTemp.hasHeaders) {\n        // Extract headers and create objects.\n        const headers = rows[0]\n        return rows.slice(1).map(row => {\n          return headers.reduce((\n            object,\n            header,\n            index,\n          ) => {\n            object[header] = row[index] || ''\n            return object\n          }, {})\n        })\n      }\n\n      return rows\n    }\n  }\n}\n",
    "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} IniOptions Options for the INI parser.\n * @property {string[]} [types] The types that should be parsed as INI.\n */\n\n/**\n * @typedef {Object} IniObject The parsed INI object.\n * @property {Object.<string, Object.<string, string>>} IniObject The parsed INI object.\n */\n\n/**\n * INI parser.\n *\n * @param {IniOptions} [options={}] Options for the INI parser.\n * @returns {ResponseParser} The INI parser.\n */\nexport const iniParser = (\n  options = {},\n) => {\n  return {\n    types: options.types || ['ini'],\n\n    /**\n     * Parse the response as an INI object.\n     *\n     * @param {Response} response The response to parse.\n     * @param {RequestOptions} requestOptions The request options.\n     * @param {string} type The MIME type of the response.\n     * @returns {Promise<IniObject>} The parsed INI object.\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const text = await response.text()\n\n      const result = {}\n      const lines = text\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n\n      let currentSection = ''\n      for (const line of lines) {\n        if (\n          line === ''\n          || line.startsWith(';')\n          || line.startsWith('#')\n        ) {\n          // Skip empty lines and comments.\n          continue\n        }\n\n        if (\n          line.startsWith('[')\n          && line.endsWith(']')\n        ) {\n          // New section.\n          currentSection = line.slice(1, -1).trim()\n          if (!result[currentSection]) {\n            result[currentSection] = {}\n          }\n        } else {\n          // Key-value pair.\n          const [key, ...valueParts] = line.split('=')\n          const value = valueParts.join('=').trim()\n\n          if (currentSection === '') {\n            // Global section (outside any named section).\n            if (!result['global']) {\n              result['global'] = {}\n            }\n            result['global'][key.trim()] = value\n          } else {\n            result[currentSection][key.trim()] = value\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n",
    "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} TomlOptions Options for the TOML parser.\n * @property {string[]} [types] The types that should be parsed as TOML.\n */\n\n/**\n * @typedef {string | number | boolean | Date | TomlObject | TomlValue[]} TomlValue The value of a TOML key.\n */\n\n/**\n * @typedef {Object.<string, TomlValue>} TomlObject The parsed TOML object.\n */\n\n/**\n * Parse a TOML value.\n *\n * @param {string} value The TOML value to parse.\n * @returns {TomlValue} The parsed TOML value.\n */\nconst parseTomlValue = (\n  value,\n) => {\n  if (\n    value.startsWith('\"')\n    && value.endsWith('\"')\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value.startsWith(\"'\")\n    && value.endsWith(\"'\")\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value === 'true'\n    || value === 'false'\n  ) {\n    return value === 'true'\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (value.match(/^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(.\\d+)?(Z|[+-]\\d{2}:\\d{2})?)?$/)) {\n    return new Date(value)\n  }\n  return value\n}\n\n/**\n * Parse an inline table.\n *\n * @param {string} tableString The inline table string.\n * @returns {TomlObject} The parsed inline table.\n */\nconst parseInlineTable = (\n  tableString,\n) => {\n  const result = {}\n  let key = ''\n  let value = ''\n  let inQuotes = false\n  let quoteChar = ''\n  let inValue = false\n\n  for (let i = 1; i < tableString.length - 1; i++) {\n    const character = tableString[i]\n    if (\n      !inQuotes\n      && (\n        character === '\"'\n        || character === \"'\"\n      )\n    ) {\n      inQuotes = true\n      quoteChar = character\n    } else if (\n      inQuotes\n      && character === quoteChar\n    ) {\n      inQuotes = false\n    } else if (\n      !inQuotes\n      && character === '='\n    ) {\n      inValue = true\n    } else if (\n      !inQuotes\n      && character === ','\n    ) {\n      result[key.trim()] = parseTomlValue(value.trim())\n      key = ''\n      value = ''\n      inValue = false\n    } else {\n      if (inValue) {\n        value += character\n      } else {\n        key += character\n      }\n    }\n  }\n\n  if (key) {\n    result[key.trim()] = parseTomlValue(\n      value.trim(),\n    )\n  }\n\n  return result\n}\n\n/**\n * TOML parser.\n *\n * @param {TomlOptions} [options={}] Options for the TOML parser.\n * @returns {ResponseParser} The TOML parser.\n */\nexport const tomlParser = (\n  options = {},\n) => {\n  return {\n    types: options.types || [\n      'toml',\n      'application/toml',\n    ],\n\n    /**\n     * Parse the response as a TOML object.\n     *\n     * @param {Response} response The response to parse.\n     * @param {RequestOptions} requestOptions The options for the request.\n     * @param {string} type The MIME type of the response.\n     * @returns {Promise<TomlObject>} The parsed TOML object.\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const text = await response.text()\n\n      const result = {}\n      let currentTable = result\n      let currentArray = null\n      let multilineString = null\n      let multilineStringDelimiter = null\n\n      const lines = text.split(/\\r?\\n/)\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trim()\n\n        if (line === '' || line.startsWith('#')) {\n          continue // Skip empty lines and comments\n        }\n\n        if (multilineString !== null) {\n          if (line.endsWith(multilineStringDelimiter)) {\n            multilineString += line.slice(0, -multilineStringDelimiter.length)\n            currentTable[Object.keys(currentTable).pop()] = multilineString\n            multilineString = null\n            multilineStringDelimiter = null\n          } else {\n            multilineString += line + '\\n'\n          }\n          continue\n        }\n\n        if (line.startsWith('[') && line.endsWith(']')) {\n          // Table\n          const tableName = line.slice(1, -1).trim()\n          currentTable = result\n          const parts = tableName.split('.')\n          for (const part of parts) {\n            if (!currentTable[part]) currentTable[part] = {}\n            currentTable = currentTable[part]\n          }\n          currentArray = null\n        } else if (line.startsWith('[[') && line.endsWith(']]')) {\n          // Array of Tables\n          const arrayName = line.slice(2, -2).trim()\n          const parts = arrayName.split('.')\n          let parent = result\n          for (let i = 0; i < parts.length - 1; i++) {\n            if (!parent[parts[i]]) parent[parts[i]] = {}\n            parent = parent[parts[i]]\n          }\n          const lastPart = parts[parts.length - 1]\n          if (!parent[lastPart]) parent[lastPart] = []\n          const newTable = {}\n          parent[lastPart].push(newTable)\n          currentTable = newTable\n          currentArray = null\n        } else {\n          // Key-value pair\n          const [key, ...valueParts] = line.split('=')\n          let value = valueParts.join('=').trim()\n\n          if (value.startsWith('\"\"\"') || value.startsWith(\"'''\")) {\n            // Multi-line string\n            multilineStringDelimiter = value.slice(0, 3)\n            multilineString = value.slice(3)\n            if (value.endsWith(multilineStringDelimiter)) {\n              currentTable[key.trim()] = multilineString.slice(0, -3)\n              multilineString = null\n              multilineStringDelimiter = null\n            }\n          } else if (value.startsWith('{') && value.endsWith('}')) {\n            // Inline table\n            currentTable[key.trim()] = parseInlineTable(value)\n          } else if (value.startsWith('[') && !value.endsWith(']')) {\n            // Multi-line array\n            currentArray = []\n            value = value.slice(1).trim()\n          } else {\n            if (currentArray !== null) {\n              if (value.endsWith(']')) {\n                currentArray.push(parseTomlValue(value.slice(0, -1).trim()))\n                currentTable[key.trim()] = currentArray\n                currentArray = null\n              } else {\n                currentArray.push(parseTomlValue(value))\n              }\n            } else {\n              currentTable[key.trim()] = parseTomlValue(value)\n            }\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n",
    "/**\n * @typedef {import('../request.js').RequestOptions} RequestOptions\n * @typedef {import('../request.js').ResponseParser} ResponseParser\n */\n\n/**\n * @typedef {Object} YamlOptions Options for the YAML parser.\n * @property {string[]} [types] Content types to parse as YAML.\n * @property {number} [indentSize] Number of spaces to use for indentation.\n */\n\n/**\n * @typedef {string | number | boolean | null | YamlObject | YamlValue[]} YamlValue YAML value.\n */\n\n/**\n * @typedef {Object.<string, YamlValue>} YamlObject YAML object.\n */\n\n/**\n * Parses a YAML value.\n *\n * @param {string} value Value to parse.\n * @param {Record<string, YamlValue>} anchors Anchors.\n * @returns {YamlValue} Parsed value.\n */\nconst parseValue = (value, anchors) => {\n  if (value === 'null' || value === '~') {\n    return null\n  }\n  if (value === 'true') {\n    return true\n  }\n  if (value === 'false') {\n    return false\n  }\n  if (value.startsWith('\"') && value.endsWith('\"')) {\n    return value.slice(1, -1)\n  }\n  if (value.startsWith(\"'\") && value.endsWith(\"'\")) {\n    return value.slice(1, -1)\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (value.startsWith('[') && value.endsWith(']')) {\n    return value.slice(1, -1).split(',').map(item => parseValue(item.trim(), anchors))\n  }\n  if (value.startsWith('*')) {\n    const anchorName = value.slice(1).trim()\n    return anchors[anchorName]\n  }\n  if (value.includes('!!')) {\n    const [tag, tagValue] = value.split(' ')\n    switch (tag) {\n      case '!!int':\n        return parseInt(tagValue)\n      case '!!float':\n        return parseFloat(tagValue)\n      case '!!str':\n        return tagValue\n      case '!!bool':\n        return tagValue.toLowerCase() === 'true'\n      default:\n        return tagValue\n    }\n  }\n  return value\n}\n\n/**\n * YAML parser.\n *\n * @param {YamlOptions} [options={}] Options for the YAML parser.\n * @returns {ResponseParser} Response parser that parses YAML.\n */\nexport const yamlParser = (\n  options = {},\n) => {\n  return {\n    types: options.types || [\n      'yaml',\n      'application/yaml',\n      'text/yaml',\n    ],\n\n    /**\n     * Parse the response as a YAML object.\n     *\n     * @param {Response} response The response to parse.\n     * @param {RequestOptions} requestOptions The request options.\n     * @param {string} type The MIME type of the response.\n     * @returns {Promise<YamlObject>} The parsed YAML object.\n     */\n    parser: async (\n      response,\n      requestOptions,\n      type,\n    ) => {\n      const lines = (await response.text()).split('\\n')\n      const result = {}\n      let currentObject = result\n      let indentStack = [result]\n      let currentIndent = 0\n      let multilineKey = null\n      let multilineValue = []\n      const anchors = {}\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trimEnd()\n        if (line.trim().startsWith('#')) {\n          continue\n        }\n\n        const indent = line.search(/\\S/)\n\n        if (multilineKey !== null) {\n          if (indent > currentIndent) {\n            multilineValue.push(line.trim())\n            continue\n          } else {\n            currentObject[multilineKey] = multilineValue.join('\\n')\n            multilineKey = null\n            multilineValue = []\n          }\n        }\n\n        if (indent > currentIndent) {\n          indentStack.push(currentObject)\n          currentObject = currentObject[Object.keys(currentObject).pop()]\n        } else if (indent < currentIndent) {\n          while (indent < currentIndent) {\n            indentStack.pop()\n            currentObject = indentStack[indentStack.length - 1]\n            currentIndent -= options.indentSize || 2\n          }\n        }\n\n        currentIndent = indent\n\n        if (line.trim() === '-') {\n          if (!Array.isArray(currentObject)) {\n            const lastKey = Object.keys(currentObject).pop()\n            currentObject[lastKey] = []\n            currentObject = currentObject[lastKey]\n          }\n          currentObject.push({})\n          currentObject = currentObject[currentObject.length - 1]\n          continue\n        }\n\n        const colonIndex = line.indexOf(':')\n        if (colonIndex === -1) {\n          continue\n        }\n\n        const key = line.slice(0, colonIndex).trim()\n        let value = line.slice(colonIndex + 1).trim()\n\n        if (value.startsWith('&')) {\n          const anchorName = value.slice(1).split(' ')[0]\n          value = value.slice(anchorName.length + 2).trim()\n          const parsedValue = parseValue(value, anchors)\n          anchors[anchorName] = parsedValue\n          currentObject[key] = parsedValue\n        } else if (value.startsWith('*')) {\n          const anchorName = value.slice(1).trim()\n          currentObject[key] = anchors[anchorName]\n        } else if (value === '|' || value === '>') {\n          multilineKey = key\n          currentIndent += options.indentSize || 2\n        } else if (value) {\n          currentObject[key] = parseValue(value, anchors)\n        } else {\n          currentObject[key] = {}\n        }\n      }\n\n      return result\n    }\n  }\n}\n"
  ],
  "mappings": "AAMO,IAAM,EAAiB,CAC5B,IACG,CACH,GAAI,OAAQ,IAAW,SAAU,CAC/B,IAAM,EACJ,MAAM,QAAQ,CAAK,EACf,CAAC,EACD,CAAC,EAEP,QAAW,KAAO,EAChB,EAAM,GAAO,EAAe,EAAM,EAAI,EAExC,OAAO,EAET,OAAO,GCdF,IAAM,EAAQ,MACnB,IACG,CACH,GAAI,EAAO,EACT,OAAO,IAAI,QACT,CAAC,IAAY,WAAW,EAAS,CAAI,CACvC,EAEF,OAAO,MCRT,IAAM,EAAuB,CAC3B,IACG,EAAY,MAAM,GAAG,EAAE,GAAG,KAAK,EAAE,YAAY,EAQ5C,EAAmB,CACvB,IACG,CACH,IAAM,EAAQ,EAAI,MAAM,uBAAuB,EAC/C,OAAO,EAAQ,EAAM,GAAG,YAAY,EAAI,MAW7B,EAAU,CACrB,EACA,EACA,IACG,CAEH,IAAM,EAAc,EAAgB,IAAI,cAAc,EACtD,GAAI,EACF,OAAO,EAAqB,CAAW,EAIzC,GAAI,GACF,GAAI,EAAe,OAAW,CAC5B,IAAM,EAAc,EAAe,OAAU,MAAM,GAAG,EACtD,QAAW,KAAQ,EACjB,GAAI,EAAK,KAAK,IAAM,MAClB,OAAO,EAAqB,CAAI,GAOxC,IAAM,EAAY,EAAiB,CAAG,EACtC,GAAI,EACF,OAAO,EAGT,MAAO,ICnBT,IAAM,EAAiB,CACrB,OAAQ,MACR,WAAY,CAAC,IAAK,IAAK,GAAG,EAC1B,WAAY,GACd,EAQa,EAAS,CACpB,IACG,CACH,EAAiB,IACZ,KACA,EAAe,CAAc,CAClC,EAEA,IAAI,EAAoB,EACpB,EAAiB,EACjB,EAAgB,EAChB,EAAkB,KAKhB,EAAW,MACf,IACG,CACH,IAAM,EAAM,KAAK,IAAI,EACf,EAAW,GAAiB,EAAM,GACxC,EAAoB,GAAO,EAAW,EAAI,EAAW,GACrD,MAAM,EAAM,CAAQ,GAShB,EAAW,CACf,IACG,CACH,OAAO,IAAI,QAAQ,CAAC,IAAY,CAC9B,GAAI,EACF,aAAa,CAAe,EAE9B,EAAkB,WAAW,EAAS,CAAa,EACpD,GASG,EAAc,MAClB,IACG,CACH,GACE,EAAQ,cAAgB,QACrB,GAAiB,EAAQ,YAE5B,MAAO,CAAK,MAAM,+BAA+B,EAAG,KAAM,IAAI,EAGhE,IAEA,IAAM,EAAS,CACb,MAAO,EAAQ,MACf,YAAa,EAAQ,YACrB,QAAS,EAAQ,QACjB,OAAQ,EAAQ,OAChB,KAAM,EAAQ,KACd,SAAU,EAAQ,SAClB,KAAM,EAAQ,KAAO,KAAK,UAAU,EAAQ,IAAI,EAAI,MACtD,EAEI,GAAO,EAAQ,QAAU,KAAO,EAAQ,MAAQ,IACpD,GAAI,EAAQ,YACV,GAAO,IAAM,IAAI,gBAAgB,EAAQ,WAAW,EAAE,SAAS,EAGjE,GAAI,EAAQ,QAAS,CACnB,IAAM,EAAa,EAAQ,OAAS,IAAI,gBACxC,EAAO,OAAS,EAAW,OAC3B,WAAW,IAAM,EAAW,MAAM,EAAG,EAAQ,OAAO,EAMtD,IAAM,EAAe,SAAY,CAC/B,IAAM,EAAW,MAAO,EAAQ,OAAS,OAAO,EAAK,CAAM,EAC3D,GAAI,CAAC,EAAS,GACZ,MAAO,CAAK,MAAM,kBAAkB,EAAG,EAAU,IAAI,EAGvD,GAAI,CACF,IAAI,EACA,EAAc,GACZ,EAAO,EAAQ,MAAQ,EAAQ,EAAK,EAAS,QAAS,EAAQ,OAAO,EAC3E,GAAI,EAAQ,SACV,QAAW,KAAU,EAAQ,QAE3B,GADA,EAAc,EAAO,MAAM,SAAS,CAAI,EACpC,EAAa,CACf,EAAS,MAAM,EAAO,OAAO,EAAU,EAAS,CAAI,EACpD,OAIN,GAAI,CAAC,EACH,OAAQ,EAAK,YAAY,OAClB,cACH,EAAS,MAAM,EAAS,YAAY,EACpC,UACG,OACH,EAAS,MAAM,EAAS,KAAK,EAC7B,UACG,WACH,EAAS,MAAM,EAAS,SAAS,EACjC,UACG,iBACA,WACA,MACH,EAAS,MAAM,EAAS,KAAK,EAC7B,UACG,wBACA,eACH,EAAS,MAAM,EAAS,KAAK,EAC7B,IAAM,EAAW,SAAS,cAAc,UAAU,EAClD,EAAS,UAAY,EACrB,EAAS,EAAS,QAAQ,WAC1B,UACG,gBACA,OACH,EAAS,MAAM,EAAS,KAAK,EAC7B,EAAS,IAAI,UAAU,EAAE,gBAAgB,EAAQ,WAAW,EAC5D,UACG,uBACA,gBACA,OACH,EAAS,MAAM,EAAS,KAAK,EAC7B,UACG,oBACA,MACH,EAAS,MAAM,EAAS,KAAK,EAC7B,EAAS,IAAI,UAAU,EAAE,gBAAgB,EAAQ,eAAe,EAChE,UACG,sBACA,eACA,MACH,EAAS,MAAM,EAAS,KAAK,EAC7B,EAAS,IAAI,UAAU,EAAE,gBAAgB,EAAQ,iBAAiB,EAClE,MAIN,MAAO,CAAC,KAAM,EAAU,CAAM,EAC9B,MAAO,EAAO,CACd,MAAO,CAAC,GAAa,MAAM,+BAA+B,EAAG,EAAU,IAAI,IASzE,EAAe,SAAY,CAC/B,IAAI,EAAU,EACR,EAAgB,EAAQ,eAAiB,EACzC,EAAa,EAAQ,YAAc,EAEzC,MAAO,EAAU,EAAe,CAC9B,IAAO,EAAO,EAAU,GAAU,MAAM,EAAa,EACrD,GAAI,CAAC,EACH,MAAO,CAAC,EAAO,EAAU,CAAM,EAEjC,GAAI,CAAC,EAAQ,YAAY,SAAS,EAAS,QAAU,GAAG,EACtD,MAAO,CAAK,MAAM,qBAAqB,EAAG,EAAU,CAAM,EAI5D,GADA,IACI,GAAW,EACb,MAAO,CAAK,MAAM,yBAAyB,EAAG,EAAU,CAAM,EAGhE,IAAI,EAAY,EAAa,KAAK,IAAI,EAAG,EAAU,CAAC,EAE9C,EAAa,EAAS,QAAQ,IAAI,aAAa,EACrD,GAAI,EAAY,CACd,IAAM,EAAoB,SAAS,EAAY,EAAE,EACjD,GAAI,CAAC,MAAM,CAAiB,EAC1B,EAAY,KAAK,IAAI,EAAW,EAAoB,IAAI,EACnD,KACL,IAAM,EAAiB,IAAI,KAAK,CAAU,EAAE,QAAQ,EACpD,GAAI,CAAC,MAAM,CAAc,EAAG,CAC1B,IAAM,EAAc,KAAK,IAAI,EAC7B,EAAY,KAAK,IAAI,EAAW,EAAiB,CAAW,IAKlE,MAAM,EAAM,CAAS,EAEvB,OAAO,EAAa,IAGf,EAAO,EAAU,GAAU,MAAM,EAAa,EACrD,GAAI,CAAC,EAAS,GACZ,MAAO,CAAK,MAAM,EAAS,UAAU,EAAG,EAAU,CAAM,EAE1D,MAAO,CAAC,EAAO,EAAU,CAAM,GASjC,MAAO,OACL,IACG,CACH,IAAM,EAAU,IACX,KACA,EAAe,CAAW,CAC/B,EACA,GAAI,EAAe,QACjB,EAAQ,QAAU,IACb,EAAe,WACf,EAAQ,OACb,EAGF,GAAI,EAAQ,SACV,MAAM,EAAS,EAAQ,QAAQ,EAGjC,GAAI,EAAQ,MACV,MAAM,EAAM,EAAQ,KAAK,EAG3B,GAAI,EAAQ,SACV,MAAM,EAAS,EAAQ,QAAQ,EAGjC,GACE,EAAQ,gBACL,GAAkB,EAAQ,eAE7B,MAAM,IAAI,QAAQ,KAAW,CAC3B,IAAI,EAAW,KACT,EAAO,IAAM,CACjB,GAAI,GAAkB,EAAQ,eAC5B,EAAW,sBAAsB,CAAI,EAChC,KACL,GAAI,EACF,cAAc,CAAQ,EAExB,EAAQ,IAAI,IAGhB,EAAW,sBAAsB,CAAI,EACtC,EAGH,IACA,IAAM,EAAU,MAAM,EAAY,CAAO,EAEzC,OADA,IACO,IC9SX,IAAM,EAAW,CACf,MACA,2BACF,EAQa,EAAY,CACvB,IACG,CACH,MAAO,CACL,MAAO,GAAS,OAAS,CACvB,MACA,WACA,GAAG,CACL,EAUA,OAAQ,MACN,EACA,EACA,IACG,CACH,IAAM,EAAc,CAClB,gBACE,EAAS,SAAS,CAAI,EAClB,KACA,IAEN,aAAc;AAAA,EACd,gBAAiB,OAEd,CACL,EAEM,EAAS,MAAM,EAAS,KAAK,EAE7B,EAAO,CAAC,EACV,EAAa,CAAC,EACd,EAAe,GACf,EAAe,GAEnB,QAAS,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACtC,IAAM,EAAY,EAAO,GACnB,EAAgB,EAAO,EAAI,GAEjC,GAAI,IAAc,EAAY,gBAC5B,GACE,IAAkB,EAAY,iBAC3B,EAGH,GAAgB,EAAY,gBAC5B,IAGA,OAAe,CAAC,EAEb,QACL,IAAc,EAAY,iBACvB,CAAC,EAEJ,EAAW,KACT,CACF,EACA,EAAe,GACV,QACL,IAAc,EAAY,cACvB,CAAC,EAEJ,EAAW,KACT,CACF,EACA,EAAe,GAEf,EAAK,KAAK,CAAU,EACpB,EAAa,CAAC,EAEd,QAAgB,EAKpB,GAAI,EACF,EAAW,KACT,CACF,EACA,EAAe,GAEjB,GAAI,EAAW,OAAS,EACtB,EAAK,KAAK,CAAU,EAGtB,GAAI,EAAY,WAAY,CAE1B,IAAM,EAAU,EAAK,GACrB,OAAO,EAAK,MAAM,CAAC,EAAE,IAAI,KAAO,CAC9B,OAAO,EAAQ,OAAO,CACpB,EACA,EACA,IACG,CAEH,OADA,EAAO,GAAU,EAAI,IAAU,GACxB,GACN,CAAC,CAAC,EACN,EAGH,OAAO,EAEX,GClHK,IAAM,EAAY,CACvB,EAAU,CAAC,IACR,CACH,MAAO,CACL,MAAO,EAAQ,OAAS,CAAC,KAAK,EAU9B,OAAQ,MACN,EACA,EACA,IACG,CACH,IAAM,EAAO,MAAM,EAAS,KAAK,EAE3B,EAAS,CAAC,EACV,EAAQ,EACX,MAAM,OAAO,EACb,IAAI,KAAQ,EAAK,KAAK,CAAC,EAEtB,EAAiB,GACrB,QAAW,KAAQ,EAAO,CACxB,GACE,IAAS,IACN,EAAK,WAAW,GAAG,GACnB,EAAK,WAAW,GAAG,EAGtB,SAGF,GACE,EAAK,WAAW,GAAG,GAChB,EAAK,SAAS,GAAG,GAIpB,GADA,EAAiB,EAAK,MAAM,EAAG,EAAE,EAAE,KAAK,EACpC,CAAC,EAAO,GACV,EAAO,GAAkB,CAAC,EAEvB,KAEL,IAAO,KAAQ,GAAc,EAAK,MAAM,GAAG,EACrC,EAAQ,EAAW,KAAK,GAAG,EAAE,KAAK,EAExC,GAAI,IAAmB,GAAI,CAEzB,GAAI,CAAC,EAAO,OACV,EAAO,OAAY,CAAC,EAEtB,EAAO,OAAU,EAAI,KAAK,GAAK,EAE/B,OAAO,GAAgB,EAAI,KAAK,GAAK,GAK3C,OAAO,EAEX,GC9DF,IAAM,EAAiB,CACrB,IACG,CACH,GACE,EAAM,WAAW,GAAG,GACjB,EAAM,SAAS,GAAG,EAErB,OAAO,EAAM,MAAM,EAAG,EAAE,EAE1B,GACE,EAAM,WAAW,GAAG,GACjB,EAAM,SAAS,GAAG,EAErB,OAAO,EAAM,MAAM,EAAG,EAAE,EAE1B,GACE,IAAU,QACP,IAAU,QAEb,OAAO,IAAU,OAEnB,GAAI,CAAC,MAAM,OAAO,CAAK,CAAC,EACtB,OAAO,OAAO,CAAK,EAErB,GAAI,EAAM,MAAM,qEAAqE,EACnF,OAAO,IAAI,KAAK,CAAK,EAEvB,OAAO,GASH,EAAmB,CACvB,IACG,CACH,IAAM,EAAS,CAAC,EACZ,EAAM,GACN,EAAQ,GACR,EAAW,GACX,EAAY,GACZ,EAAU,GAEd,QAAS,EAAI,EAAG,EAAI,EAAY,OAAS,EAAG,IAAK,CAC/C,IAAM,EAAY,EAAY,GAC9B,GACE,CAAC,IAEC,IAAc,KACX,IAAc,KAGnB,EAAW,GACX,EAAY,EACP,QACL,GACG,IAAc,EAEjB,EAAW,GACN,QACL,CAAC,GACE,IAAc,IAEjB,EAAU,GACL,QACL,CAAC,GACE,IAAc,IAEjB,EAAO,EAAI,KAAK,GAAK,EAAe,EAAM,KAAK,CAAC,EAChD,EAAM,GACN,EAAQ,GACR,EAAU,GAEV,QAAI,EACF,GAAS,EAET,QAAO,EAKb,GAAI,EACF,EAAO,EAAI,KAAK,GAAK,EACnB,EAAM,KAAK,CACb,EAGF,OAAO,GASI,EAAa,CACxB,EAAU,CAAC,IACR,CACH,MAAO,CACL,MAAO,EAAQ,OAAS,CACtB,OACA,kBACF,EAUA,OAAQ,MACN,EACA,EACA,IACG,CACH,IAAM,EAAO,MAAM,EAAS,KAAK,EAE3B,EAAS,CAAC,EACZ,EAAe,EACf,EAAe,KACf,EAAkB,KAClB,EAA2B,KAEzB,EAAQ,EAAK,MAAM,OAAO,EAChC,QAAS,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACrC,IAAI,EAAO,EAAM,GAAG,KAAK,EAEzB,GAAI,IAAS,IAAM,EAAK,WAAW,GAAG,EACpC,SAGF,GAAI,IAAoB,KAAM,CAC5B,GAAI,EAAK,SAAS,CAAwB,EACxC,GAAmB,EAAK,MAAM,EAAG,CAAC,EAAyB,MAAM,EACjE,EAAa,OAAO,KAAK,CAAY,EAAE,IAAI,GAAK,EAChD,EAAkB,KAClB,EAA2B,KAE3B,QAAmB,EAAO;AAAA,EAE5B,SAGF,GAAI,EAAK,WAAW,GAAG,GAAK,EAAK,SAAS,GAAG,EAAG,CAE9C,IAAM,EAAY,EAAK,MAAM,EAAG,EAAE,EAAE,KAAK,EACzC,EAAe,EACf,IAAM,EAAQ,EAAU,MAAM,GAAG,EACjC,QAAW,KAAQ,EAAO,CACxB,GAAI,CAAC,EAAa,GAAO,EAAa,GAAQ,CAAC,EAC/C,EAAe,EAAa,GAE9B,EAAe,KACV,QAAI,EAAK,WAAW,IAAI,GAAK,EAAK,SAAS,IAAI,EAAG,CAGvD,IAAM,EADY,EAAK,MAAM,EAAG,EAAE,EAAE,KAAK,EACjB,MAAM,GAAG,EAC7B,EAAS,EACb,QAAS,EAAI,EAAG,EAAI,EAAM,OAAS,EAAG,IAAK,CACzC,GAAI,CAAC,EAAO,EAAM,IAAK,EAAO,EAAM,IAAM,CAAC,EAC3C,EAAS,EAAO,EAAM,IAExB,IAAM,EAAW,EAAM,EAAM,OAAS,GACtC,GAAI,CAAC,EAAO,GAAW,EAAO,GAAY,CAAC,EAC3C,IAAM,EAAW,CAAC,EAClB,EAAO,GAAU,KAAK,CAAQ,EAC9B,EAAe,EACf,EAAe,KACV,KAEL,IAAO,KAAQ,GAAc,EAAK,MAAM,GAAG,EACvC,EAAQ,EAAW,KAAK,GAAG,EAAE,KAAK,EAEtC,GAAI,EAAM,WAAW,KAAK,GAAK,EAAM,WAAW,KAAK,GAInD,GAFA,EAA2B,EAAM,MAAM,EAAG,CAAC,EAC3C,EAAkB,EAAM,MAAM,CAAC,EAC3B,EAAM,SAAS,CAAwB,EACzC,EAAa,EAAI,KAAK,GAAK,EAAgB,MAAM,EAAG,EAAE,EACtD,EAAkB,KAClB,EAA2B,KAExB,QAAI,EAAM,WAAW,GAAG,GAAK,EAAM,SAAS,GAAG,EAEpD,EAAa,EAAI,KAAK,GAAK,EAAiB,CAAK,EAC5C,QAAI,EAAM,WAAW,GAAG,GAAK,CAAC,EAAM,SAAS,GAAG,EAErD,EAAe,CAAC,EAChB,EAAQ,EAAM,MAAM,CAAC,EAAE,KAAK,EAE5B,QAAI,IAAiB,KACnB,GAAI,EAAM,SAAS,GAAG,EACpB,EAAa,KAAK,EAAe,EAAM,MAAM,EAAG,EAAE,EAAE,KAAK,CAAC,CAAC,EAC3D,EAAa,EAAI,KAAK,GAAK,EAC3B,EAAe,KAEf,OAAa,KAAK,EAAe,CAAK,CAAC,EAGzC,OAAa,EAAI,KAAK,GAAK,EAAe,CAAK,GAMvD,OAAO,EAEX,GCnNF,IAAM,EAAa,CAAC,EAAO,IAAY,CACrC,GAAI,IAAU,QAAU,IAAU,IAChC,OAAO,KAET,GAAI,IAAU,OACZ,MAAO,GAET,GAAI,IAAU,QACZ,MAAO,GAET,GAAI,EAAM,WAAW,GAAG,GAAK,EAAM,SAAS,GAAG,EAC7C,OAAO,EAAM,MAAM,EAAG,EAAE,EAE1B,GAAI,EAAM,WAAW,GAAG,GAAK,EAAM,SAAS,GAAG,EAC7C,OAAO,EAAM,MAAM,EAAG,EAAE,EAE1B,GAAI,CAAC,MAAM,OAAO,CAAK,CAAC,EACtB,OAAO,OAAO,CAAK,EAErB,GAAI,EAAM,WAAW,GAAG,GAAK,EAAM,SAAS,GAAG,EAC7C,OAAO,EAAM,MAAM,EAAG,EAAE,EAAE,MAAM,GAAG,EAAE,IAAI,KAAQ,EAAW,EAAK,KAAK,EAAG,CAAO,CAAC,EAEnF,GAAI,EAAM,WAAW,GAAG,EAAG,CACzB,IAAM,EAAa,EAAM,MAAM,CAAC,EAAE,KAAK,EACvC,OAAO,EAAQ,GAEjB,GAAI,EAAM,SAAS,IAAI,EAAG,CACxB,IAAO,EAAK,GAAY,EAAM,MAAM,GAAG,EACvC,OAAQ,OACD,QACH,OAAO,SAAS,CAAQ,MACrB,UACH,OAAO,WAAW,CAAQ,MACvB,QACH,OAAO,MACJ,SACH,OAAO,EAAS,YAAY,IAAM,eAElC,OAAO,GAGb,OAAO,GASI,EAAa,CACxB,EAAU,CAAC,IACR,CACH,MAAO,CACL,MAAO,EAAQ,OAAS,CACtB,OACA,mBACA,WACF,EAUA,OAAQ,MACN,EACA,EACA,IACG,CACH,IAAM,GAAS,MAAM,EAAS,KAAK,GAAG,MAAM;AAAA,CAAI,EAC1C,EAAS,CAAC,EACZ,EAAgB,EAChB,EAAc,CAAC,CAAM,EACrB,EAAgB,EAChB,EAAe,KACf,EAAiB,CAAC,EAChB,EAAU,CAAC,EAEjB,QAAS,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACrC,IAAI,EAAO,EAAM,GAAG,QAAQ,EAC5B,GAAI,EAAK,KAAK,EAAE,WAAW,GAAG,EAC5B,SAGF,IAAM,EAAS,EAAK,OAAO,IAAI,EAE/B,GAAI,IAAiB,KACnB,GAAI,EAAS,EAAe,CAC1B,EAAe,KAAK,EAAK,KAAK,CAAC,EAC/B,SAEA,OAAc,GAAgB,EAAe,KAAK;AAAA,CAAI,EACtD,EAAe,KACf,EAAiB,CAAC,EAItB,GAAI,EAAS,EACX,EAAY,KAAK,CAAa,EAC9B,EAAgB,EAAc,OAAO,KAAK,CAAa,EAAE,IAAI,GACxD,QAAI,EAAS,EAClB,MAAO,EAAS,EACd,EAAY,IAAI,EAChB,EAAgB,EAAY,EAAY,OAAS,GACjD,GAAiB,EAAQ,YAAc,EAM3C,GAFA,EAAgB,EAEZ,EAAK,KAAK,IAAM,IAAK,CACvB,GAAI,CAAC,MAAM,QAAQ,CAAa,EAAG,CACjC,IAAM,EAAU,OAAO,KAAK,CAAa,EAAE,IAAI,EAC/C,EAAc,GAAW,CAAC,EAC1B,EAAgB,EAAc,GAEhC,EAAc,KAAK,CAAC,CAAC,EACrB,EAAgB,EAAc,EAAc,OAAS,GACrD,SAGF,IAAM,EAAa,EAAK,QAAQ,GAAG,EACnC,GAAI,IAAe,GACjB,SAGF,IAAM,EAAM,EAAK,MAAM,EAAG,CAAU,EAAE,KAAK,EACvC,EAAQ,EAAK,MAAM,EAAa,CAAC,EAAE,KAAK,EAE5C,GAAI,EAAM,WAAW,GAAG,EAAG,CACzB,IAAM,EAAa,EAAM,MAAM,CAAC,EAAE,MAAM,GAAG,EAAE,GAC7C,EAAQ,EAAM,MAAM,EAAW,OAAS,CAAC,EAAE,KAAK,EAChD,IAAM,EAAc,EAAW,EAAO,CAAO,EAC7C,EAAQ,GAAc,EACtB,EAAc,GAAO,EAChB,QAAI,EAAM,WAAW,GAAG,EAAG,CAChC,IAAM,EAAa,EAAM,MAAM,CAAC,EAAE,KAAK,EACvC,EAAc,GAAO,EAAQ,GACxB,QAAI,IAAU,KAAO,IAAU,IACpC,EAAe,EACf,GAAiB,EAAQ,YAAc,EAClC,QAAI,EACT,EAAc,GAAO,EAAW,EAAO,CAAO,EAE9C,OAAc,GAAO,CAAC,EAI1B,OAAO,EAEX",
  "debugId": "57BD01A361E1D94664756E2164756E21",
  "names": []
}