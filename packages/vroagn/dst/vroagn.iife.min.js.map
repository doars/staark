{
  "version": 3,
  "sources": ["../../../.scripts/iife.ts", "../src/utilities/clone.ts", "../src/utilities/delay.ts", "../src/utilities/type.ts", "../src/library/request.ts", "../src/library/cache.ts", "../src/library/parsers/csv.ts", "../src/library/parsers/ini.ts", "../src/library/parsers/toml.ts", "../src/library/parsers/yaml.ts", "../src/index.iife.ts"],
  "sourcesContent": ["export const iife = function (\n  path: Array<string>,\n  data: any\n) {\n  let subject: Record<string, any> = window\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof (subject[path[i]]) !== 'object' || !Array.isArray(subject[path[i]])) {\n      subject[path[i]] = {}\n    }\n    subject = subject[path[i]]\n  }\n  subject[path[path.length - 1]] = data\n}\n", "\nexport const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const delay = async (\n  time: number,\n): Promise<null> => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time)\n    )\n  }\n  return null\n}\n", "const normalizeContentType = (\n  contentType: string,\n): string => contentType.split(';')[0].trim().toLowerCase()\n\nconst getFileExtension = (\n  url: string,\n): string | null => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\nexport const getType = function (\n  url: string,\n  responseHeaders: Headers,\n  requestHeaders?: Record<string, string>,\n): string {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n", "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\nimport {\n  delay,\n} from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\nexport interface ResponseParser {\n  types: string[],\n  parser: (\n    response: Response,\n    options: RequestOptions,\n    type: string,\n  ) => any,\n}\n\nexport type FetchFunction = (\n  request: Request | string,\n  requestOptions?: RequestInit,\n) => Promise<Response>\n\nexport interface SendOptions {\n  body?: any\n  credentials?: RequestCredentials\n  domain?: string\n  headers?: Record<string, string>\n  method?: 'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'\n  mode?: RequestMode\n  path?: string\n  priority?: 'high' | 'normal' | 'low'\n  queryParams?: Record<string, string>\n  redirect?: RequestRedirect,\n  parsers?: ResponseParser[],\n  type?: string,\n\n  abort?: AbortController\n  cache?: RequestCache\n  fetch?: FetchFunction,\n\n  debounce?: number\n  delay?: number\n  throttle?: number\n  timeout?: number\n  retryAttempts?: number\n  retryCodes?: number[]\n  retryDelay?: number\n}\n\nexport interface RequestOptions extends SendOptions {\n  maxConcurrency?: number\n  maxRequests?: number\n}\n\nconst DEFAULT_VALUES: RequestOptions = {\n  method: 'get',\n  retryCodes: [429, 503, 504,],\n  retryDelay: 500,\n}\n\nexport const create = (\n  initialOptions: RequestOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0\n  let debounceTimeout: number | null = null\n\n  const throttle = async (\n    throttleValue: number,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (\n      waitTime > 0\n        ? waitTime\n        : 0\n    )\n    await delay(waitTime)\n  }\n\n  const debounce = (\n    debounceValue: number,\n  ): Promise<void> => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(\n        resolve,\n        debounceValue,\n      )\n    })\n  }\n\n  const sendRequest = async (\n    options: RequestOptions,\n  ): Promise<[Error | null, Response | null, any]> => {\n    if (\n      options.maxRequests !== undefined\n      && totalRequests >= options.maxRequests\n    ) {\n      return [new Error('Maximum request limit reached'), null, null]\n    }\n\n    totalRequests++\n\n    const config: RequestInit = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n\n      body: (\n        options.body\n          ? JSON.stringify(options.body)\n          : undefined\n      ),\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(\n        options.queryParams,\n      ).toString()\n    }\n\n    if (options.timeout) {\n      const controller = (\n        options.abort\n        || new AbortController()\n      )\n      config.signal = controller.signal\n      setTimeout(\n        () => controller.abort(),\n        options.timeout,\n      );\n    }\n\n    const executeFetch = async (\n    ): Promise<[Error | null, Response, any]> => {\n      // let response = null\n      // try {\n      //   response = await fetch(url, config)\n      // } catch (error) {\n      //   return [(error as Error) || new Error('Thrown fetching error is falsely'), response, null]\n      // }\n      const response = await (options.fetch ?? fetch)(url, config)\n      if (!response.ok) {\n        return [new Error('Invalid response'), response, null]\n      }\n\n      try {\n        let result\n        let foundParser = false\n        const type = options.type || getType(url, response.headers, options.headers)\n        if (options.parsers) {\n          for (const parser of options.parsers) {\n            foundParser = parser.types.includes(type)\n            if (foundParser) {\n              result = await parser.parser(\n                response,\n                options,\n                type,\n              )\n              break\n            }\n          }\n        }\n        if (!foundParser) {\n          switch (type.toLowerCase()) {\n            case 'arraybuffer':\n              result = await response.arrayBuffer()\n              break\n\n            case 'blob':\n              result = await response.blob()\n              break\n\n            case 'formdata':\n              result = await response.formData()\n              break\n\n            case 'text/plain':\n            case 'text':\n            case 'txt':\n              result = await response.text()\n              break\n\n            case 'text/html-partial':\n            case 'html-partial':\n              result = await response.text()\n              const template = document.createElement('template')\n              template.innerHTML = result\n              result = template.content.childNodes\n              break\n\n            case 'text/html':\n            case 'html':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'text/html')\n              break\n\n            case 'application/json':\n            case 'text/json':\n            case 'json':\n              result = await response.json()\n              break\n\n            case 'image/svg+xml':\n            case 'svg':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'image/svg+xml')\n              break\n\n            case 'application/xml':\n            case 'text/xml':\n            case 'xml':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'application/xml')\n              break\n          }\n        }\n\n        return [null, response, result]\n      } catch (error) {\n        return [(error as Error) || new Error('Thrown parsing error is falsy'), response, null]\n      }\n    }\n\n    const retryRequest = async (\n    ): Promise<[Error | null, Response, any]> => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        const [error, response, result] = await executeFetch()\n        if (!error) {\n          return [error, response, result]\n        }\n        if (!options.retryCodes?.includes(response.status || 200)) {\n          return [new Error('Invalid status code'), response, result]\n        }\n\n        attempt++\n        if (attempt >= retryAttempts) {\n          return [new Error('Too many retry attempts'), response, result]\n        }\n\n        // Exponentially increase the retry delay.\n        let delayTime = retryDelay * Math.pow(2, attempt - 1)\n\n        // Try and respect the Retry-After header.\n        const retryAfter = response.headers.get('Retry-After')\n        if (retryAfter) {\n          const retryAfterSeconds = parseInt(retryAfter, 10)\n          if (!isNaN(retryAfterSeconds)) {\n            delayTime = Math.max(delayTime, retryAfterSeconds * 1000)\n          } else {\n            const retryAfterDate = new Date(retryAfter).getTime()\n            if (!isNaN(retryAfterDate)) {\n              const currentTime = Date.now()\n              delayTime = Math.max(delayTime, retryAfterDate - currentTime)\n            }\n          }\n        }\n\n        await delay(delayTime)\n      }\n      return executeFetch()\n    }\n\n    const [error, response, result] = await retryRequest()\n    if (!response.ok) {\n      return [new Error(response.statusText), response, result]\n    }\n    return [error, response, result]\n  }\n\n  return async (\n    sendOptions: SendOptions,\n  ): Promise<[Error | null, Response | null, any]> => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise((resolve) => {\n        let interval: number | null = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency!) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    const results = await sendRequest(\n      options,\n    )\n    activeRequests--\n    return results\n  }\n}\n", "export type CacheOptions = {\n  name?: string,\n  // Fallback time-to-live in milliseconds for cache validity if headers don't provide it\n  ttl?: number,\n}\nconst FALLBACK_TTL = 60 * 60 * 1000 // One hour.\n\nconst openCaches: Record<string, Cache> = {}\n\nexport const cacheFetch = (\n  cacheOptions: CacheOptions = {},\n) => {\n  return async (\n    request: Request | string,\n    requestOptions: RequestInit = {},\n  ): Promise<Response> => {\n    // Bypass caching if no cache name is provided or if cache is explicitly disabled.\n    if (requestOptions.cache === 'no-store') {\n      return await fetch(request, requestOptions)\n    }\n\n    const cacheName = cacheOptions.name ?? 'vroagn-cache'\n    let cache: Cache | null = null\n    if (openCaches[cacheName]) {\n      cache = openCaches[cacheName]\n    } else {\n      cache = openCaches[cacheName] = await caches.open(cacheName)\n    }\n\n    const fetchFromNetworkAndCache = async (): Promise<Response> => {\n      const networkResponse = await fetch(request, requestOptions)\n      const cacheControl = networkResponse.headers.get('Cache-Control')\n      const noStore = cacheControl?.includes('no-store') || false\n\n      // Cache the response if it's successful and allowed.\n      if (\n        networkResponse.status === 200\n        && !noStore\n      ) {\n        const clonedResponse = networkResponse.clone()\n        const headers = new Headers(clonedResponse.headers)\n        headers.set('date', new Date().toUTCString())\n\n        const responseWithDate = new Response(clonedResponse.body, {\n          status: clonedResponse.status,\n          statusText: clonedResponse.statusText,\n          headers: headers,\n        })\n        await cache.put(request, responseWithDate)\n      }\n\n      return networkResponse\n    }\n\n    // Handle the cache option in requestOptions.\n    if (requestOptions.cache) {\n      switch (requestOptions.cache) {\n        case 'reload':\n          await cache.delete(request)\n          return await fetchFromNetworkAndCache()\n\n        case 'no-cache': {\n          const cachedResponse = await cache.match(request)\n          if (cachedResponse) {\n            const cacheControl = cachedResponse.headers.get('Cache-Control')\n            if (\n              cacheControl\n              && cacheControl.includes('no-cache')\n            ) {\n              await cache.delete(request)\n              return await fetchFromNetworkAndCache()\n            }\n          }\n          return await fetchFromNetworkAndCache()\n        }\n\n        case 'force-cache': {\n          const cachedResponse = await cache.match(request)\n          if (cachedResponse) {\n            return cachedResponse\n          }\n          return await fetchFromNetworkAndCache()\n        }\n\n        case 'only-if-cached': {\n          const cachedResponse = await cache.match(request)\n          if (!cachedResponse) {\n            throw new Error('Request failed because no cached response is available')\n          }\n          return cachedResponse\n        }\n\n        default:\n          // Continue for the 'default' cache option.\n          break\n      }\n    }\n\n    // Check if a valid cached response is available\n    const cachedResponse = await cache.match(request)\n    if (cachedResponse) {\n      const cacheControl = cachedResponse.headers.get('Cache-Control')\n      const expiresHeader = cachedResponse.headers.get('Expires')\n\n      if (\n        cacheControl\n        || expiresHeader\n      ) {\n        if (cacheControl) {\n          const noStore = cacheControl.includes('no-store')\n          const noCache = cacheControl.includes('no-cache')\n          const maxAgeMatch = cacheControl.match(/max-age=(\\d+)/)\n          const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1]) : null\n\n          if (\n            noStore\n            || noCache\n          ) {\n            await cache.delete(request)\n            return fetchFromNetworkAndCache()\n          }\n\n          if (maxAge !== null) {\n            const cachedTime = new Date(\n              cachedResponse.headers.get('date') || 0,\n            ).getTime()\n            const now = Date.now()\n            const age = (now - cachedTime) / 1000\n\n            if (age > maxAge) {\n              await cache.delete(request)\n              return fetchFromNetworkAndCache()\n            }\n          }\n        }\n\n        if (expiresHeader) {\n          const expires = new Date(expiresHeader).getTime()\n          if (Date.now() > expires) {\n            await cache.delete(request)\n            return fetchFromNetworkAndCache()\n          }\n        }\n      } else {\n        const dateHeader = cachedResponse.headers.get('date')\n        if (dateHeader) {\n          const cachedTime = new Date(dateHeader).getTime()\n          const now = Date.now()\n          const age = now - cachedTime\n          if (age > (cacheOptions.ttl ?? FALLBACK_TTL)) {\n            await cache.delete(request)\n            return fetchFromNetworkAndCache()\n          }\n        }\n      }\n\n      return cachedResponse\n    }\n\n    return fetchFromNetworkAndCache()\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser\n} from '../request.js'\n\ninterface CsvOptions {\n  types?: string[],\n  hasHeaders?: boolean,\n\n  columnDelimiter?: string,\n  rowDelimiter?: string,\n  escapeCharacter?: string,\n}\n\nconst tsvTypes = [\n  'tsv', 'text/tab-separated-values',\n]\n\nexport const csvParser = (\n  options: CsvOptions,\n): ResponseParser => {\n  return {\n    types: options?.types || [\n      'csv', 'text/csv',\n      ...tsvTypes,\n    ],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n      type: string,\n    ): Promise<any> => {\n      const optionsTemp = {\n        columnDelimiter: (\n          tsvTypes.includes(type)\n            ? '\t'\n            : ','\n        ),\n        rowDelimiter: '\\n',\n        escapeCharacter: '\"',\n\n        ...options,\n      }\n\n      const string = await response.text()\n\n      const rows: string[][] = []\n      let currentRow: string[] = []\n      let currentField = ''\n      let insideQuotes = false\n\n      for (let i = 0; i < string.length; i++) {\n        const character = string[i]\n        const nextCharacter = string[i + 1]\n\n        if (character === optionsTemp.escapeCharacter) {\n          if (\n            nextCharacter === optionsTemp.escapeCharacter\n            && insideQuotes\n          ) {\n            // Double quotes inside quotes.\n            currentField += optionsTemp.escapeCharacter\n            i++ // Skip next quote.\n          } else {\n            // Toggle insideQuotes.\n            insideQuotes = !insideQuotes\n          }\n        } else if (\n          character === optionsTemp.columnDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n        } else if (\n          character === optionsTemp.rowDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n\n          rows.push(currentRow)\n          currentRow = []\n        } else {\n          currentField += character\n        }\n      }\n\n      // Push the last field and row if there's any.\n      if (currentField) {\n        currentRow.push(\n          currentField,\n        )\n        currentField = ''\n      }\n      if (currentRow.length > 0) {\n        rows.push(currentRow)\n      }\n\n      if (optionsTemp.hasHeaders) {\n        // Extract headers and create objects.\n        const headers = rows[0]\n        return rows.slice(1).map(row => {\n          return headers.reduce((\n            object: Record<string, string>,\n            header: string,\n            index: number,\n          ) => {\n            object[header] = row[index] || ''\n            return object\n          }, {})\n        })\n      }\n\n      return rows\n    }\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser,\n} from '../request.js'\n\ninterface IniOptions {\n  types?: string[],\n}\n\ninterface IniObject {\n  [section: string]: {\n    [key: string]: string\n  }\n}\n\nexport const iniParser = (\n  options: IniOptions = {},\n): ResponseParser => {\n  return {\n    types: options.types || ['ini',],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n    ): Promise<IniObject> => {\n      const text = await response.text()\n\n      const result: IniObject = {}\n      const lines = text\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n\n      let currentSection = ''\n      for (const line of lines) {\n        if (\n          line === ''\n          || line.startsWith(';')\n          || line.startsWith('#')\n        ) {\n          // Skip empty lines and comments.\n          continue\n        }\n\n        if (\n          line.startsWith('[')\n          && line.endsWith(']')\n        ) {\n          // New section.\n          currentSection = line.slice(1, -1).trim()\n          if (!result[currentSection]) {\n            result[currentSection] = {}\n          }\n        } else {\n          // Key-value pair.\n          const [key, ...valueParts] = line.split('=')\n          const value = valueParts.join('=').trim()\n\n          if (currentSection === '') {\n            // Global section (outside any named section).\n            if (!result['global']) {\n              result['global'] = {}\n            }\n            result['global'][key.trim()] = value\n          } else {\n            result[currentSection][key.trim()] = value\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser,\n} from '../request.js'\n\ninterface TomlOptions {\n  types?: string[],\n}\n\ntype TomlValue = string | number | boolean | Date | TomlObject | TomlValue[]\ninterface TomlObject {\n  [key: string]: TomlValue\n}\n\nconst parseTomlValue = (\n  value: string,\n): TomlValue => {\n  if (\n    value.startsWith('\"')\n    && value.endsWith('\"')\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value.startsWith(\"'\")\n    && value.endsWith(\"'\")\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value === 'true'\n    || value === 'false'\n  ) {\n    return value === 'true'\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (value.match(/^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(.\\d+)?(Z|[+-]\\d{2}:\\d{2})?)?$/)) {\n    return new Date(value)\n  }\n  return value\n}\n\nconst parseInlineTable = (\n  tableString: string,\n): TomlObject => {\n  const result: TomlObject = {}\n  let key = ''\n  let value = ''\n  let inQuotes = false\n  let quoteChar = ''\n  let inValue = false\n\n  for (let i = 1; i < tableString.length - 1; i++) {\n    const character = tableString[i]\n    if (\n      !inQuotes\n      && (\n        character === '\"'\n        || character === \"'\"\n      )\n    ) {\n      inQuotes = true\n      quoteChar = character\n    } else if (\n      inQuotes\n      && character === quoteChar\n    ) {\n      inQuotes = false\n    } else if (\n      !inQuotes\n      && character === '='\n    ) {\n      inValue = true\n    } else if (\n      !inQuotes\n      && character === ','\n    ) {\n      result[key.trim()] = parseTomlValue(value.trim())\n      key = ''\n      value = ''\n      inValue = false\n    } else {\n      if (inValue) {\n        value += character\n      } else {\n        key += character\n      }\n    }\n  }\n\n  if (key) {\n    result[key.trim()] = parseTomlValue(value.trim())\n  }\n\n  return result\n}\n\nexport const tomlParser = (\n  options: TomlOptions = {},\n): ResponseParser => {\n  return {\n    types: options.types || ['toml', 'application/toml'],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n    ): Promise<TomlObject> => {\n      const text = await response.text()\n\n      const result: TomlObject = {}\n      let currentTable: TomlObject = result\n      let currentArray: TomlValue[] | null = null\n      let multilineString: string | null = null\n      let multilineStringDelimiter: string | null = null\n\n      const lines = text.split(/\\r?\\n/)\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trim()\n\n        if (line === '' || line.startsWith('#')) {\n          continue // Skip empty lines and comments\n        }\n\n        if (multilineString !== null) {\n          if (line.endsWith(multilineStringDelimiter!)) {\n            multilineString += line.slice(0, -multilineStringDelimiter!.length)\n            currentTable[Object.keys(currentTable).pop()!] = multilineString\n            multilineString = null\n            multilineStringDelimiter = null\n          } else {\n            multilineString += line + '\\n'\n          }\n          continue\n        }\n\n        if (line.startsWith('[') && line.endsWith(']')) {\n          // Table\n          const tableName = line.slice(1, -1).trim()\n          currentTable = result\n          const parts = tableName.split('.')\n          for (const part of parts) {\n            if (!currentTable[part]) currentTable[part] = {}\n            currentTable = currentTable[part] as TomlObject\n          }\n          currentArray = null\n        } else if (line.startsWith('[[') && line.endsWith(']]')) {\n          // Array of Tables\n          const arrayName = line.slice(2, -2).trim()\n          const parts = arrayName.split('.')\n          let parent = result\n          for (let i = 0; i < parts.length - 1; i++) {\n            if (!parent[parts[i]]) parent[parts[i]] = {}\n            parent = parent[parts[i]] as TomlObject\n          }\n          const lastPart = parts[parts.length - 1]\n          if (!parent[lastPart]) parent[lastPart] = []\n          const newTable = {};\n          (parent[lastPart] as TomlValue[]).push(newTable)\n          currentTable = newTable as TomlObject\n          currentArray = null\n        } else {\n          // Key-value pair\n          const [key, ...valueParts] = line.split('=')\n          let value = valueParts.join('=').trim()\n\n          if (value.startsWith('\"\"\"') || value.startsWith(\"'''\")) {\n            // Multi-line string\n            multilineStringDelimiter = value.slice(0, 3)\n            multilineString = value.slice(3)\n            if (value.endsWith(multilineStringDelimiter)) {\n              currentTable[key.trim()] = multilineString.slice(0, -3)\n              multilineString = null\n              multilineStringDelimiter = null\n            }\n          } else if (value.startsWith('{') && value.endsWith('}')) {\n            // Inline table\n            currentTable[key.trim()] = parseInlineTable(value)\n          } else if (value.startsWith('[') && !value.endsWith(']')) {\n            // Multi-line array\n            currentArray = []\n            value = value.slice(1).trim()\n          } else {\n            if (currentArray !== null) {\n              if (value.endsWith(']')) {\n                currentArray.push(parseTomlValue(value.slice(0, -1).trim()))\n                currentTable[key.trim()] = currentArray\n                currentArray = null\n              } else {\n                currentArray.push(parseTomlValue(value))\n              }\n            } else {\n              currentTable[key.trim()] = parseTomlValue(value)\n            }\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser,\n} from '../request.js'\n\ninterface YamlOptions {\n  types?: string[],\n  indentSize?: number,\n}\n\ntype YamlValue = string | number | boolean | null | YamlObject | YamlValue[]\ninterface YamlObject {\n  [key: string]: YamlValue,\n}\n\nconst parseValue = (\n  value: string,\n  anchors: Record<string, YamlValue>,\n): YamlValue => {\n  if (value === 'null' || value === '~') {\n    return null\n  }\n  if (value === 'true') {\n    return true\n  }\n  if (value === 'false') {\n    return false\n  }\n  if (\n    value.startsWith('\"')\n    && value.endsWith('\"')\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value.startsWith(\"'\")\n    && value.endsWith(\"'\")\n  ) {\n    return value.slice(1, -1)\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (\n    value.startsWith('[')\n    && value.endsWith(']')\n  ) {\n    return value\n      .slice(1, -1)\n      .split(',')\n      .map(\n        item => parseValue(item.trim(), anchors)\n      )\n  }\n  if (value.startsWith('*')) {\n    const anchorName = value.slice(1).trim()\n    return anchors[anchorName]\n  }\n  if (value.includes('!!')) {\n    const [tag, tagValue] = value.split(' ')\n    switch (tag) {\n      case '!!int':\n        return parseInt(tagValue)\n      case '!!float':\n        return parseFloat(tagValue)\n      case '!!str':\n        return tagValue\n      case '!!bool':\n        return tagValue.toLowerCase() === 'true'\n      default:\n        return tagValue\n    }\n  }\n  return value\n}\n\nexport const yamlParser = (\n  options: YamlOptions = {},\n): ResponseParser => {\n  return {\n    types: options.types || ['yaml', 'application/yaml', 'text/yaml'],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n    ): Promise<any> => {\n      const lines = (await response.text())\n        .split('\\n')\n      const result: YamlObject = {}\n      let currentObject: YamlValue = result\n      let indentStack: YamlObject[] = [result]\n      let currentIndent = 0\n      let multilineKey: string | null = null\n      let multilineValue: string[] = []\n      const anchors: Record<string, YamlValue> = {}\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trimEnd()\n        if (line.trim().startsWith('#')) {\n          continue\n        }\n\n        const indent = line.search(/\\S/)\n\n        if (multilineKey !== null) {\n          if (indent > currentIndent) {\n            multilineValue.push(line.trim())\n            continue\n          } else {\n            currentObject[multilineKey] = multilineValue.join('\\n')\n            multilineKey = null\n            multilineValue = []\n          }\n        }\n\n        if (indent > currentIndent) {\n          indentStack.push(currentObject)\n          currentObject = currentObject[\n            Object.keys(currentObject).pop()!\n          ] as YamlObject\n        } else if (indent < currentIndent) {\n          while (indent < currentIndent) {\n            indentStack.pop()\n            currentObject = indentStack[indentStack.length - 1]\n            currentIndent -= options.indentSize || 2\n          }\n        }\n\n        currentIndent = indent\n\n        if (line.trim() === '-') {\n          if (!Array.isArray(currentObject)) {\n            const lastKey = Object.keys(currentObject).pop()!\n            currentObject[lastKey] = []\n            currentObject = currentObject[lastKey] as YamlValue[]\n          }\n          currentObject.push({})\n          currentObject = currentObject[currentObject.length - 1] as YamlObject\n          continue\n        }\n\n        const colonIndex = line.indexOf(':')\n        if (colonIndex === -1) {\n          continue\n        }\n\n        const key = line.slice(0, colonIndex).trim()\n        let value = line.slice(colonIndex + 1).trim()\n\n        if (value.startsWith('&')) {\n          const anchorName = value.slice(1).split(' ')[0]\n          value = value.slice(anchorName.length + 2).trim()\n          const parsedValue = parseValue(value, anchors)\n          anchors[anchorName] = parsedValue\n          currentObject[key] = parsedValue\n        } else if (value.startsWith('*')) {\n          const anchorName = value.slice(1).trim()\n          currentObject[key] = anchors[anchorName]\n        } else if (\n          value === '|'\n          || value === '>'\n        ) {\n          multilineKey = key\n          currentIndent += options.indentSize || 2\n        } else if (value) {\n          currentObject[key] = parseValue(value, anchors)\n        } else {\n          currentObject[key] = {}\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n", "import { iife } from '../../../.scripts/iife.js'\n\nimport { create } from './library/request.js'\n\nimport { cacheFetch } from './library/cache.js'\n\nimport { csvParser } from './library/parsers/csv.js'\nimport { iniParser } from './library/parsers/ini.js'\nimport { tomlParser } from './library/parsers/toml.js'\nimport { yamlParser } from './library/parsers/yaml.js'\n\niife([\n  'vroagn',\n], {\n  create,\n\n  cacheFetch,\n\n  csvParser,\n  iniParser,\n  tomlParser,\n  yamlParser,\n})\n"],
  "mappings": "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",
  "names": ["iife", "path", "data", "subject", "i", "cloneRecursive", "value", "clone", "i", "key", "delay", "time", "__async", "resolve", "normalizeContentType", "contentType", "getFileExtension", "url", "match", "getType", "responseHeaders", "requestHeaders", "acceptTypes", "type", "extension", "DEFAULT_VALUES", "create", "initialOptions", "__spreadValues", "cloneRecursive", "lastExecutionTime", "activeRequests", "totalRequests", "debounceTimeout", "throttle", "throttleValue", "__async", "now", "waitTime", "delay", "debounce", "debounceValue", "resolve", "sendRequest", "options", "config", "url", "controller", "executeFetch", "_a", "response", "result", "foundParser", "type", "getType", "parser", "template", "error", "retryRequest", "attempt", "retryAttempts", "retryDelay", "delayTime", "retryAfter", "retryAfterSeconds", "retryAfterDate", "currentTime", "sendOptions", "interval", "wait", "results", "openCaches", "cacheFetch", "cacheOptions", "_0", "_1", "__async", "request", "requestOptions", "_a", "_b", "cacheName", "cache", "fetchFromNetworkAndCache", "networkResponse", "cacheControl", "noStore", "clonedResponse", "headers", "responseWithDate", "cachedResponse", "expiresHeader", "noCache", "maxAgeMatch", "maxAge", "cachedTime", "expires", "dateHeader", "tsvTypes", "csvParser", "options", "response", "requestOptions", "type", "__async", "optionsTemp", "__spreadValues", "string", "rows", "currentRow", "currentField", "insideQuotes", "i", "character", "nextCharacter", "headers", "row", "object", "header", "index", "iniParser", "options", "response", "requestOptions", "__async", "text", "result", "lines", "line", "currentSection", "key", "valueParts", "value", "parseTomlValue", "value", "parseInlineTable", "tableString", "result", "key", "inQuotes", "quoteChar", "inValue", "i", "character", "tomlParser", "options", "response", "requestOptions", "__async", "text", "currentTable", "currentArray", "multilineString", "multilineStringDelimiter", "lines", "line", "tableName", "parts", "part", "parent", "lastPart", "newTable", "valueParts", "parseValue", "value", "anchors", "item", "anchorName", "tag", "tagValue", "yamlParser", "options", "response", "requestOptions", "__async", "lines", "result", "currentObject", "indentStack", "currentIndent", "multilineKey", "multilineValue", "i", "line", "indent", "lastKey", "colonIndex", "key", "parsedValue", "iife", "create", "cacheFetch", "csvParser", "iniParser", "tomlParser", "yamlParser"]
}
