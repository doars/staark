{
  "version": 3,
  "sources": ["../../../helpers/iife.js", "../src/utilities/clone.js", "../src/utilities/delay.js", "../src/utilities/type.js", "../src/library/request.js", "../src/index.base.iife.js"],
  "sourcesContent": [
    "/**\n * Assigns data to window at the given path. If an object at the path already exists it will merge them instead of replacing it.\n * @param {Array<string>} path Path to assign the values to.\n * @param {any} data Data to assign to the window.\n */\nexport const iife = (\n  path,\n  data,\n) => {\n  let subject = window\n  for (let i = 0; i < path.length - 1; i++) {\n    if (\n      typeof (subject[path[i]]) !== 'object'\n      || !Array.isArray(subject[path[i]])\n    ) {\n      subject[path[i]] = {}\n    }\n    subject = subject[path[i]]\n  }\n  subject[path[path.length - 1]] = data\n}\n",
    "/**\n * Creates a deep clone of a javascript value.\n *\n * @param {any} value Data to clone.\n * @returns {any} Clone of the data.\n */\nexport const cloneRecursive = (\n  value,\n) => {\n  if (typeof (value) === 'object') {\n    const clone = (\n      Array.isArray(value)\n        ? []\n        : {}\n    )\n    for (const key in value) {\n      clone[key] = cloneRecursive(value[key])\n    }\n    return clone\n  }\n  return value\n}\n",
    "/**\n * Delays the execution for a specified amount of time.\n *\n * @param {number} time The amount of time to delay in milliseconds.\n * @returns {Promise<null>} A promise that resolves after the delay.\n */\nexport const delay = async (\n  time,\n) => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time),\n    )\n  }\n  return null\n}\n",
    "/**\n * Normalize the content type by removing any parameters and converting to lowercase.\n *\n * @param {string} contentType The content type to normalize.\n * @returns {string} The normalized content type.\n */\nconst normalizeContentType = (\n  contentType,\n) => contentType.split(';')[0].trim().toLowerCase()\n\n/**\n * Extract the file extension from a URL.\n *\n * @param {string} url The URL to extract the file extension from.\n * @returns {string|null} The file extension or null if not found.\n */\nconst getFileExtension = (\n  url,\n) => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\n/**\n * Get the type of the resource based on the URL, response headers, and request headers.\n *\n * @param {string} url The URL of the resource.\n * @param {Headers} responseHeaders The response headers.\n * @param {Record<string, string>} [requestHeaders] The request headers.\n * @returns {string} The type of the resource.\n */\nexport const getType = (\n  url,\n  responseHeaders,\n  requestHeaders,\n) => {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n",
    "import { cloneRecursive } from '../utilities/clone.js'\nimport { delay } from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\n/**\n * @typedef {Object} ResponseParser Defines a response parser.\n * @property {string[]} types The types of responses the parser can handle.\n * @property {(response: Response, options: RequestOptions, type: string) => any} parser The function to parse the response.\n **/\n\n/**\n * @typedef {Object} SendOptions Defines the options for sending a request.\n * @property {any} [body] The body of the request.\n * @property {RequestCredentials} [credentials] The credentials for the request.\n * @property {string} [domain] The domain for the request.\n * @property {Record<string, string>} [headers] The headers for the request.\n * @property {'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'} [method] The HTTP method for the request.\n * @property {RequestMode} [mode] The mode for the request.\n * @property {string} [path] The path for the request.\n * @property {'high' | 'normal' | 'low'} [priority] The priority of the request.\n * @property {Record<string, string>} [queryParams] The query parameters for the request.\n * @property {RequestRedirect} [redirect] The redirect mode for the request.\n * @property {ResponseParser[]} [parsers] The parsers for the response.\n * @property {string} [type] The expected response type.\n * @property {AbortController} [abort] The abort controller for the request.\n * @property {RequestCache} [cache] The cache mode for the request.\n * @property {(request: Request | string, requestOptions?: RequestInit) => Promise<Response>} [fetch] The fetch function to use for the request.\n * @property {number} [debounce] The debounce time for the request.\n * @property {number} [delay] The delay time for the request.\n * @property {number} [throttle] The throttle time for the request.\n * @property {number} [timeout] The timeout for the request.\n * @property {number} [retryAttempts] The number of retry attempts for the request.\n * @property {number[]} [retryCodes] The HTTP status codes that should trigger a retry.\n * @property {number} [retryDelay] The delay between retry attempts.\n **/\n\n/**\n * @typedef {SendOptions & { maxConcurrency?: number, maxRequests?: number }} RequestOptions Defines the options for creating a request handler.\n */\n\n// Default values for the request handler.\nconst DEFAULT_VALUES = {\n  method: 'get',\n  retryCodes: [429, 503, 504],\n  retryDelay: 500,\n}\n\n/**\n * Creates a request handler.\n *\n * @param {RequestOptions} initialOptions The initial options for the request handler.\n * @returns {(sendOptions: SendOptions) => Promise<[Error | null, Response | null, any]>} The request handler.\n */\nexport const create = (\n  initialOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0\n  let debounceTimeout = null\n\n  /**\n   * @param {number} throttleValue\n   */\n  const throttle = async (\n    throttleValue,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (waitTime > 0 ? waitTime : 0)\n    await delay(waitTime)\n  }\n\n  /**\n   * Debounces the request handler.\n   *\n   * @param {number} debounceValue The debounce time in milliseconds.\n   * @returns {Promise<void>} A promise that resolves after the debounce time.\n   */\n  const debounce = (\n    debounceValue,\n  ) => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(resolve, debounceValue)\n    })\n  }\n\n  /**\n   * Sends a request.\n   *\n   * @param {RequestOptions} options The options for the request.\n   * @returns {Promise<[Error | null, Response | null, any]>} The error, response and result of the request.\n   */\n  const sendRequest = async (\n    options,\n  ) => {\n    if (\n      options.maxRequests !== undefined\n      && totalRequests >= options.maxRequests\n    ) {\n      return [new Error('Maximum request limit reached'), null, null]\n    }\n\n    totalRequests++\n\n    const config = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n      body: options.body ? JSON.stringify(options.body) : undefined,\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(options.queryParams).toString()\n    }\n\n    if (options.timeout) {\n      const controller = options.abort || new AbortController()\n      config.signal = controller.signal\n      setTimeout(() => controller.abort(), options.timeout)\n    }\n\n    /**\n     * @returns {Promise<[Error | null, Response, any]>}\n     */\n    const executeFetch = async () => {\n      const response = await (options.fetch ?? fetch)(url, config)\n      if (!response.ok) {\n        return [new Error('Invalid response'), response, null]\n      }\n\n      try {\n        let result\n        let foundParser = false\n        const type = options.type || getType(url, response.headers, options.headers)\n        if (options.parsers) {\n          for (const parser of options.parsers) {\n            foundParser = parser.types.includes(type)\n            if (foundParser) {\n              result = await parser.parser(response, options, type)\n              break\n            }\n          }\n        }\n        if (!foundParser) {\n          switch (type.toLowerCase()) {\n            case 'arraybuffer':\n              result = await response.arrayBuffer()\n              break\n            case 'blob':\n              result = await response.blob()\n              break\n            case 'formdata':\n              result = await response.formData()\n              break\n            case 'text/plain':\n            case 'text':\n            case 'txt':\n              result = await response.text()\n              break\n            case 'text/html-partial':\n            case 'html-partial':\n              result = await response.text()\n              const template = document.createElement('template')\n              template.innerHTML = result\n              result = template.content.childNodes\n              break\n            case 'text/html':\n            case 'html':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'text/html')\n              break\n            case 'application/json':\n            case 'text/json':\n            case 'json':\n              result = await response.json()\n              break\n            case 'image/svg+xml':\n            case 'svg':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'image/svg+xml')\n              break\n            case 'application/xml':\n            case 'text/xml':\n            case 'xml':\n              result = await response.text()\n              result = new DOMParser().parseFromString(result, 'application/xml')\n              break\n          }\n        }\n\n        return [null, response, result]\n      } catch (error) {\n        return [error || new Error('Thrown parsing error is falsy'), response, null]\n      }\n    }\n\n    /**\n     * Retries the request.\n     *\n     * @returns {Promise<[Error | null, Response, any]>} The error, response and result of the request.\n     */\n    const retryRequest = async () => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        const [error, response, result] = await executeFetch()\n        if (!error) {\n          return [error, response, result]\n        }\n        if (!options.retryCodes?.includes(response.status || 200)) {\n          return [new Error('Invalid status code'), response, result]\n        }\n\n        attempt++\n        if (attempt >= retryAttempts) {\n          return [new Error('Too many retry attempts'), response, result]\n        }\n\n        let delayTime = retryDelay * Math.pow(2, attempt - 1)\n\n        const retryAfter = response.headers.get('Retry-After')\n        if (retryAfter) {\n          const retryAfterSeconds = parseInt(retryAfter, 10)\n          if (!isNaN(retryAfterSeconds)) {\n            delayTime = Math.max(delayTime, retryAfterSeconds * 1000)\n          } else {\n            const retryAfterDate = new Date(retryAfter).getTime()\n            if (!isNaN(retryAfterDate)) {\n              const currentTime = Date.now()\n              delayTime = Math.max(delayTime, retryAfterDate - currentTime)\n            }\n          }\n        }\n\n        await delay(delayTime)\n      }\n      return executeFetch()\n    }\n\n    const [error, response, result] = await retryRequest()\n    if (!response.ok) {\n      return [new Error(response.statusText), response, result]\n    }\n    return [error, response, result]\n  }\n\n  /**\n   * Sends a request.\n   *\n   * @param {SendOptions} sendOptions The options for sending the request.\n   * @returns {Promise<[Error | null, Response | null, any]>} The error, response and result of the request.\n   */\n  return async (\n    sendOptions,\n  ) => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise(resolve => {\n        let interval = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    const results = await sendRequest(options)\n    activeRequests--\n    return results\n  }\n}\n",
    "import { iife } from '../../../helpers/iife.js'\n\nimport { create } from './library/request.js'\n\niife([\n  'vroagn',\n], {\n  create,\n})\n"
  ],
  "mappings": ";;EAKO,IAAM,OAAO,CAClB,MACA,SACG;AAAA,IACH,IAAI,UAAU;AAAA,IACd,SAAS,IAAI,EAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AAAA,MACxC,IACE,OAAQ,QAAQ,KAAK,QAAS,YAC3B,CAAC,MAAM,QAAQ,QAAQ,KAAK,GAAG,GAClC;AAAA,QACA,QAAQ,KAAK,MAAM,CAAC;AAAA,MACtB;AAAA,MACA,UAAU,QAAQ,KAAK;AAAA,IACzB;AAAA,IACA,QAAQ,KAAK,KAAK,SAAS,MAAM;AAAA;;;ECb5B,IAAM,iBAAiB,CAC5B,UACG;AAAA,IACH,IAAI,OAAQ,UAAW,UAAU;AAAA,MAC/B,MAAM,QACJ,MAAM,QAAQ,KAAK,IACf,CAAC,IACD,CAAC;AAAA,MAEP,WAAW,OAAO,OAAO;AAAA,QACvB,MAAM,OAAO,eAAe,MAAM,IAAI;AAAA,MACxC;AAAA,MACA,OAAO;AAAA,IACT;AAAA,IACA,OAAO;AAAA;;;ECdF,IAAM,QAAQ,OACnB,SACG;AAAA,IACH,IAAI,OAAO,GAAG;AAAA,MACZ,OAAO,IAAI,QACT,CAAC,YAAY,WAAW,SAAS,IAAI,CACvC;AAAA,IACF;AAAA,IACA,OAAO;AAAA;;;ECRT,IAAM,uBAAuB,CAC3B,gBACG,YAAY,MAAM,GAAG,EAAE,GAAG,KAAK,EAAE,YAAY;AAAA,EAQlD,IAAM,mBAAmB,CACvB,QACG;AAAA,IACH,MAAM,QAAQ,IAAI,MAAM,uBAAuB;AAAA,IAC/C,OAAO,QAAQ,MAAM,GAAG,YAAY,IAAI;AAAA;AAAA,EAWnC,IAAM,UAAU,CACrB,KACA,iBACA,mBACG;AAAA,IAEH,MAAM,cAAc,gBAAgB,IAAI,cAAc;AAAA,IACtD,IAAI,aAAa;AAAA,MACf,OAAO,qBAAqB,WAAW;AAAA,IACzC;AAAA,IAGA,IAAI,gBAAgB;AAAA,MAClB,IAAI,eAAe,WAAW;AAAA,QAC5B,MAAM,cAAc,eAAe,UAAU,MAAM,GAAG;AAAA,QACtD,WAAW,QAAQ,aAAa;AAAA,UAC9B,IAAI,KAAK,KAAK,MAAM,OAAO;AAAA,YACzB,OAAO,qBAAqB,IAAI;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IAGA,MAAM,YAAY,iBAAiB,GAAG;AAAA,IACtC,IAAI,WAAW;AAAA,MACb,OAAO;AAAA,IACT;AAAA,IAEA,OAAO;AAAA;;;ECnBT,IAAM,iBAAiB;AAAA,IACrB,QAAQ;AAAA,IACR,YAAY,CAAC,KAAK,KAAK,GAAG;AAAA,IAC1B,YAAY;AAAA,EACd;AAAA,EAQO,IAAM,SAAS,CACpB,mBACG;AAAA,IACH,iBAAiB;AAAA,SACZ;AAAA,SACA,eAAe,cAAc;AAAA,IAClC;AAAA,IAEA,IAAI,oBAAoB;AAAA,IACxB,IAAI,iBAAiB;AAAA,IACrB,IAAI,gBAAgB;AAAA,IACpB,IAAI,kBAAkB;AAAA,IAKtB,MAAM,WAAW,OACf,kBACG;AAAA,MACH,MAAM,MAAM,KAAK,IAAI;AAAA,MACrB,MAAM,WAAW,iBAAiB,MAAM;AAAA,MACxC,oBAAoB,OAAO,WAAW,IAAI,WAAW;AAAA,MACrD,MAAM,MAAM,QAAQ;AAAA;AAAA,IAStB,MAAM,WAAW,CACf,kBACG;AAAA,MACH,OAAO,IAAI,QAAQ,CAAC,YAAY;AAAA,QAC9B,IAAI,iBAAiB;AAAA,UACnB,aAAa,eAAe;AAAA,QAC9B;AAAA,QACA,kBAAkB,WAAW,SAAS,aAAa;AAAA,OACpD;AAAA;AAAA,IASH,MAAM,cAAc,OAClB,YACG;AAAA,MACH,IACE,QAAQ,gBAAgB,aACrB,iBAAiB,QAAQ,aAC5B;AAAA,QACA,OAAO,CAAC,IAAI,MAAM,+BAA+B,GAAG,MAAM,IAAI;AAAA,MAChE;AAAA,MAEA;AAAA,MAEA,MAAM,SAAS;AAAA,QACb,OAAO,QAAQ;AAAA,QACf,aAAa,QAAQ;AAAA,QACrB,SAAS,QAAQ;AAAA,QACjB,QAAQ,QAAQ;AAAA,QAChB,MAAM,QAAQ;AAAA,QACd,UAAU,QAAQ;AAAA,QAClB,MAAM,QAAQ,OAAO,KAAK,UAAU,QAAQ,IAAI,IAAI;AAAA,MACtD;AAAA,MAEA,IAAI,OAAO,QAAQ,UAAU,OAAO,QAAQ,QAAQ;AAAA,MACpD,IAAI,QAAQ,aAAa;AAAA,QACvB,OAAO,MAAM,IAAI,gBAAgB,QAAQ,WAAW,EAAE,SAAS;AAAA,MACjE;AAAA,MAEA,IAAI,QAAQ,SAAS;AAAA,QACnB,MAAM,aAAa,QAAQ,SAAS,IAAI;AAAA,QACxC,OAAO,SAAS,WAAW;AAAA,QAC3B,WAAW,MAAM,WAAW,MAAM,GAAG,QAAQ,OAAO;AAAA,MACtD;AAAA,MAKA,MAAM,eAAe,YAAY;AAAA,QAC/B,MAAM,YAAW,OAAO,QAAQ,SAAS,OAAO,KAAK,MAAM;AAAA,QAC3D,IAAI,CAAC,UAAS,IAAI;AAAA,UAChB,OAAO,CAAC,IAAI,MAAM,kBAAkB,GAAG,WAAU,IAAI;AAAA,QACvD;AAAA,QAEA,IAAI;AAAA,UACF,IAAI;AAAA,UACJ,IAAI,cAAc;AAAA,UAClB,MAAM,OAAO,QAAQ,QAAQ,QAAQ,KAAK,UAAS,SAAS,QAAQ,OAAO;AAAA,UAC3E,IAAI,QAAQ,SAAS;AAAA,YACnB,WAAW,UAAU,QAAQ,SAAS;AAAA,cACpC,cAAc,OAAO,MAAM,SAAS,IAAI;AAAA,cACxC,IAAI,aAAa;AAAA,gBACf,UAAS,MAAM,OAAO,OAAO,WAAU,SAAS,IAAI;AAAA,gBACpD;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,UACA,IAAI,CAAC,aAAa;AAAA,YAChB,QAAQ,KAAK,YAAY;AAAA,mBAClB;AAAA,gBACH,UAAS,MAAM,UAAS,YAAY;AAAA,gBACpC;AAAA,mBACG;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B;AAAA,mBACG;AAAA,gBACH,UAAS,MAAM,UAAS,SAAS;AAAA,gBACjC;AAAA,mBACG;AAAA,mBACA;AAAA,mBACA;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B;AAAA,mBACG;AAAA,mBACA;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B,MAAM,WAAW,SAAS,cAAc,UAAU;AAAA,gBAClD,SAAS,YAAY;AAAA,gBACrB,UAAS,SAAS,QAAQ;AAAA,gBAC1B;AAAA,mBACG;AAAA,mBACA;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B,UAAS,IAAI,UAAU,EAAE,gBAAgB,SAAQ,WAAW;AAAA,gBAC5D;AAAA,mBACG;AAAA,mBACA;AAAA,mBACA;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B;AAAA,mBACG;AAAA,mBACA;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B,UAAS,IAAI,UAAU,EAAE,gBAAgB,SAAQ,eAAe;AAAA,gBAChE;AAAA,mBACG;AAAA,mBACA;AAAA,mBACA;AAAA,gBACH,UAAS,MAAM,UAAS,KAAK;AAAA,gBAC7B,UAAS,IAAI,UAAU,EAAE,gBAAgB,SAAQ,iBAAiB;AAAA,gBAClE;AAAA;AAAA,UAEN;AAAA,UAEA,OAAO,CAAC,MAAM,WAAU,OAAM;AAAA,UAC9B,OAAO,QAAO;AAAA,UACd,OAAO,CAAC,UAAS,IAAI,MAAM,+BAA+B,GAAG,WAAU,IAAI;AAAA;AAAA;AAAA,MAS/E,MAAM,eAAe,YAAY;AAAA,QAC/B,IAAI,UAAU;AAAA,QACd,MAAM,gBAAgB,QAAQ,iBAAiB;AAAA,QAC/C,MAAM,aAAa,QAAQ,cAAc;AAAA,QAEzC,OAAO,UAAU,eAAe;AAAA,UAC9B,OAAO,QAAO,WAAU,WAAU,MAAM,aAAa;AAAA,UACrD,IAAI,CAAC,QAAO;AAAA,YACV,OAAO,CAAC,QAAO,WAAU,OAAM;AAAA,UACjC;AAAA,UACA,IAAI,CAAC,QAAQ,YAAY,SAAS,UAAS,UAAU,GAAG,GAAG;AAAA,YACzD,OAAO,CAAC,IAAI,MAAM,qBAAqB,GAAG,WAAU,OAAM;AAAA,UAC5D;AAAA,UAEA;AAAA,UACA,IAAI,WAAW,eAAe;AAAA,YAC5B,OAAO,CAAC,IAAI,MAAM,yBAAyB,GAAG,WAAU,OAAM;AAAA,UAChE;AAAA,UAEA,IAAI,YAAY,aAAa,KAAK,IAAI,GAAG,UAAU,CAAC;AAAA,UAEpD,MAAM,aAAa,UAAS,QAAQ,IAAI,aAAa;AAAA,UACrD,IAAI,YAAY;AAAA,YACd,MAAM,oBAAoB,SAAS,YAAY,EAAE;AAAA,YACjD,IAAI,CAAC,MAAM,iBAAiB,GAAG;AAAA,cAC7B,YAAY,KAAK,IAAI,WAAW,oBAAoB,IAAI;AAAA,YAC1D,EAAO;AAAA,cACL,MAAM,iBAAiB,IAAI,KAAK,UAAU,EAAE,QAAQ;AAAA,cACpD,IAAI,CAAC,MAAM,cAAc,GAAG;AAAA,gBAC1B,MAAM,cAAc,KAAK,IAAI;AAAA,gBAC7B,YAAY,KAAK,IAAI,WAAW,iBAAiB,WAAW;AAAA,cAC9D;AAAA;AAAA,UAEJ;AAAA,UAEA,MAAM,MAAM,SAAS;AAAA,QACvB;AAAA,QACA,OAAO,aAAa;AAAA;AAAA,MAGtB,OAAO,OAAO,UAAU,UAAU,MAAM,aAAa;AAAA,MACrD,IAAI,CAAC,SAAS,IAAI;AAAA,QAChB,OAAO,CAAC,IAAI,MAAM,SAAS,UAAU,GAAG,UAAU,MAAM;AAAA,MAC1D;AAAA,MACA,OAAO,CAAC,OAAO,UAAU,MAAM;AAAA;AAAA,IASjC,OAAO,OACL,gBACG;AAAA,MACH,MAAM,UAAU;AAAA,WACX;AAAA,WACA,eAAe,WAAW;AAAA,MAC/B;AAAA,MACA,IAAI,eAAe,SAAS;AAAA,QAC1B,QAAQ,UAAU;AAAA,aACb,eAAe;AAAA,aACf,QAAQ;AAAA,QACb;AAAA,MACF;AAAA,MAEA,IAAI,QAAQ,UAAU;AAAA,QACpB,MAAM,SAAS,QAAQ,QAAQ;AAAA,MACjC;AAAA,MAEA,IAAI,QAAQ,OAAO;AAAA,QACjB,MAAM,MAAM,QAAQ,KAAK;AAAA,MAC3B;AAAA,MAEA,IAAI,QAAQ,UAAU;AAAA,QACpB,MAAM,SAAS,QAAQ,QAAQ;AAAA,MACjC;AAAA,MAEA,IACE,QAAQ,kBACL,kBAAkB,QAAQ,gBAC7B;AAAA,QACA,MAAM,IAAI,QAAQ,aAAW;AAAA,UAC3B,IAAI,WAAW;AAAA,UACf,MAAM,OAAO,MAAM;AAAA,YACjB,IAAI,kBAAkB,QAAQ,gBAAgB;AAAA,cAC5C,WAAW,sBAAsB,IAAI;AAAA,YACvC,EAAO;AAAA,cACL,IAAI,UAAU;AAAA,gBACZ,cAAc,QAAQ;AAAA,cACxB;AAAA,cACA,QAAQ,IAAI;AAAA;AAAA;AAAA,UAGhB,WAAW,sBAAsB,IAAI;AAAA,SACtC;AAAA,MACH;AAAA,MAEA;AAAA,MACA,MAAM,UAAU,MAAM,YAAY,OAAO;AAAA,MACzC;AAAA,MACA,OAAO;AAAA;AAAA;;;ECxTX,KAAK;AAAA,IACH;AAAA,EACF,GAAG;AAAA,IACD;AAAA,EACF,CAAC;",
  "debugId": "2BC33C896393CC7E64756E2164756E21",
  "names": []
}