{
  "version": 3,
  "sources": ["../../../.scripts/iife.ts", "../src/utilities/clone.ts", "../src/utilities/delay.ts", "../src/utilities/type.ts", "../src/library/request.ts", "../src/library/parsers/csv.ts", "../src/library/parsers/ini.ts", "../src/library/parsers/toml.ts", "../src/library/parsers/yaml.ts", "../src/index.iife.ts"],
  "sourcesContent": ["export const iife = function (\n  path: Array<string>,\n  data: any\n) {\n  let subject: Record<string, any> = window\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof (subject[path[i]]) !== 'object' || !Array.isArray(subject[path[i]])) {\n      subject[path[i]] = {}\n    }\n    subject = subject[path[i]]\n  }\n  subject[path[path.length - 1]] = data\n}\n", "\nexport const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const delay = async (\n  time: number,\n): Promise<null> => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time)\n    )\n  }\n  return null\n}\n", "const normalizeContentType = (\n  contentType: string,\n): string => contentType.split(';')[0].trim().toLowerCase()\n\nconst getFileExtension = (\n  url: string,\n): string | null => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\nexport const getType = function (\n  url: string,\n  responseHeaders: Headers,\n  requestHeaders?: Record<string, string>,\n): string {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n", "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\nimport {\n  delay,\n} from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\nexport interface ResponseParser {\n  types: string[],\n  parser: (\n    response: Response,\n    options: RequestOptions,\n    type: string,\n  ) => any,\n}\n\nexport interface SendOptions {\n  body?: any\n  credentials?: RequestCredentials\n  domain?: string\n  headers?: Record<string, string>\n  method?: 'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'\n  mode?: RequestMode\n  path?: string\n  priority?: 'high' | 'normal' | 'low'\n  queryParams?: Record<string, string>\n  redirect?: RequestRedirect,\n  parsers?: ResponseParser[],\n  type?: string,\n\n  abort?: AbortController\n  cache?: RequestCache\n\n  debounce?: number\n  delay?: number\n  throttle?: number\n  timeout?: number\n  retryAttempts?: number\n  retryCodes?: number[]\n  retryDelay?: number\n}\n\nexport interface RequestOptions extends SendOptions {\n  maxConcurrency?: number\n  maxRequests?: number\n}\n\nconst DEFAULT_VALUES: RequestOptions = {\n  method: 'get',\n  retryCodes: [429, 503, 504,],\n  retryDelay: 500,\n}\n\nexport const create = (\n  initialOptions: RequestOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0\n  let debounceTimeout: number | null = null\n\n  const throttle = async (\n    throttleValue: number,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (\n      waitTime > 0\n        ? waitTime\n        : 0\n    )\n    await delay(waitTime)\n  }\n\n  const debounce = (\n    debounceValue: number,\n  ): Promise<void> => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(\n        resolve,\n        debounceValue,\n      )\n    })\n  }\n\n  const sendRequest = async (\n    options: RequestOptions,\n  ): Promise<[Error | null, Response | null, any]> => {\n    if (\n      options.maxRequests !== undefined\n      && totalRequests >= options.maxRequests\n    ) {\n      return [new Error('Maximum request limit reached'), null, null]\n    }\n\n    totalRequests++\n\n    const config: RequestInit = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n\n      body: (\n        options.body\n          ? JSON.stringify(options.body)\n          : undefined\n      ),\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(\n        options.queryParams,\n      ).toString()\n    }\n\n    if (options.timeout) {\n      const controller = (\n        options.abort\n        || new AbortController()\n      )\n      config.signal = controller.signal\n      setTimeout(\n        () => controller.abort(),\n        options.timeout,\n      );\n    }\n\n    const executeFetch = async (\n    ): Promise<[Error | null, Response, any]> => {\n      // let response = null\n      // try {\n      //   response = await fetch(url, config)\n      // } catch (error) {\n      //   return [(error as Error) || new Error('Thrown fetching error is falsely'), response, null]\n      // }\n      const response = await fetch(url, config)\n      if (!response.ok) {\n        return [new Error('Invalid response'), response, null]\n      }\n\n      try {\n        let result\n        let foundParser = false\n        const type = options.type || getType(url, response.headers, options.headers)\n        if (options.parsers) {\n          for (const parser of options.parsers) {\n            foundParser = parser.types.includes(type)\n            if (foundParser) {\n              result = await parser.parser(\n                response,\n                options,\n                type,\n              )\n              break\n            }\n          }\n        }\n        if (!foundParser) {\n          switch (type.toLowerCase()) {\n            case 'arraybuffer':\n              result = await response.arrayBuffer()\n              break\n\n            case 'blob':\n              result = await response.blob()\n              break\n\n            case 'formdata':\n              result = await response.formData()\n              break\n\n            case 'text/plain':\n            case 'text':\n            case 'txt':\n              result = await response.text()\n              break\n\n            case 'text/html-partial':\n            case 'html-partial':\n              result = await response.text()\n              const template = document.createElement('template')\n              template.innerHTML = result\n              result = template.content.childNodes\n              break\n\n            case 'text/html':\n            case 'html':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'text/html')\n              break\n\n            case 'application/json':\n            case 'text/json':\n            case 'json':\n              result = await response.json()\n              break\n\n            case 'image/svg+xml':\n            case 'svg':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'image/svg+xml')\n              break\n\n            case 'application/xml':\n            case 'text/xml':\n            case 'xml':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'application/xml')\n              break\n          }\n        }\n\n        return [null, response, result]\n      } catch (error) {\n        return [(error as Error) || new Error('Thrown parsing error is falsy'), response, null]\n      }\n    }\n\n    const retryRequest = async (\n    ): Promise<[Error | null, Response, any]> => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        const [error, response, result] = await executeFetch()\n        if (!error) {\n          return [error, response, result]\n        }\n        if (!options.retryCodes?.includes(response.status || 200)) {\n          return [new Error('Invalid status code'), response, result]\n        }\n\n        attempt++\n        if (attempt >= retryAttempts) {\n          return [new Error('Too many retry attempts'), response, result]\n        }\n\n        // Exponentially increase the retry delay.\n        let delayTime = retryDelay * Math.pow(2, attempt - 1)\n\n        // Try and respect the Retry-After header.\n        const retryAfter = response.headers.get('Retry-After')\n        if (retryAfter) {\n          const retryAfterSeconds = parseInt(retryAfter, 10)\n          if (!isNaN(retryAfterSeconds)) {\n            delayTime = Math.max(delayTime, retryAfterSeconds * 1000)\n          } else {\n            const retryAfterDate = new Date(retryAfter).getTime()\n            if (!isNaN(retryAfterDate)) {\n              const currentTime = Date.now()\n              delayTime = Math.max(delayTime, retryAfterDate - currentTime)\n            }\n          }\n        }\n\n        await delay(delayTime)\n      }\n      return executeFetch()\n    }\n\n    const [error, response, result] = await retryRequest()\n    if (!response.ok) {\n      return [new Error(response.statusText), response, result]\n    }\n    return [error, response, result]\n  }\n\n  return async (\n    sendOptions: SendOptions,\n  ): Promise<[Error | null, Response | null, any]> => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise((resolve) => {\n        let interval: number | null = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency!) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    const results = await sendRequest(\n      options,\n    )\n    activeRequests--\n    return results\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser\n} from '../request.js'\n\ninterface CsvOptions {\n  types?: string[],\n  hasHeaders?: boolean,\n\n  columnDelimiter?: string,\n  rowDelimiter?: string,\n  escapeCharacter?: string,\n}\n\n// TODO: Check if the file starts with a delimiter specified.\n\nconst tsvTypes = [\n  'tsv', 'text/tab-separated-values',\n]\n\nexport const csvParser = (\n  options: CsvOptions,\n): ResponseParser => {\n  return {\n    types: options?.types || [\n      'csv', 'text/csv',\n      ...tsvTypes,\n    ],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n      type: string,\n    ): Promise<any> => {\n      const optionsTemp = {\n        columnDelimiter: (\n          tsvTypes.includes(type)\n            ? '\t'\n            : ','\n        ),\n        rowDelimiter: '\\n',\n        escapeCharacter: '\"',\n\n        ...options,\n      }\n\n      const string = await response.text()\n\n      const rows: string[][] = []\n      let currentRow: string[] = []\n      let currentField = ''\n      let insideQuotes = false\n\n      for (let i = 0; i < string.length; i++) {\n        const character = string[i]\n        const nextCharacter = string[i + 1]\n\n        if (character === optionsTemp.escapeCharacter) {\n          if (\n            nextCharacter === optionsTemp.escapeCharacter\n            && insideQuotes\n          ) {\n            // Double quotes inside quotes.\n            currentField += optionsTemp.escapeCharacter\n            i++ // Skip next quote.\n          } else {\n            // Toggle insideQuotes.\n            insideQuotes = !insideQuotes\n          }\n        } else if (\n          character === optionsTemp.columnDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n        } else if (\n          character === optionsTemp.rowDelimiter\n          && !insideQuotes\n        ) {\n          currentRow.push(\n            currentField,\n          )\n          currentField = ''\n\n          rows.push(currentRow)\n          currentRow = []\n        } else {\n          currentField += character\n        }\n      }\n\n      // Push the last field and row if there's any.\n      if (currentField) {\n        currentRow.push(\n          currentField,\n        )\n        currentField = ''\n      }\n      if (currentRow.length > 0) {\n        rows.push(currentRow)\n      }\n\n      if (optionsTemp.hasHeaders) {\n        // Extract headers and create objects.\n        const headers = rows[0]\n        return rows.slice(1).map(row => {\n          return headers.reduce((\n            object: Record<string, string>,\n            header: string,\n            index: number,\n          ) => {\n            object[header] = row[index] || ''\n            return object\n          }, {})\n        })\n      }\n\n      return rows\n    }\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser,\n} from '../request.js'\n\ninterface IniOptions {\n  types?: string[],\n}\n\ninterface IniObject {\n  [section: string]: {\n    [key: string]: string\n  }\n}\n\nexport const iniParser = (\n  options: IniOptions = {},\n): ResponseParser => {\n  return {\n    types: options.types || ['ini',],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n    ): Promise<IniObject> => {\n      const text = await response.text()\n\n      const result: IniObject = {}\n      const lines = text\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n\n      let currentSection = ''\n      for (const line of lines) {\n        if (\n          line === ''\n          || line.startsWith(';')\n          || line.startsWith('#')\n        ) {\n          // Skip empty lines and comments.\n          continue\n        }\n\n        if (\n          line.startsWith('[')\n          && line.endsWith(']')\n        ) {\n          // New section.\n          currentSection = line.slice(1, -1).trim()\n          if (!result[currentSection]) {\n            result[currentSection] = {}\n          }\n        } else {\n          // Key-value pair.\n          const [key, ...valueParts] = line.split('=')\n          const value = valueParts.join('=').trim()\n\n          if (currentSection === '') {\n            // Global section (outside any named section).\n            if (!result['global']) {\n              result['global'] = {}\n            }\n            result['global'][key.trim()] = value\n          } else {\n            result[currentSection][key.trim()] = value\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser,\n} from '../request.js'\n\ninterface TomlOptions {\n  types?: string[],\n}\n\ntype TomlValue = string | number | boolean | Date | TomlObject | TomlValue[]\ninterface TomlObject {\n  [key: string]: TomlValue\n}\n\nconst parseTomlValue = (\n  value: string,\n): TomlValue => {\n  if (\n    value.startsWith('\"')\n    && value.endsWith('\"')\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value.startsWith(\"'\")\n    && value.endsWith(\"'\")\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value === 'true'\n    || value === 'false'\n  ) {\n    return value === 'true'\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (value.match(/^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(.\\d+)?(Z|[+-]\\d{2}:\\d{2})?)?$/)) {\n    return new Date(value)\n  }\n  return value\n}\n\nconst parseInlineTable = (\n  tableString: string,\n): TomlObject => {\n  const result: TomlObject = {}\n  let key = ''\n  let value = ''\n  let inQuotes = false\n  let quoteChar = ''\n  let inValue = false\n\n  for (let i = 1; i < tableString.length - 1; i++) {\n    const character = tableString[i]\n    if (\n      !inQuotes\n      && (\n        character === '\"'\n        || character === \"'\"\n      )\n    ) {\n      inQuotes = true\n      quoteChar = character\n    } else if (\n      inQuotes\n      && character === quoteChar\n    ) {\n      inQuotes = false\n    } else if (\n      !inQuotes\n      && character === '='\n    ) {\n      inValue = true\n    } else if (\n      !inQuotes\n      && character === ','\n    ) {\n      result[key.trim()] = parseTomlValue(value.trim())\n      key = ''\n      value = ''\n      inValue = false\n    } else {\n      if (inValue) {\n        value += character\n      } else {\n        key += character\n      }\n    }\n  }\n\n  if (key) {\n    result[key.trim()] = parseTomlValue(value.trim())\n  }\n\n  return result\n}\n\nexport const tomlParser = (\n  options: TomlOptions = {},\n): ResponseParser => {\n  return {\n    types: options.types || ['toml', 'application/toml'],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n    ): Promise<TomlObject> => {\n      const text = await response.text()\n\n      const result: TomlObject = {}\n      let currentTable: TomlObject = result\n      let currentArray: TomlValue[] | null = null\n      let multilineString: string | null = null\n      let multilineStringDelimiter: string | null = null\n\n      const lines = text.split(/\\r?\\n/)\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trim()\n\n        if (line === '' || line.startsWith('#')) {\n          continue // Skip empty lines and comments\n        }\n\n        if (multilineString !== null) {\n          if (line.endsWith(multilineStringDelimiter!)) {\n            multilineString += line.slice(0, -multilineStringDelimiter!.length)\n            currentTable[Object.keys(currentTable).pop()!] = multilineString\n            multilineString = null\n            multilineStringDelimiter = null\n          } else {\n            multilineString += line + '\\n'\n          }\n          continue\n        }\n\n        if (line.startsWith('[') && line.endsWith(']')) {\n          // Table\n          const tableName = line.slice(1, -1).trim()\n          currentTable = result\n          const parts = tableName.split('.')\n          for (const part of parts) {\n            if (!currentTable[part]) currentTable[part] = {}\n            currentTable = currentTable[part] as TomlObject\n          }\n          currentArray = null\n        } else if (line.startsWith('[[') && line.endsWith(']]')) {\n          // Array of Tables\n          const arrayName = line.slice(2, -2).trim()\n          const parts = arrayName.split('.')\n          let parent = result\n          for (let i = 0; i < parts.length - 1; i++) {\n            if (!parent[parts[i]]) parent[parts[i]] = {}\n            parent = parent[parts[i]] as TomlObject\n          }\n          const lastPart = parts[parts.length - 1]\n          if (!parent[lastPart]) parent[lastPart] = []\n          const newTable = {};\n          (parent[lastPart] as TomlValue[]).push(newTable)\n          currentTable = newTable as TomlObject\n          currentArray = null\n        } else {\n          // Key-value pair\n          const [key, ...valueParts] = line.split('=')\n          let value = valueParts.join('=').trim()\n\n          if (value.startsWith('\"\"\"') || value.startsWith(\"'''\")) {\n            // Multi-line string\n            multilineStringDelimiter = value.slice(0, 3)\n            multilineString = value.slice(3)\n            if (value.endsWith(multilineStringDelimiter)) {\n              currentTable[key.trim()] = multilineString.slice(0, -3)\n              multilineString = null\n              multilineStringDelimiter = null\n            }\n          } else if (value.startsWith('{') && value.endsWith('}')) {\n            // Inline table\n            currentTable[key.trim()] = parseInlineTable(value)\n          } else if (value.startsWith('[') && !value.endsWith(']')) {\n            // Multi-line array\n            currentArray = []\n            value = value.slice(1).trim()\n          } else {\n            if (currentArray !== null) {\n              if (value.endsWith(']')) {\n                currentArray.push(parseTomlValue(value.slice(0, -1).trim()))\n                currentTable[key.trim()] = currentArray\n                currentArray = null\n              } else {\n                currentArray.push(parseTomlValue(value))\n              }\n            } else {\n              currentTable[key.trim()] = parseTomlValue(value)\n            }\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n", "import {\n  RequestOptions,\n  ResponseParser,\n} from '../request.js'\n\ninterface YamlOptions {\n  types?: string[],\n  indentSize?: number,\n}\n\ntype YamlValue = string | number | boolean | null | YamlObject | YamlValue[]\ninterface YamlObject {\n  [key: string]: YamlValue,\n}\n\nconst parseValue = (\n  value: string,\n  anchors: Record<string, YamlValue>,\n): YamlValue => {\n  if (value === 'null' || value === '~') {\n    return null\n  }\n  if (value === 'true') {\n    return true\n  }\n  if (value === 'false') {\n    return false\n  }\n  if (\n    value.startsWith('\"')\n    && value.endsWith('\"')\n  ) {\n    return value.slice(1, -1)\n  }\n  if (\n    value.startsWith(\"'\")\n    && value.endsWith(\"'\")\n  ) {\n    return value.slice(1, -1)\n  }\n  if (!isNaN(Number(value))) {\n    return Number(value)\n  }\n  if (\n    value.startsWith('[')\n    && value.endsWith(']')\n  ) {\n    return value\n      .slice(1, -1)\n      .split(',')\n      .map(\n        item => parseValue(item.trim(), anchors)\n      )\n  }\n  if (value.startsWith('*')) {\n    const anchorName = value.slice(1).trim()\n    return anchors[anchorName]\n  }\n  if (value.includes('!!')) {\n    const [tag, tagValue] = value.split(' ')\n    switch (tag) {\n      case '!!int':\n        return parseInt(tagValue)\n      case '!!float':\n        return parseFloat(tagValue)\n      case '!!str':\n        return tagValue\n      case '!!bool':\n        return tagValue.toLowerCase() === 'true'\n      default:\n        return tagValue\n    }\n  }\n  return value\n}\n\nexport const yamlParser = (\n  options: YamlOptions = {},\n): ResponseParser => {\n  return {\n    types: options.types || ['yaml', 'application/yaml', 'text/yaml'],\n    parser: async (\n      response: Response,\n      requestOptions: RequestOptions,\n    ): Promise<any> => {\n      const lines = (await response.text())\n        .split('\\n')\n      const result: YamlObject = {}\n      let currentObject: YamlValue = result\n      let indentStack: YamlObject[] = [result]\n      let currentIndent = 0\n      let multilineKey: string | null = null\n      let multilineValue: string[] = []\n      const anchors: Record<string, YamlValue> = {}\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trimEnd()\n        if (line.trim().startsWith('#')) {\n          continue\n        }\n\n        const indent = line.search(/\\S/)\n\n        if (multilineKey !== null) {\n          if (indent > currentIndent) {\n            multilineValue.push(line.trim())\n            continue\n          } else {\n            currentObject[multilineKey] = multilineValue.join('\\n')\n            multilineKey = null\n            multilineValue = []\n          }\n        }\n\n        if (indent > currentIndent) {\n          indentStack.push(currentObject)\n          currentObject = currentObject[\n            Object.keys(currentObject).pop()!\n          ] as YamlObject\n        } else if (indent < currentIndent) {\n          while (indent < currentIndent) {\n            indentStack.pop()\n            currentObject = indentStack[indentStack.length - 1]\n            currentIndent -= options.indentSize || 2\n          }\n        }\n\n        currentIndent = indent\n\n        if (line.trim() === '-') {\n          if (!Array.isArray(currentObject)) {\n            const lastKey = Object.keys(currentObject).pop()!\n            currentObject[lastKey] = []\n            currentObject = currentObject[lastKey] as YamlValue[]\n          }\n          currentObject.push({})\n          currentObject = currentObject[currentObject.length - 1] as YamlObject\n          continue\n        }\n\n        const colonIndex = line.indexOf(':')\n        if (colonIndex === -1) {\n          continue\n        }\n\n        const key = line.slice(0, colonIndex).trim()\n        let value = line.slice(colonIndex + 1).trim()\n\n        if (value.startsWith('&')) {\n          const anchorName = value.slice(1).split(' ')[0]\n          value = value.slice(anchorName.length + 2).trim()\n          const parsedValue = parseValue(value, anchors)\n          anchors[anchorName] = parsedValue\n          currentObject[key] = parsedValue\n        } else if (value.startsWith('*')) {\n          const anchorName = value.slice(1).trim()\n          currentObject[key] = anchors[anchorName]\n        } else if (\n          value === '|'\n          || value === '>'\n        ) {\n          multilineKey = key\n          currentIndent += options.indentSize || 2\n        } else if (value) {\n          currentObject[key] = parseValue(value, anchors)\n        } else {\n          currentObject[key] = {}\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n", "import { iife } from '../../../.scripts/iife.js'\n\nimport { create } from './library/request.js'\n\nimport { csvParser } from './library/parsers/csv.js'\nimport { iniParser } from './library/parsers/ini.js'\nimport { tomlParser } from './library/parsers/toml.js'\nimport { yamlParser } from './library/parsers/yaml.js'\n\niife([\n  'vroagn',\n], {\n  create,\n\n  csvParser,\n  iniParser,\n  tomlParser,\n  yamlParser,\n})\n"],
  "mappings": "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",
  "names": ["response", "result", "error", "i"]
}
