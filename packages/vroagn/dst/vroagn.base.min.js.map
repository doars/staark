{
  "version": 3,
  "sources": ["../src/utilities/clone.ts", "../src/utilities/delay.ts", "../src/utilities/type.ts", "../src/library/request.ts"],
  "sourcesContent": ["\nexport const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const delay = async (\n  time: number,\n): Promise<null> => {\n  if (time > 0) {\n    return new Promise(\n      (resolve) => setTimeout(resolve, time)\n    )\n  }\n  return null\n}\n", "const normalizeContentType = (\n  contentType: string,\n): string => contentType.split(';')[0].trim().toLowerCase()\n\nconst getFileExtension = (\n  url: string,\n): string | null => {\n  const match = url.match(/\\.([^./?]+)(?:[?#]|$)/)\n  return match ? match[1].toLowerCase() : null\n}\n\nexport const getType = function (\n  url: string,\n  responseHeaders: Headers,\n  requestHeaders?: Record<string, string>,\n): string {\n  // Check Content-Type in response headers.\n  const contentType = responseHeaders.get('Content-Type')\n  if (contentType) {\n    return normalizeContentType(contentType)\n  }\n\n  // Check Accept in request headers.\n  if (requestHeaders) {\n    if (requestHeaders['Accept']) {\n      const acceptTypes = requestHeaders['Accept'].split(',')\n      for (const type of acceptTypes) {\n        if (type.trim() !== '*/*') {\n          return normalizeContentType(type)\n        }\n      }\n    }\n  }\n\n  // Check URL extension.\n  const extension = getFileExtension(url)\n  if (extension) {\n    return extension\n  }\n\n  return ''\n}\n", "import {\n  cloneRecursive,\n} from '../utilities/clone.js'\nimport {\n  delay,\n} from '../utilities/delay.js'\nimport { getType } from '../utilities/type.js'\n\nexport interface ResponseParser {\n  types: string[],\n  parser: (\n    response: Response,\n    options: RequestOptions,\n    type: string,\n  ) => any,\n}\n\nexport type FetchFunction = (\n  request: Request | string,\n  requestOptions?: RequestInit,\n) => Promise<Response>\n\nexport interface SendOptions {\n  body?: any\n  credentials?: RequestCredentials\n  domain?: string\n  headers?: Record<string, string>\n  method?: 'get' | 'post' | 'put' | 'delete' | 'patch' | 'head'\n  mode?: RequestMode\n  path?: string\n  priority?: 'high' | 'normal' | 'low'\n  queryParams?: Record<string, string>\n  redirect?: RequestRedirect,\n  parsers?: ResponseParser[],\n  type?: string,\n\n  abort?: AbortController\n  cache?: RequestCache\n  fetch?: FetchFunction,\n\n  debounce?: number\n  delay?: number\n  throttle?: number\n  timeout?: number\n  retryAttempts?: number\n  retryCodes?: number[]\n  retryDelay?: number\n}\n\nexport interface RequestOptions extends SendOptions {\n  maxConcurrency?: number\n  maxRequests?: number\n}\n\nconst DEFAULT_VALUES: RequestOptions = {\n  method: 'get',\n  retryCodes: [429, 503, 504,],\n  retryDelay: 500,\n}\n\nexport const create = (\n  initialOptions: RequestOptions,\n) => {\n  initialOptions = {\n    ...DEFAULT_VALUES,\n    ...cloneRecursive(initialOptions),\n  }\n\n  let lastExecutionTime = 0\n  let activeRequests = 0\n  let totalRequests = 0\n  let debounceTimeout: number | null = null\n\n  const throttle = async (\n    throttleValue: number,\n  ) => {\n    const now = Date.now()\n    const waitTime = throttleValue - (now - lastExecutionTime)\n    lastExecutionTime = now + (\n      waitTime > 0\n        ? waitTime\n        : 0\n    )\n    await delay(waitTime)\n  }\n\n  const debounce = (\n    debounceValue: number,\n  ): Promise<void> => {\n    return new Promise((resolve) => {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout)\n      }\n      debounceTimeout = setTimeout(\n        resolve,\n        debounceValue,\n      )\n    })\n  }\n\n  const sendRequest = async (\n    options: RequestOptions,\n  ): Promise<[Error | null, Response | null, any]> => {\n    if (\n      options.maxRequests !== undefined\n      && totalRequests >= options.maxRequests\n    ) {\n      return [new Error('Maximum request limit reached'), null, null]\n    }\n\n    totalRequests++\n\n    const config: RequestInit = {\n      cache: options.cache,\n      credentials: options.credentials,\n      headers: options.headers,\n      method: options.method,\n      mode: options.mode,\n      redirect: options.redirect,\n\n      body: (\n        options.body\n          ? JSON.stringify(options.body)\n          : undefined\n      ),\n    }\n\n    let url = (options.domain || '') + (options.path || '')\n    if (options.queryParams) {\n      url += '?' + new URLSearchParams(\n        options.queryParams,\n      ).toString()\n    }\n\n    if (options.timeout) {\n      const controller = (\n        options.abort\n        || new AbortController()\n      )\n      config.signal = controller.signal\n      setTimeout(\n        () => controller.abort(),\n        options.timeout,\n      );\n    }\n\n    const executeFetch = async (\n    ): Promise<[Error | null, Response, any]> => {\n      // let response = null\n      // try {\n      //   response = await fetch(url, config)\n      // } catch (error) {\n      //   return [(error as Error) || new Error('Thrown fetching error is falsely'), response, null]\n      // }\n      const response = await (options.fetch ?? fetch)(url, config)\n      if (!response.ok) {\n        return [new Error('Invalid response'), response, null]\n      }\n\n      try {\n        let result\n        let foundParser = false\n        const type = options.type || getType(url, response.headers, options.headers)\n        if (options.parsers) {\n          for (const parser of options.parsers) {\n            foundParser = parser.types.includes(type)\n            if (foundParser) {\n              result = await parser.parser(\n                response,\n                options,\n                type,\n              )\n              break\n            }\n          }\n        }\n        if (!foundParser) {\n          switch (type.toLowerCase()) {\n            case 'arraybuffer':\n              result = await response.arrayBuffer()\n              break\n\n            case 'blob':\n              result = await response.blob()\n              break\n\n            case 'formdata':\n              result = await response.formData()\n              break\n\n            case 'text/plain':\n            case 'text':\n            case 'txt':\n              result = await response.text()\n              break\n\n            case 'text/html-partial':\n            case 'html-partial':\n              result = await response.text()\n              const template = document.createElement('template')\n              template.innerHTML = result\n              result = template.content.childNodes\n              break\n\n            case 'text/html':\n            case 'html':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'text/html')\n              break\n\n            case 'application/json':\n            case 'text/json':\n            case 'json':\n              result = await response.json()\n              break\n\n            case 'image/svg+xml':\n            case 'svg':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'image/svg+xml')\n              break\n\n            case 'application/xml':\n            case 'text/xml':\n            case 'xml':\n              result = await response.text()\n              result = (new DOMParser()).parseFromString(result, 'application/xml')\n              break\n          }\n        }\n\n        return [null, response, result]\n      } catch (error) {\n        return [(error as Error) || new Error('Thrown parsing error is falsy'), response, null]\n      }\n    }\n\n    const retryRequest = async (\n    ): Promise<[Error | null, Response, any]> => {\n      let attempt = 0\n      const retryAttempts = options.retryAttempts || 0\n      const retryDelay = options.retryDelay || 0\n\n      while (attempt < retryAttempts) {\n        const [error, response, result] = await executeFetch()\n        if (!error) {\n          return [error, response, result]\n        }\n        if (!options.retryCodes?.includes(response.status || 200)) {\n          return [new Error('Invalid status code'), response, result]\n        }\n\n        attempt++\n        if (attempt >= retryAttempts) {\n          return [new Error('Too many retry attempts'), response, result]\n        }\n\n        // Exponentially increase the retry delay.\n        let delayTime = retryDelay * Math.pow(2, attempt - 1)\n\n        // Try and respect the Retry-After header.\n        const retryAfter = response.headers.get('Retry-After')\n        if (retryAfter) {\n          const retryAfterSeconds = parseInt(retryAfter, 10)\n          if (!isNaN(retryAfterSeconds)) {\n            delayTime = Math.max(delayTime, retryAfterSeconds * 1000)\n          } else {\n            const retryAfterDate = new Date(retryAfter).getTime()\n            if (!isNaN(retryAfterDate)) {\n              const currentTime = Date.now()\n              delayTime = Math.max(delayTime, retryAfterDate - currentTime)\n            }\n          }\n        }\n\n        await delay(delayTime)\n      }\n      return executeFetch()\n    }\n\n    const [error, response, result] = await retryRequest()\n    if (!response.ok) {\n      return [new Error(response.statusText), response, result]\n    }\n    return [error, response, result]\n  }\n\n  return async (\n    sendOptions: SendOptions,\n  ): Promise<[Error | null, Response | null, any]> => {\n    const options = {\n      ...initialOptions,\n      ...cloneRecursive(sendOptions),\n    }\n    if (initialOptions.headers) {\n      options.headers = {\n        ...initialOptions.headers,\n        ...options.headers,\n      }\n    }\n\n    if (options.debounce) {\n      await debounce(options.debounce)\n    }\n\n    if (options.delay) {\n      await delay(options.delay)\n    }\n\n    if (options.throttle) {\n      await throttle(options.throttle)\n    }\n\n    if (\n      options.maxConcurrency\n      && activeRequests >= options.maxConcurrency\n    ) {\n      await new Promise((resolve) => {\n        let interval: number | null = null\n        const wait = () => {\n          if (activeRequests >= options.maxConcurrency!) {\n            interval = requestAnimationFrame(wait)\n          } else {\n            if (interval) {\n              clearInterval(interval)\n            }\n            resolve(null)\n          }\n        }\n        interval = requestAnimationFrame(wait)\n      })\n    }\n\n    activeRequests++\n    const results = await sendRequest(\n      options,\n    )\n    activeRequests--\n    return results\n  }\n}\n"],
  "mappings": "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",
  "names": ["cloneRecursive", "value", "clone", "i", "key", "delay", "time", "__async", "resolve", "normalizeContentType", "contentType", "getFileExtension", "url", "match", "getType", "responseHeaders", "requestHeaders", "acceptTypes", "type", "extension", "DEFAULT_VALUES", "create", "initialOptions", "__spreadValues", "cloneRecursive", "lastExecutionTime", "activeRequests", "totalRequests", "debounceTimeout", "throttle", "throttleValue", "__async", "now", "waitTime", "delay", "debounce", "debounceValue", "resolve", "sendRequest", "options", "config", "url", "controller", "executeFetch", "_a", "response", "result", "foundParser", "type", "getType", "parser", "template", "error", "retryRequest", "attempt", "retryAttempts", "retryDelay", "delayTime", "retryAfter", "retryAfterSeconds", "retryAfterDate", "currentTime", "sendOptions", "interval", "wait", "results"]
}
