{
  "version": 3,
  "sources": ["../../staark-common/src/array.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/element.ts", "../src/library/patch.ts"],
  "sourcesContent": ["/**\n * Ensure the data is an array of not already. Non-truthy values are converted to empty arrays.\n * @param data Data to arrify\n * @returns An array with the data.\n */\nexport const arrayify = <T>(\n  data: T[] | T,\n): T[] => arrayifyOrUndefined(data) ?? []\n\n/**\n * Ensure the data is an array of not already. Non-truthy values are converted to undefined.\n * @param data Data to arrify\n * @returns An array with the data or undefined.\n */\nexport const arrayifyOrUndefined = <T>(\n  data: T[] | T,\n): T[] | undefined => (\n  data\n    ? Array.isArray(data)\n      ? data :\n      [data,]\n    : undefined\n)\n", "export const marker = 'n'\n", "import {\n  arrayifyOrUndefined\n} from './array.js'\nimport {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\n\ntype _NodeAttributeListener = {\n  (event: Event, state: Record<string, any>): unknown\n  (event: Event): unknown\n  (): unknown\n}\n\nexport interface NodeAttributeListener extends _NodeAttributeListener {\n  f?: _NodeAttributeListener\n}\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract\n\nexport type NodeAbstract = {\n  // Discriminator\n  _: string,\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: arrayifyOrUndefined(contents) as NodeContent[] | undefined,\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport const childrenToNodes = (\n  element: Element | ChildNode,\n) => {\n  const abstractChildNodes: NodeContent[] = []\n  for (const childNode of element.childNodes) {\n    if (childNode instanceof Text) {\n      abstractChildNodes.push(\n        childNode.textContent ?? ''\n      )\n    } else {\n      const elementChild = childNode as Element\n      const attributes: NodeAttributes = {}\n      for (const attribute of elementChild.attributes) {\n        attributes[attribute.name] = attribute.value\n      }\n\n      abstractChildNodes.push(\n        node(\n          childNode.nodeName,\n          attributes,\n          childrenToNodes(childNode),\n        )\n      )\n    }\n  }\n  return abstractChildNodes\n}\n", "import {\n  arrayifyOrUndefined,\n} from '@doars/staark-common/src/array.js'\nimport {\n  childrenToNodes,\n} from '@doars/staark-common/src/element.js'\nimport {\n  NodeAbstract,\n  NodeAttributes,\n  NodeAttributeListener,\n  NodeContent,\n} from '@doars/staark-common/src/node.js'\n\nexport type PatchFunction = (\n  newAbstractTree: NodeContent[] | NodeContent,\n) => void\n\nconst updateAttributes = (\n  element: Element,\n  newAttributes?: NodeAttributes,\n  oldAttributes?: NodeAttributes,\n): void => {\n  if (newAttributes) {\n    for (const name in newAttributes) {\n      let value = newAttributes[name]\n      if (value) {\n        const type = typeof (value)\n        if (type === 'function') {\n          const oldValue = oldAttributes?.[name]\n          if (oldValue !== value) {\n            if (oldValue) {\n              element.removeEventListener(\n                name,\n                oldValue as NodeAttributeListener,\n              )\n            }\n\n            element.addEventListener(\n              name,\n              value as NodeAttributeListener,\n            )\n          }\n        } else {\n          if (name === 'class') {\n            if (typeof (value) === 'object') {\n              if (Array.isArray(value)) {\n                value = value.join(' ')\n              } else {\n                let classNames: string = ''\n                for (const className in value) {\n                  if (value[className]) {\n                    classNames += ' ' + className\n                  }\n                }\n                value = classNames\n              }\n            }\n            element.className = value as string\n          } else if (\n            name === 'style'\n            && typeof (value) === 'object'\n          ) {\n            // Apply updated styles.\n            for (let styleName in value) {\n              let styleValue = (\n                value as Record<string, boolean | string | null | undefined | number | (boolean | string | number)[]>\n              )[styleName]\n              if (styleName.includes('-', 1)) {\n                (element as HTMLElement).style.setProperty(\n                  styleName,\n                  styleValue as string,\n                )\n              } else {\n                // @ts-ignore\n                (element as HTMLElement).style[styleName] = styleValue as string\n              }\n            }\n\n            // Remove old styles.\n            if (\n              oldAttributes\n              && oldAttributes[name]\n              && typeof (oldAttributes[name]) === 'object'\n              && !Array.isArray(oldAttributes[name])\n            ) {\n              for (let styleName in oldAttributes[name]) {\n                if (!(styleName in value)) {\n                  if (styleName.includes('-')) {\n                    (element as HTMLElement).style.removeProperty(\n                      styleName,\n                    )\n                  } else {\n                    // @ts-ignore\n                    delete (element as HTMLElement).style[styleName]\n                  }\n                }\n              }\n            }\n          } else {\n            // Ensure it is of type string.\n            if (value === true) {\n              value = 'true'\n            } else if (type !== 'string') {\n              value = value.toString()\n            }\n\n            // Setting attribute will automatically update the elements checked and value state.\n            // if (\n            //   name === 'value'\n            //   && (element as HTMLInputElement).value !== value\n            // ) {\n            // (element as HTMLInputElement).value = value as string\n            // Don't dispatch a change event, the re-rendering should update everything: element.dispatchEvent(new Event('change'))\n            // } else if (name === 'checked') {\n            //   (element as HTMLInputElement).checked = !!value\n            // Don't dispatch a change event, the re-rendering should update everything: element.dispatchEvent(new Event('change'))\n            // }\n\n            element.setAttribute(name, (value as string))\n          }\n        }\n      }\n    }\n  }\n\n  // Cleanup old attributes.\n  if (oldAttributes) {\n    for (const name in oldAttributes) {\n      if (\n        !newAttributes\n        || !newAttributes[name]\n      ) {\n        if (typeof (oldAttributes[name]) === 'function') {\n          element.removeEventListener(\n            name,\n            oldAttributes[name] as NodeAttributeListener,\n          )\n        } else if (name === 'class') {\n          element.className = ''\n        } else if (name === 'style') {\n          (element as HTMLElement).style.cssText = ''\n        } else {\n          // Setting attribute will automatically update the elements checked and value state.\n          // if (name === 'value') {\n          // (element as HTMLInputElement).value = ''\n          // Don't dispatch the input change event, the rerendering should update everything: element.dispatchEvent(new Event('change'))\n          // } else if (name === 'checked') {\n          //   (element as HTMLInputElement).checked = false\n          // }\n          element.removeAttribute(name)\n        }\n      }\n    }\n  }\n}\n\nconst updateElementTree = (\n  element: Element,\n  newChildAbstracts?: NodeContent[],\n  oldChildAbstracts?: NodeContent[],\n): void => {\n  // TODO: Iterate over nodes and keep track of where you are in each list, both old and new abstracts. The index in the old and new child abstracts does not have to be the same. If the index in the old child abstracts is lower than new child abstracts then new nodes have been inserted in which is fine. Doing this prevents splice from needing to be called on the existing old child abstracts.\n\n  let newIndex = 0\n  let newCount = 0\n  if (newChildAbstracts) {\n    for (; newIndex < newChildAbstracts.length; newIndex++) {\n      const newAbstract = newChildAbstracts[newIndex]\n\n      // Try to find the matching old abstract.\n      let matched = false\n      if (oldChildAbstracts) {\n        for (let oldIndex = newIndex - newCount; oldIndex < oldChildAbstracts.length; oldIndex++) {\n          const oldAbstract = oldChildAbstracts[oldIndex]\n          if (\n            (\n              (oldAbstract as NodeAbstract).t\n              && (newAbstract as NodeAbstract).t === (oldAbstract as NodeAbstract).t\n            )\n            || (\n              !(oldAbstract as NodeAbstract).t\n              && !(newAbstract as NodeAbstract).t\n            )\n          ) {\n            matched = true\n\n            if (newIndex !== (oldIndex + newCount)) {\n              // Move node in dom.\n              element.insertBefore(\n                element.childNodes[oldIndex + newCount],\n                element.childNodes[newIndex],\n              )\n              // Move node in abstract tree.\n              oldChildAbstracts.splice(\n                newIndex - newCount,\n                0,\n                oldChildAbstracts.splice(\n                  oldIndex,\n                  1,\n                )[0]\n              )\n            }\n\n            if ((newAbstract as NodeAbstract).t) {\n              updateAttributes(\n                (element.childNodes[newIndex] as Element),\n                (newAbstract as NodeAbstract).a,\n                (oldAbstract as NodeAbstract).a,\n              )\n              updateElementTree(\n                (element.childNodes[newIndex] as Element),\n                (newAbstract as NodeAbstract).c,\n                (oldAbstract as NodeAbstract).c,\n              )\n            } else if (oldAbstract !== newAbstract) {\n              element.childNodes[newIndex].textContent = newAbstract as string\n            }\n            break\n          }\n        }\n      }\n\n      if (!matched) {\n        let newNode: Node\n        if ((newAbstract as NodeAbstract).t) {\n          newNode = document.createElement(\n            (newAbstract as NodeAbstract).t,\n          )\n          updateAttributes(\n            newNode as HTMLElement,\n            (newAbstract as NodeAbstract).a,\n          )\n          updateElementTree(\n            newNode as HTMLElement,\n            (newAbstract as NodeAbstract).c,\n          )\n        } else {\n          newNode = document.createTextNode(\n            newAbstract as string,\n          )\n        }\n\n        element.insertBefore(\n          newNode,\n          element.childNodes[newIndex],\n        )\n        newCount++\n      }\n    }\n  }\n\n  // Remove old elements.\n  if (oldChildAbstracts) {\n    const elementLength = oldChildAbstracts.length + newCount\n    if (elementLength >= newIndex) {\n      for (let i = elementLength - 1; i >= newIndex; i--) {\n        element.childNodes[i].remove()\n      }\n    }\n  }\n}\n\nexport const prepare = (\n  rootElement: HTMLElement | Element | string,\n  oldAbstractTree?: NodeContent[] | string | null,\n): PatchFunction => {\n  const _rootElement = (\n    typeof (rootElement) === 'string'\n      ? (\n        document.querySelector(rootElement)\n        || document.body.appendChild(\n          document.createElement('div')\n        )\n      )\n      : rootElement\n  )\n\n  if (typeof (oldAbstractTree) === 'string') {\n    try {\n      oldAbstractTree = JSON.parse(oldAbstractTree) as NodeContent[]\n    } catch (error) {\n      oldAbstractTree = null\n    }\n  }\n  if (!oldAbstractTree) {\n    oldAbstractTree = childrenToNodes(_rootElement)\n  }\n\n  return (\n    newAbstractTree: NodeContent[] | NodeContent | undefined,\n  ): void => {\n    newAbstractTree = arrayifyOrUndefined(newAbstractTree) as NodeContent[] | undefined\n    updateElementTree(\n      _rootElement,\n      newAbstractTree,\n      oldAbstractTree as NodeContent[],\n    )\n    oldAbstractTree = newAbstractTree\n  }\n}\n"],
  "mappings": "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",
  "names": ["arrayifyOrUndefined", "data", "marker", "node", "type", "attributesOrContents", "contents", "marker", "arrayifyOrUndefined", "childrenToNodes", "element", "_a", "abstractChildNodes", "childNode", "elementChild", "attributes", "attribute", "node", "updateAttributes", "element", "newAttributes", "oldAttributes", "name", "value", "type", "oldValue", "classNames", "className", "styleName", "styleValue", "updateElementTree", "newChildAbstracts", "oldChildAbstracts", "newIndex", "newCount", "newAbstract", "matched", "oldIndex", "oldAbstract", "newNode", "elementLength", "i", "prepare", "rootElement", "oldAbstractTree", "_rootElement", "error", "childrenToNodes", "newAbstractTree", "arrayifyOrUndefined"]
}
