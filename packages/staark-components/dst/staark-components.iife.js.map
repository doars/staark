{
  "version": 3,
  "sources": ["../../../.scripts/iife.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/factory.ts", "../../staark-common/src/selector.ts", "../../staark-common/src/fctory.ts", "../../staark-common/src/array.ts", "../../staark-common/src/attribute.ts", "../../staark-common/src/clone.ts", "../../staark-common/src/compare.ts", "../../staark-common/src/conditional.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/element.ts", "../../staark-common/src/factory.ts", "../../staark-common/src/selector.ts", "../../staark-common/src/fctory.ts", "../../staark-common/src/identifier.ts", "../../staark-common/src/memo.ts", "../../staark-common/src/nde.ts", "../../staark-common/src/text.ts", "../src/scripts/inputField.ts", "../src/scripts/inputList.ts", "../src/index.iife.ts"],
  "sourcesContent": ["export const iife = function (\n  path: Array<string>,\n  data: any\n) {\n  let subject: Record<string, any> = window\n  for (let i = 0; i < path.length - 1; i++) {\n    if (\n      typeof (subject[path[i]]) !== 'object'\n      || !Array.isArray(subject[path[i]])\n    ) {\n      subject[path[i]] = {}\n    }\n    subject = subject[path[i]]\n  }\n  subject[path[path.length - 1]] = data\n}\n", "export const marker = Symbol()\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\nimport {\n  TextAbstract,\n} from './text.js'\n\nexport type NodeAttributeListener = (\n  event: Event\n) => unknown\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract |\n  TextAbstract\n\nexport type NodeAbstract = {\n  _: Symbol\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport type Factory = (\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FactoryCache = {\n  [key: string]: Factory,\n}\n\nexport const factory = new Proxy({}, {\n  get: (\n    target: FactoryCache,\n    type: string,\n  ): Factory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => node(\n      typeConverted,\n      attributesOrContents,\n      contents,\n    )\n  },\n})\n", "const BRACKET_CLOSE = ']'\nconst BRACKET_OPEN = '['\nconst DOT = '.'\nconst EQUAL = '='\nconst HASH = '#'\nconst QUOTE_SINGLE = '\\''\nconst QUOTE_DOUBLE = '\"'\n\nenum TokenTypes {\n  attribute = 0,\n  class = 1,\n  id = 2,\n  type = 3,\n}\n\nexport const selectorToTokenizer = (\n  selector: string,\n): [string, Record<string, any>] => {\n  const length: number = selector.length\n  let i: number = 0\n\n  let type: string = ''\n  const attributes: Record<string, any> = {}\n\n  let tokenA: string = ''\n  let tokenB: string | true = true\n  let tokenType: TokenTypes = TokenTypes.type\n  const storeToken = () => {\n    if (tokenA) {\n      switch (tokenType) {\n        case TokenTypes.attribute:\n          attributes[tokenA] = tokenB === true ? true : tokenB\n          tokenB = true\n          break\n\n        case TokenTypes.class:\n          if (!attributes.class) {\n            attributes.class = tokenA\n            break\n          }\n          attributes.class += ' ' + tokenA\n          break\n\n        case TokenTypes.id:\n          attributes.id = tokenA\n          break\n\n        case TokenTypes.type:\n          type = tokenA\n          break\n      }\n      tokenA = ''\n    }\n  }\n\n  let character: string\n\n  let attributeBracketCount: number\n  const parseAttribute = (\n  ): void => {\n    attributeBracketCount = 0\n\n    while (i < length) {\n      character = selector[i]\n      i++\n      if (character === EQUAL) {\n        // Parse attribute value.\n        tokenB = ''\n        character = selector[i]\n        const endOnDoubleQuote = character === QUOTE_DOUBLE\n        const endOnSingleQuote = character === QUOTE_SINGLE\n        if (endOnDoubleQuote || endOnSingleQuote) {\n          tokenB += character\n          i++\n        }\n\n        while (i < length) {\n          character = selector[i]\n          if (\n            (endOnDoubleQuote && character === QUOTE_DOUBLE) ||\n            (endOnSingleQuote && character === QUOTE_SINGLE)\n          ) {\n            tokenB += character\n            i++\n            break\n          } else if (\n            !endOnDoubleQuote &&\n            !endOnSingleQuote &&\n            character === BRACKET_CLOSE\n          ) {\n            break\n          }\n          tokenB += character\n          i++\n        }\n\n        if (\n          (\n            tokenB[0] === QUOTE_DOUBLE &&\n            tokenB[tokenB.length - 1] === QUOTE_DOUBLE\n          ) ||\n          (\n            tokenB[0] === QUOTE_SINGLE &&\n            tokenB[tokenB.length - 1] === QUOTE_SINGLE\n          )\n        ) {\n          tokenB = tokenB.substring(1, tokenB.length - 1)\n        }\n\n\n        // Consume until closing bracket, but don't store the tokes since these are invalid.\n        while (i < length) {\n          character = selector[i]\n          i++\n          if (character === BRACKET_CLOSE) {\n            break\n          }\n        }\n        break\n      } else if (character === BRACKET_OPEN) {\n        attributeBracketCount++\n        continue\n      } else if (character === BRACKET_CLOSE) {\n        attributeBracketCount--\n        if (attributeBracketCount < 0) {\n          break\n        }\n        continue\n      }\n\n      tokenA += character\n    }\n    storeToken()\n  }\n\n  while (i < length) {\n    character = selector[i]\n    i++\n\n    if (character === HASH) {\n      storeToken()\n      tokenType = TokenTypes.id\n      continue\n    } else if (character === DOT) {\n      storeToken()\n      tokenType = TokenTypes.class\n      continue\n    } else if (character === BRACKET_OPEN) {\n      storeToken()\n      tokenType = TokenTypes.attribute\n      parseAttribute()\n      continue\n    }\n\n    tokenA += character\n  }\n\n  return [type, attributes]\n}\n", "\nimport {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport type Fctory = (\n  attributes?: string,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FctoryCache = {\n  [key: string]: Fctory,\n}\n\nexport const fctory = new Proxy({}, {\n  get: (\n    target: FctoryCache,\n    type: string,\n  ): Fctory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      selector?: string,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => {\n      let attributes: NodeAttributes | undefined\n      if (selector) {\n        const [_, _attributes] = selectorToTokenizer(selector)\n        attributes = _attributes\n      }\n      return node(\n        typeConverted,\n        attributes,\n        contents,\n      )\n    }\n  },\n})\n", "export const arrayify = function <T>(\n  data: T[] | T,\n): T[] {\n  if (Array.isArray(data)) {\n    return data\n  }\n  return [\n    data,\n  ]\n}\n", "const SUFFIX_MULTIPLE: string = '[]'\n\nexport type MultipleAttributes = {\n  multiple?: boolean,\n  name?: string,\n}\n\nexport const suffixNameIfMultiple = (\n  attributes: MultipleAttributes,\n) => {\n  if (\n    attributes.multiple\n    && attributes.name\n    && !attributes.name.endsWith(SUFFIX_MULTIPLE)\n  ) {\n    attributes.name += SUFFIX_MULTIPLE\n  }\n}\n", "export const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const equalRecursive = (\n  valueA: any,\n  valueB: any,\n): boolean => {\n  if (valueA === valueB) {\n    return true\n  }\n  if (\n    valueA instanceof Date\n    && valueB instanceof Date\n  ) {\n    return valueA.getTime() === valueB.getTime()\n  }\n  if (\n    !valueA\n    || !valueB\n    || (\n      typeof valueA !== 'object' && typeof valueB !== 'object'\n    )\n  ) {\n    return valueA === valueB\n  }\n  if (\n    valueA === null\n    || valueA === undefined\n    || valueB === null\n    || valueB === undefined\n  ) {\n    return false\n  }\n  if (valueA.prototype !== valueB.prototype) {\n    return false\n  }\n  let keys = Object.keys(valueA)\n  if (keys.length !== Object.keys(valueB).length) {\n    return false\n  }\n  return keys.every(\n    (key: string): boolean => equalRecursive(valueA[key], valueB[key]),\n  )\n}\n", "import { arrayify } from './array.js'\nimport { NodeAbstract } from './node.js'\n\nexport const conditional = (\n  condition: any,\n  onTruth: NodeAbstract[] | NodeAbstract,\n  onFalse?: NodeAbstract[] | NodeAbstract,\n): NodeAbstract[] => {\n  if (condition) {\n    return arrayify(onTruth)\n  }\n  return arrayify(onFalse ?? [])\n}\n", "export const marker = Symbol()\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\nimport {\n  TextAbstract,\n} from './text.js'\n\nexport type NodeAttributeListener = (\n  event: Event\n) => unknown\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract |\n  TextAbstract\n\nexport type NodeAbstract = {\n  _: Symbol\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport const childrenToNodes = (\n  element: Element | ChildNode,\n) => {\n  const abstractChildNodes: NodeContent[] = []\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const childNode = element.childNodes[i]\n    if (childNode instanceof Text) {\n      abstractChildNodes.push(\n        childNode.textContent ?? ''\n      )\n    } else {\n      let attributes: NodeAttributes = {}\n      for (let i = 0; i < (childNode as Element).attributes.length; i++) {\n        const attribute = (childNode as Element).attributes[i]\n        attributes[attribute.name] = attribute.value\n      }\n\n      abstractChildNodes.push(\n        node(\n          childNode.nodeName,\n          attributes,\n          childrenToNodes(childNode),\n        )\n      )\n    }\n  }\n  return abstractChildNodes\n}\n", "import {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport type Factory = (\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FactoryCache = {\n  [key: string]: Factory,\n}\n\nexport const factory = new Proxy({}, {\n  get: (\n    target: FactoryCache,\n    type: string,\n  ): Factory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => node(\n      typeConverted,\n      attributesOrContents,\n      contents,\n    )\n  },\n})\n", "const BRACKET_CLOSE = ']'\nconst BRACKET_OPEN = '['\nconst DOT = '.'\nconst EQUAL = '='\nconst HASH = '#'\nconst QUOTE_SINGLE = '\\''\nconst QUOTE_DOUBLE = '\"'\n\nenum TokenTypes {\n  attribute = 0,\n  class = 1,\n  id = 2,\n  type = 3,\n}\n\nexport const selectorToTokenizer = (\n  selector: string,\n): [string, Record<string, any>] => {\n  const length: number = selector.length\n  let i: number = 0\n\n  let type: string = ''\n  const attributes: Record<string, any> = {}\n\n  let tokenA: string = ''\n  let tokenB: string | true = true\n  let tokenType: TokenTypes = TokenTypes.type\n  const storeToken = () => {\n    if (tokenA) {\n      switch (tokenType) {\n        case TokenTypes.attribute:\n          attributes[tokenA] = tokenB === true ? true : tokenB\n          tokenB = true\n          break\n\n        case TokenTypes.class:\n          if (!attributes.class) {\n            attributes.class = tokenA\n            break\n          }\n          attributes.class += ' ' + tokenA\n          break\n\n        case TokenTypes.id:\n          attributes.id = tokenA\n          break\n\n        case TokenTypes.type:\n          type = tokenA\n          break\n      }\n      tokenA = ''\n    }\n  }\n\n  let character: string\n\n  let attributeBracketCount: number\n  const parseAttribute = (\n  ): void => {\n    attributeBracketCount = 0\n\n    while (i < length) {\n      character = selector[i]\n      i++\n      if (character === EQUAL) {\n        // Parse attribute value.\n        tokenB = ''\n        character = selector[i]\n        const endOnDoubleQuote = character === QUOTE_DOUBLE\n        const endOnSingleQuote = character === QUOTE_SINGLE\n        if (endOnDoubleQuote || endOnSingleQuote) {\n          tokenB += character\n          i++\n        }\n\n        while (i < length) {\n          character = selector[i]\n          if (\n            (endOnDoubleQuote && character === QUOTE_DOUBLE) ||\n            (endOnSingleQuote && character === QUOTE_SINGLE)\n          ) {\n            tokenB += character\n            i++\n            break\n          } else if (\n            !endOnDoubleQuote &&\n            !endOnSingleQuote &&\n            character === BRACKET_CLOSE\n          ) {\n            break\n          }\n          tokenB += character\n          i++\n        }\n\n        if (\n          (\n            tokenB[0] === QUOTE_DOUBLE &&\n            tokenB[tokenB.length - 1] === QUOTE_DOUBLE\n          ) ||\n          (\n            tokenB[0] === QUOTE_SINGLE &&\n            tokenB[tokenB.length - 1] === QUOTE_SINGLE\n          )\n        ) {\n          tokenB = tokenB.substring(1, tokenB.length - 1)\n        }\n\n\n        // Consume until closing bracket, but don't store the tokes since these are invalid.\n        while (i < length) {\n          character = selector[i]\n          i++\n          if (character === BRACKET_CLOSE) {\n            break\n          }\n        }\n        break\n      } else if (character === BRACKET_OPEN) {\n        attributeBracketCount++\n        continue\n      } else if (character === BRACKET_CLOSE) {\n        attributeBracketCount--\n        if (attributeBracketCount < 0) {\n          break\n        }\n        continue\n      }\n\n      tokenA += character\n    }\n    storeToken()\n  }\n\n  while (i < length) {\n    character = selector[i]\n    i++\n\n    if (character === HASH) {\n      storeToken()\n      tokenType = TokenTypes.id\n      continue\n    } else if (character === DOT) {\n      storeToken()\n      tokenType = TokenTypes.class\n      continue\n    } else if (character === BRACKET_OPEN) {\n      storeToken()\n      tokenType = TokenTypes.attribute\n      parseAttribute()\n      continue\n    }\n\n    tokenA += character\n  }\n\n  return [type, attributes]\n}\n", "\nimport {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport type Fctory = (\n  attributes?: string,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FctoryCache = {\n  [key: string]: Fctory,\n}\n\nexport const fctory = new Proxy({}, {\n  get: (\n    target: FctoryCache,\n    type: string,\n  ): Fctory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      selector?: string,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => {\n      let attributes: NodeAttributes | undefined\n      if (selector) {\n        const [_, _attributes] = selectorToTokenizer(selector)\n        attributes = _attributes\n      }\n      return node(\n        typeConverted,\n        attributes,\n        contents,\n      )\n    }\n  },\n})\n", "let identifierCount = 0\nexport const uniqueIdentifier = (\n): string => '-' + (identifierCount++)\n", "import {\n  marker,\n} from './marker.js'\nimport { NodeContent } from './node.js'\n\nexport type MemoFunction = (\n  state: Record<string, any>,\n  memory: any,\n) => NodeContent[] | NodeContent\n\nexport type MemoAbstract = {\n  _: Symbol,\n  // Compare data\n  m: any,\n  // Render function\n  r: MemoFunction,\n}\n\nexport const memo = (\n  render: MemoFunction,\n  memory: any,\n) => ({\n  _: marker,\n  r: render,\n  m: memory,\n})\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  NodeAbstract,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport const nde = (\n  selector: string,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  const [type, attributes] = selectorToTokenizer(selector)\n  return {\n    _: marker,\n    a: attributes,\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  marker\n} from './marker.js'\n\nexport type TextAbstract = {\n  _: Symbol,\n  // Contents\n  c: string\n}\n\nexport const text = (\n  contents: number | string | (number | string)[],\n): TextAbstract => ({\n  _: marker,\n  c: (\n    Array.isArray(contents)\n      ? contents.join('')\n      : ('' + contents)\n  ),\n})\n", "import {\n  node as n,\n  NodeAbstract,\n  NodeAttributeListener,\n  NodeAttributes,\n  suffixNameIfMultiple,\n  uniqueIdentifier,\n} from '@doars/staark-common'\n\nconst COMPONENT_CLASS = ' staark-component-input'\n\nexport enum InputFieldTypes {\n  checkbox = 'checkbox',\n  color = 'color',\n  date = 'date',\n  datetimeLocal = 'datetime-local',\n  email = 'email',\n  file = 'file',\n  month = 'month',\n  number = 'number',\n  password = 'password',\n  radio = 'radio',\n  range = 'range',\n  search = 'search',\n  tel = 'tel',\n  text = 'text',\n  time = 'time',\n  url = 'url',\n  week = 'week',\n}\n\nexport type InputAttributes = {\n  autocomplete?: string,\n  accepts?: string,\n  checked?: boolean,\n  class?: string | string[],\n  id?: string,\n  max?: number,\n  maxlength?: number,\n  min?: number,\n  minlength?: number,\n  multiple?: boolean,\n  name?: string,\n  placeholder?: string,\n  readonly?: boolean,\n  step?: number,\n  tabindex?: number,\n  type?: InputFieldTypes,\n  value?: string,\n\n  change?: NodeAttributeListener,\n  click?: NodeAttributeListener,\n  focus?: NodeAttributeListener,\n  keydown?: NodeAttributeListener,\n  keyup?: NodeAttributeListener,\n}\n\nexport type LabelOptions = {\n  label: string,\n  append?: boolean,\n}\n\nexport const inputField = (\n  state: Record<string, any>,\n  attributes: InputAttributes,\n  label?: string | LabelOptions,\n): NodeAbstract[] => {\n  state = Object.assign({\n    value: attributes.value || '',\n  }, state)\n\n  attributes.class = (attributes.class || '') + COMPONENT_CLASS\n  if (!attributes.type) {\n    attributes.type = InputFieldTypes.text\n  }\n  attributes.value = state.value\n  suffixNameIfMultiple(attributes)\n\n  const onChange = attributes.change\n  attributes.change = (\n    event: Event,\n  ) => {\n    // TODO: What about the checkboxes and radio types.\n    // TODO: What about the file type.\n    state.value = (event.target as HTMLDataElement).value\n    if (onChange) {\n      onChange(event)\n    }\n  }\n\n  if (typeof (label) === 'string') {\n    label = {\n      label: label,\n    }\n  }\n\n  if (\n    label\n    && !label.append\n    && (\n      attributes.type === InputFieldTypes.checkbox\n      || attributes.type === InputFieldTypes.radio\n    )\n  ) {\n    label.append = true\n  }\n\n  const contents: NodeAbstract[] = [\n    n('input', attributes),\n  ]\n\n  if (label) {\n    if (!attributes.id) {\n      attributes.id = 'auto-id' + uniqueIdentifier()\n    }\n\n    const labelAttributes: NodeAttributes = {\n      for: attributes.id,\n    }\n    if (\n      attributes.type === InputFieldTypes.checkbox\n      || attributes.type === InputFieldTypes.radio\n    ) {\n      labelAttributes.tabindex = 0\n      labelAttributes.click = (\n        event: Event,\n      ): void => {\n        (\n          (event.target as HTMLElement)\n            .previousSibling as HTMLElement\n        ).focus()\n      }\n    }\n    const labelAbstract: NodeAbstract = n(\n      'label',\n      labelAttributes,\n      label.label,\n    )\n\n    if (\n      label\n      && label.append\n    ) {\n      contents.push(labelAbstract)\n    } else {\n      contents.unshift(labelAbstract)\n    }\n  }\n\n  return contents\n}\n", "import {\n  node as n,\n  NodeAbstract,\n} from '@doars/staark/src/index.js'\nimport {\n  inputField,\n  InputAttributes,\n  InputFieldTypes,\n} from './inputField.js'\n\nexport type InputListItem = {\n  id?: string,\n  label?: string,\n  value: string,\n  search: string, // TODO: Search this as well as the label/value.\n}\n\nexport type InputListOptions = {\n  class?: string,\n  id?: string,\n  legend?: string,\n  multiple?: boolean,\n  name: string,\n\n  selectAllLabel?: string,\n  selected?: string[],\n  selectedChange?: (argument: string[]) => unknown,\n  selectNoneLabel?: string,\n\n  preview: boolean,\n  previewLabel?: string,\n  previewPlaceholder?: string,\n\n  search: boolean | number,\n  searchChange?: (argument: string) => unknown,\n  searchLabel?: string,\n  searchPlaceholder?: string,\n  searchResetLabel?: string,\n  searchValue?: string,\n}\n\n// TODO: If the user has clicked on the input and starts typing, it should automatically enter into the search bar.\n// TODO: The searching should still show all items, just hide the irrelivent ones.\n// TODO: Add a select all or deselect all option.\n\nexport const inputList = (\n  state: Record<string, any>,\n  options: InputListOptions,\n  items: InputListItem[],\n): NodeAbstract => {\n  // Prefill the state.\n  state = Object.assign({\n    query: options.searchValue,\n    selected: options.selected ? [...options.selected] : [],\n  }, state)\n\n  let contents: NodeAbstract[] = []\n\n  // Setup items.\n  const inputOptions: InputAttributes = {\n    appendLabel: true,\n    multiple: options.multiple,\n    name: options.name,\n    type: options.multiple ? InputFieldTypes.checkbox : InputFieldTypes.radio,\n\n    change: (\n      event: Event,\n    ): void => {\n      // Keep the focus on the input element.\n      // @ts-ignore\n      (event as UIEvent).target.focus()\n\n      const target: HTMLInputElement = event.target as HTMLInputElement\n      if (!target.checked) {\n        const index = state.selected.indexOf(target.value)\n        if (index >= 0) {\n          state.selected.splice(index, 1)\n        }\n      } else if (options.multiple) {\n        if (state.selected.indexOf(target.value) < 0) {\n          state.selected.push(target.value)\n        }\n      } else {\n        state.selected = [target.value]\n      }\n\n      if (options.selectedChange) {\n        options.selectedChange([...state.selected])\n      }\n    },\n  }\n  for (let i = 0; i < items.length; i++) {\n    const item: InputListItem = items[i]\n    // Check if item matches query.\n    if (state.query && (\n      (item.label && item.label.indexOf(state.query) < 0) ||\n      item.value.indexOf(state.query) < 0\n    )) {\n      continue\n    }\n\n    const itemOptions: InputAttributes = {\n      ...inputOptions,\n      value: item.value,\n    }\n    if (state.selected.indexOf(item.value) >= 0) {\n      itemOptions.checked = true\n    }\n    if (item.id) {\n      itemOptions.id = item.id\n    }\n    contents.push(\n      ...inputField(\n        itemOptions,\n        item.label ?? item.value, // TODO: When the label is clicked put the focus on the input element.\n      ),\n    )\n  }\n\n  if (options.selectNoneLabel && state.selected.length > 0) {\n    contents.unshift(\n      n('button', {\n        click: (\n        ): void => {\n          state.selected = []\n\n          if (options.selectedChange) {\n            options.selectedChange([...state.selected])\n          }\n        },\n        type: 'button',\n      }, options.selectNoneLabel),\n    )\n  }\n\n  if (options.selectAllLabel && state.selected.length !== items.length) {\n    contents.unshift(\n      n('button', {\n        click: (\n        ): void => {\n          // Create list of all values.\n          const selected: string[] = []\n          for (const item of items) {\n            state.selected.push(item.value)\n          }\n          state.selected = selected\n\n          if (options.selectedChange) {\n            options.selectedChange(selected)\n          }\n        },\n        type: 'button',\n      }, options.selectAllLabel),\n    )\n  }\n\n  // Setup search input.\n  if (options.search && (\n    typeof (options.search) === 'boolean' ||\n    items.length >= options.search\n  )) {\n    if (state.query) {\n      contents.unshift(\n        n('button', {\n          click: (\n            event: Event,\n          ): void => {\n            // Set focus to search field.\n            // @ts-ignore\n            (event as UIEvent).target.previousSibling.focus()\n\n            state.query = null\n\n            if (options.searchChange) {\n              options.searchChange(state.query)\n            }\n          },\n          type: 'button',\n        }, options.searchResetLabel ?? '\u00D7'),\n      )\n    }\n\n    const searchOptions: InputAttributes = {\n      type: InputFieldTypes.search,\n      value: state.query,\n\n      keyup: (\n        event: Event,\n      ): void => {\n        // @ts-ignore.\n        state.query = event.target.value\n\n        if (options.searchChange) {\n          options.searchChange(state.query)\n        }\n      },\n    }\n    if (options.searchPlaceholder) {\n      searchOptions.placeholder = options.searchPlaceholder\n    }\n\n    contents.unshift(\n      ...inputField(searchOptions, options.searchLabel),\n    )\n  }\n\n  contents = [\n    n('div', {}, contents),\n  ]\n\n  if (options.preview) {\n    const previewOptions: InputAttributes = {\n      readonly: true,\n      tabindex: -1,\n      type: InputFieldTypes.text,\n    }\n\n    const labels: string[] = []\n    for (const item of items) {\n      if (state.selected.indexOf(item.value) >= 0) {\n        labels.push(item.label ?? item.value)\n      }\n    }\n    previewOptions.value = labels.join(', ')\n\n    contents.unshift(\n      ...inputField(previewOptions, options.previewLabel),\n    )\n  }\n\n  if (options.legend) {\n    contents.unshift(\n      n('legend', {\n        click: (\n          event: Event,\n        ): void => {\n          // @ts-ignore\n          event.target.parentNode.focus()\n        },\n      }, options.legend),\n    )\n  }\n\n  const fieldAttributes: { [key: string]: any } = {\n    tabindex: 0,\n  }\n  if (options.class) {\n    fieldAttributes.class = options.class\n  }\n  return n('fieldset', fieldAttributes, contents)\n}\n", "import { iife } from '../../../.scripts/iife.js'\n\n// import { inputFile } from './scripts/inputFile.js'\nimport { inputList } from './scripts/inputList.js'\n\niife([\n  'staark',\n  'components',\n], {\n  // inputFile,\n  inputList,\n})\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,OAAO,SAClB,MACA,MACA;AACA,QAAI,UAA+B;AACnC,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACxC,UACE,OAAQ,QAAQ,KAAK,CAAC,CAAC,MAAO,YAC3B,CAAC,MAAM,QAAQ,QAAQ,KAAK,CAAC,CAAC,CAAC,GAClC;AACA,gBAAQ,KAAK,CAAC,CAAC,IAAI,CAAC;AAAA,MACtB;AACA,gBAAU,QAAQ,KAAK,CAAC,CAAC;AAAA,IAC3B;AACA,YAAQ,KAAK,KAAK,SAAS,CAAC,CAAC,IAAI;AAAA,EACnC;;;ACfO,MAAM,SAAS,OAAO;;;AC2CtB,MAAM,OAAO,CAClB,MACA,sBACA,aACiB;AACjB,QACE,OAAQ,yBAA0B,YAC9B,qBAAsC,MAAM,UAC7C,MAAM,QAAQ,oBAAoB,GACrC;AACA,iBAAW;AACX,6BAAuB;AAAA,IACzB;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GACE,WACI,MAAM,QAAQ,QAAQ,IACpB,WACA,CAAC,QAAQ,IACX,CAAC;AAAA,MAEP,GAAG,KAAK,YAAY;AAAA,IACtB;AAAA,EACF;;;ACrDO,MAAM,UAAU,IAAI,MAAM,CAAC,GAAG;AAAA,IACnC,KAAK,CACH,QACA,SACY;AACZ,UAAI,OAAO,IAAI,GAAG;AAChB,eAAO,OAAO,IAAI;AAAA,MACpB;AAEA,YAAM,iBACJ,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,EACvB;AAAA,QACC;AAAA,QACA,aAAW,MAAM;AAAA,MACnB,GACF,YAAY;AAEd,aAAO,OAAO,IAAI,IAAI,CACpB,sBACA,aACiB;AAAA,QACjB;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;;;AC1CD,MAAM,gBAAgB;AACtB,MAAM,eAAe;AACrB,MAAM,MAAM;AACZ,MAAM,QAAQ;AACd,MAAM,OAAO;AACb,MAAM,eAAe;AACrB,MAAM,eAAe;AASd,MAAM,sBAAsB,CACjC,aACkC;AAClC,UAAM,SAAiB,SAAS;AAChC,QAAI,IAAY;AAEhB,QAAI,OAAe;AACnB,UAAM,aAAkC,CAAC;AAEzC,QAAI,SAAiB;AACrB,QAAI,SAAwB;AAC5B,QAAI,YAAwB;AAC5B,UAAM,aAAa,MAAM;AACvB,UAAI,QAAQ;AACV,gBAAQ,WAAW;AAAA,UACjB,KAAK;AACH,uBAAW,MAAM,IAAI,WAAW,OAAO,OAAO;AAC9C,qBAAS;AACT;AAAA,UAEF,KAAK;AACH,gBAAI,CAAC,WAAW,OAAO;AACrB,yBAAW,QAAQ;AACnB;AAAA,YACF;AACA,uBAAW,SAAS,MAAM;AAC1B;AAAA,UAEF,KAAK;AACH,uBAAW,KAAK;AAChB;AAAA,UAEF,KAAK;AACH,mBAAO;AACP;AAAA,QACJ;AACA,iBAAS;AAAA,MACX;AAAA,IACF;AAEA,QAAI;AAEJ,QAAI;AACJ,UAAM,iBAAiB,MACZ;AACT,8BAAwB;AAExB,aAAO,IAAI,QAAQ;AACjB,oBAAY,SAAS,CAAC;AACtB;AACA,YAAI,cAAc,OAAO;AAEvB,mBAAS;AACT,sBAAY,SAAS,CAAC;AACtB,gBAAM,mBAAmB,cAAc;AACvC,gBAAM,mBAAmB,cAAc;AACvC,cAAI,oBAAoB,kBAAkB;AACxC,sBAAU;AACV;AAAA,UACF;AAEA,iBAAO,IAAI,QAAQ;AACjB,wBAAY,SAAS,CAAC;AACtB,gBACG,oBAAoB,cAAc,gBAClC,oBAAoB,cAAc,cACnC;AACA,wBAAU;AACV;AACA;AAAA,YACF,WACE,CAAC,oBACD,CAAC,oBACD,cAAc,eACd;AACA;AAAA,YACF;AACA,sBAAU;AACV;AAAA,UACF;AAEA,cAEI,OAAO,CAAC,MAAM,gBACd,OAAO,OAAO,SAAS,CAAC,MAAM,gBAG9B,OAAO,CAAC,MAAM,gBACd,OAAO,OAAO,SAAS,CAAC,MAAM,cAEhC;AACA,qBAAS,OAAO,UAAU,GAAG,OAAO,SAAS,CAAC;AAAA,UAChD;AAIA,iBAAO,IAAI,QAAQ;AACjB,wBAAY,SAAS,CAAC;AACtB;AACA,gBAAI,cAAc,eAAe;AAC/B;AAAA,YACF;AAAA,UACF;AACA;AAAA,QACF,WAAW,cAAc,cAAc;AACrC;AACA;AAAA,QACF,WAAW,cAAc,eAAe;AACtC;AACA,cAAI,wBAAwB,GAAG;AAC7B;AAAA,UACF;AACA;AAAA,QACF;AAEA,kBAAU;AAAA,MACZ;AACA,iBAAW;AAAA,IACb;AAEA,WAAO,IAAI,QAAQ;AACjB,kBAAY,SAAS,CAAC;AACtB;AAEA,UAAI,cAAc,MAAM;AACtB,mBAAW;AACX,oBAAY;AACZ;AAAA,MACF,WAAW,cAAc,KAAK;AAC5B,mBAAW;AACX,oBAAY;AACZ;AAAA,MACF,WAAW,cAAc,cAAc;AACrC,mBAAW;AACX,oBAAY;AACZ,uBAAe;AACf;AAAA,MACF;AAEA,gBAAU;AAAA,IACZ;AAEA,WAAO,CAAC,MAAM,UAAU;AAAA,EAC1B;;;AC1IO,MAAM,SAAS,IAAI,MAAM,CAAC,GAAG;AAAA,IAClC,KAAK,CACH,QACA,SACW;AACX,UAAI,OAAO,IAAI,GAAG;AAChB,eAAO,OAAO,IAAI;AAAA,MACpB;AAEA,YAAM,iBACJ,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,EACvB;AAAA,QACC;AAAA,QACA,aAAW,MAAM;AAAA,MACnB,GACF,YAAY;AAEd,aAAO,OAAO,IAAI,IAAI,CACpB,UACA,aACiB;AACjB,YAAI;AACJ,YAAI,UAAU;AACZ,gBAAM,CAAC,GAAG,WAAW,IAAI,oBAAoB,QAAQ;AACrD,uBAAa;AAAA,QACf;AACA,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;;;AErDD,MAAM,kBAA0B;AAOzB,MAAM,uBAAuB,CAClC,eACG;AACH,QACE,WAAW,YACR,WAAW,QACX,CAAC,WAAW,KAAK,SAAS,eAAe,GAC5C;AACA,iBAAW,QAAQ;IACrB;EACF;AIjBO,MAAMA,UAAS,OAAO;AC2CtB,MAAMC,QAAO,CAClB,MACA,sBACA,aACiB;AACjB,QACE,OAAQ,yBAA0B,YAC9B,qBAAsC,MAAMD,WAC7C,MAAM,QAAQ,oBAAoB,GACrC;AACA,iBAAW;AACX,6BAAuB;IACzB;AAEA,WAAO;MACL,GAAGA;MACH,GAAG;MACH,GACE,WACI,MAAM,QAAQ,QAAQ,IACpB,WACA,CAAC,QAAQ,IACX,CAAC;MAEP,GAAG,KAAK,YAAY;IACtB;EACF;AErDO,MAAME,WAAU,IAAI,MAAM,CAAC,GAAG;IACnC,KAAK,CACH,QACA,SACY;AACZ,UAAI,OAAO,IAAI,GAAG;AAChB,eAAO,OAAO,IAAI;MACpB;AAEA,YAAM,iBACJ,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,EACvB;QACC;QACA,CAAA,YAAW,MAAM;MACnB,GACF,YAAY;AAEd,aAAO,OAAO,IAAI,IAAI,CACpB,sBACA,aACiBC;QACjB;QACA;QACA;MACF;IACF;EACF,CAAC;AC1CD,MAAMC,iBAAgB;AACtB,MAAMC,gBAAe;AACrB,MAAMC,OAAM;AACZ,MAAMC,SAAQ;AACd,MAAMC,QAAO;AACb,MAAMC,gBAAe;AACrB,MAAMC,gBAAe;AASd,MAAMC,uBAAsB,CACjC,aACkC;AAClC,UAAM,SAAiB,SAAS;AAChC,QAAI,IAAY;AAEhB,QAAI,OAAe;AACnB,UAAM,aAAkC,CAAC;AAEzC,QAAI,SAAiB;AACrB,QAAI,SAAwB;AAC5B,QAAI,YAAwB;AAC5B,UAAM,aAAa,MAAM;AACvB,UAAI,QAAQ;AACV,gBAAQ,WAAW;UACjB,KAAK;AACH,uBAAW,MAAM,IAAI,WAAW,OAAO,OAAO;AAC9C,qBAAS;AACT;UAEF,KAAK;AACH,gBAAI,CAAC,WAAW,OAAO;AACrB,yBAAW,QAAQ;AACnB;YACF;AACA,uBAAW,SAAS,MAAM;AAC1B;UAEF,KAAK;AACH,uBAAW,KAAK;AAChB;UAEF,KAAK;AACH,mBAAO;AACP;QACJ;AACA,iBAAS;MACX;IACF;AAEA,QAAI;AAEJ,QAAI;AACJ,UAAM,iBAAiB,MACZ;AACT,8BAAwB;AAExB,aAAO,IAAI,QAAQ;AACjB,oBAAY,SAAS,CAAC;AACtB;AACA,YAAI,cAAcJ,QAAO;AAEvB,mBAAS;AACT,sBAAY,SAAS,CAAC;AACtB,gBAAM,mBAAmB,cAAcG;AACvC,gBAAM,mBAAmB,cAAcD;AACvC,cAAI,oBAAoB,kBAAkB;AACxC,sBAAU;AACV;UACF;AAEA,iBAAO,IAAI,QAAQ;AACjB,wBAAY,SAAS,CAAC;AACtB,gBACG,oBAAoB,cAAcC,iBAClC,oBAAoB,cAAcD,eACnC;AACA,wBAAU;AACV;AACA;YACF,WACE,CAAC,oBACD,CAAC,oBACD,cAAcL,gBACd;AACA;YACF;AACA,sBAAU;AACV;UACF;AAEA,cAEI,OAAO,CAAC,MAAMM,iBACd,OAAO,OAAO,SAAS,CAAC,MAAMA,iBAG9B,OAAO,CAAC,MAAMD,iBACd,OAAO,OAAO,SAAS,CAAC,MAAMA,eAEhC;AACA,qBAAS,OAAO,UAAU,GAAG,OAAO,SAAS,CAAC;UAChD;AAIA,iBAAO,IAAI,QAAQ;AACjB,wBAAY,SAAS,CAAC;AACtB;AACA,gBAAI,cAAcL,gBAAe;AAC/B;YACF;UACF;AACA;QACF,WAAW,cAAcC,eAAc;AACrC;AACA;QACF,WAAW,cAAcD,gBAAe;AACtC;AACA,cAAI,wBAAwB,GAAG;AAC7B;UACF;AACA;QACF;AAEA,kBAAU;MACZ;AACA,iBAAW;IACb;AAEA,WAAO,IAAI,QAAQ;AACjB,kBAAY,SAAS,CAAC;AACtB;AAEA,UAAI,cAAcI,OAAM;AACtB,mBAAW;AACX,oBAAY;AACZ;MACF,WAAW,cAAcF,MAAK;AAC5B,mBAAW;AACX,oBAAY;AACZ;MACF,WAAW,cAAcD,eAAc;AACrC,mBAAW;AACX,oBAAY;AACZ,uBAAe;AACf;MACF;AAEA,gBAAU;IACZ;AAEA,WAAO,CAAC,MAAM,UAAU;EAC1B;AC1IO,MAAMO,UAAS,IAAI,MAAM,CAAC,GAAG;IAClC,KAAK,CACH,QACA,SACW;AACX,UAAI,OAAO,IAAI,GAAG;AAChB,eAAO,OAAO,IAAI;MACpB;AAEA,YAAM,iBACJ,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,EACvB;QACC;QACA,CAAA,YAAW,MAAM;MACnB,GACF,YAAY;AAEd,aAAO,OAAO,IAAI,IAAI,CACpB,UACA,aACiB;AACjB,YAAI;AACJ,YAAI,UAAU;AACZ,gBAAM,CAAC,GAAG,WAAW,IAAID,qBAAoB,QAAQ;AACrD,uBAAa;QACf;AACA,eAAOR;UACL;UACA;UACA;QACF;MACF;IACF;EACF,CAAC;ACrDD,MAAI,kBAAkB;AACf,MAAM,mBAAmB,MACnB,MAAO;;;AIOpB,MAAM,kBAAkB;AAqDjB,MAAM,aAAa,CACxB,OACA,YACA,UACmB;AACnB,YAAQ,OAAO,OAAO;AAAA,MACpB,OAAO,WAAW,SAAS;AAAA,IAC7B,GAAG,KAAK;AAER,eAAW,SAAS,WAAW,SAAS,MAAM;AAC9C,QAAI,CAAC,WAAW,MAAM;AACpB,iBAAW,OAAO;AAAA,IACpB;AACA,eAAW,QAAQ,MAAM;AACzB,yBAAqB,UAAU;AAE/B,UAAM,WAAW,WAAW;AAC5B,eAAW,SAAS,CAClB,UACG;AAGH,YAAM,QAAS,MAAM,OAA2B;AAChD,UAAI,UAAU;AACZ,iBAAS,KAAK;AAAA,MAChB;AAAA,IACF;AAEA,QAAI,OAAQ,UAAW,UAAU;AAC/B,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAEA,QACE,SACG,CAAC,MAAM,WAER,WAAW,SAAS,6BACjB,WAAW,SAAS,sBAEzB;AACA,YAAM,SAAS;AAAA,IACjB;AAEA,UAAM,WAA2B;AAAA,MAC/BU,MAAE,SAAS,UAAU;AAAA,IACvB;AAEA,QAAI,OAAO;AACT,UAAI,CAAC,WAAW,IAAI;AAClB,mBAAW,KAAK,YAAY,iBAAiB;AAAA,MAC/C;AAEA,YAAM,kBAAkC;AAAA,QACtC,KAAK,WAAW;AAAA,MAClB;AACA,UACE,WAAW,SAAS,6BACjB,WAAW,SAAS,qBACvB;AACA,wBAAgB,WAAW;AAC3B,wBAAgB,QAAQ,CACtB,UACS;AACT,UACG,MAAM,OACJ,gBACH,MAAM;AAAA,QACV;AAAA,MACF;AACA,YAAM,gBAA8BA;AAAA,QAClC;AAAA,QACA;AAAA,QACA,MAAM;AAAA,MACR;AAEA,UACE,SACG,MAAM,QACT;AACA,iBAAS,KAAK,aAAa;AAAA,MAC7B,OAAO;AACL,iBAAS,QAAQ,aAAa;AAAA,MAChC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;;;ACzGO,MAAM,YAAY,CACvB,OACA,SACA,UACiB;AAjDnB;AAmDE,YAAQ,OAAO,OAAO;AAAA,MACpB,OAAO,QAAQ;AAAA,MACf,UAAU,QAAQ,WAAW,CAAC,GAAG,QAAQ,QAAQ,IAAI,CAAC;AAAA,IACxD,GAAG,KAAK;AAER,QAAI,WAA2B,CAAC;AAGhC,UAAM,eAAgC;AAAA,MACpC,aAAa;AAAA,MACb,UAAU,QAAQ;AAAA,MAClB,MAAM,QAAQ;AAAA,MACd,MAAM,QAAQ;AAAA,MAEd,QAAQ,CACN,UACS;AAGT,QAAC,MAAkB,OAAO,MAAM;AAEhC,cAAM,SAA2B,MAAM;AACvC,YAAI,CAAC,OAAO,SAAS;AACnB,gBAAM,QAAQ,MAAM,SAAS,QAAQ,OAAO,KAAK;AACjD,cAAI,SAAS,GAAG;AACd,kBAAM,SAAS,OAAO,OAAO,CAAC;AAAA,UAChC;AAAA,QACF,WAAW,QAAQ,UAAU;AAC3B,cAAI,MAAM,SAAS,QAAQ,OAAO,KAAK,IAAI,GAAG;AAC5C,kBAAM,SAAS,KAAK,OAAO,KAAK;AAAA,UAClC;AAAA,QACF,OAAO;AACL,gBAAM,WAAW,CAAC,OAAO,KAAK;AAAA,QAChC;AAEA,YAAI,QAAQ,gBAAgB;AAC1B,kBAAQ,eAAe,CAAC,GAAG,MAAM,QAAQ,CAAC;AAAA,QAC5C;AAAA,MACF;AAAA,IACF;AACA,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAsB,MAAM,CAAC;AAEnC,UAAI,MAAM,UACP,KAAK,SAAS,KAAK,MAAM,QAAQ,MAAM,KAAK,IAAI,KACjD,KAAK,MAAM,QAAQ,MAAM,KAAK,IAAI,IACjC;AACD;AAAA,MACF;AAEA,YAAM,cAA+B,iCAChC,eADgC;AAAA,QAEnC,OAAO,KAAK;AAAA,MACd;AACA,UAAI,MAAM,SAAS,QAAQ,KAAK,KAAK,KAAK,GAAG;AAC3C,oBAAY,UAAU;AAAA,MACxB;AACA,UAAI,KAAK,IAAI;AACX,oBAAY,KAAK,KAAK;AAAA,MACxB;AACA,eAAS;AAAA,QACP,GAAG;AAAA,UACD;AAAA,WACA,UAAK,UAAL,YAAc,KAAK;AAAA;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAEA,QAAI,QAAQ,mBAAmB,MAAM,SAAS,SAAS,GAAG;AACxD,eAAS;AAAA,QACP,KAAE,UAAU;AAAA,UACV,OAAO,MACI;AACT,kBAAM,WAAW,CAAC;AAElB,gBAAI,QAAQ,gBAAgB;AAC1B,sBAAQ,eAAe,CAAC,GAAG,MAAM,QAAQ,CAAC;AAAA,YAC5C;AAAA,UACF;AAAA,UACA,MAAM;AAAA,QACR,GAAG,QAAQ,eAAe;AAAA,MAC5B;AAAA,IACF;AAEA,QAAI,QAAQ,kBAAkB,MAAM,SAAS,WAAW,MAAM,QAAQ;AACpE,eAAS;AAAA,QACP,KAAE,UAAU;AAAA,UACV,OAAO,MACI;AAET,kBAAM,WAAqB,CAAC;AAC5B,uBAAW,QAAQ,OAAO;AACxB,oBAAM,SAAS,KAAK,KAAK,KAAK;AAAA,YAChC;AACA,kBAAM,WAAW;AAEjB,gBAAI,QAAQ,gBAAgB;AAC1B,sBAAQ,eAAe,QAAQ;AAAA,YACjC;AAAA,UACF;AAAA,UACA,MAAM;AAAA,QACR,GAAG,QAAQ,cAAc;AAAA,MAC3B;AAAA,IACF;AAGA,QAAI,QAAQ,WACV,OAAQ,QAAQ,WAAY,aAC5B,MAAM,UAAU,QAAQ,SACvB;AACD,UAAI,MAAM,OAAO;AACf,iBAAS;AAAA,UACP,KAAE,UAAU;AAAA,YACV,OAAO,CACL,UACS;AAGT,cAAC,MAAkB,OAAO,gBAAgB,MAAM;AAEhD,oBAAM,QAAQ;AAEd,kBAAI,QAAQ,cAAc;AACxB,wBAAQ,aAAa,MAAM,KAAK;AAAA,cAClC;AAAA,YACF;AAAA,YACA,MAAM;AAAA,UACR,IAAG,aAAQ,qBAAR,YAA4B,MAAG;AAAA,QACpC;AAAA,MACF;AAEA,YAAM,gBAAiC;AAAA,QACrC;AAAA,QACA,OAAO,MAAM;AAAA,QAEb,OAAO,CACL,UACS;AAET,gBAAM,QAAQ,MAAM,OAAO;AAE3B,cAAI,QAAQ,cAAc;AACxB,oBAAQ,aAAa,MAAM,KAAK;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AACA,UAAI,QAAQ,mBAAmB;AAC7B,sBAAc,cAAc,QAAQ;AAAA,MACtC;AAEA,eAAS;AAAA,QACP,GAAG,WAAW,eAAe,QAAQ,WAAW;AAAA,MAClD;AAAA,IACF;AAEA,eAAW;AAAA,MACT,KAAE,OAAO,CAAC,GAAG,QAAQ;AAAA,IACvB;AAEA,QAAI,QAAQ,SAAS;AACnB,YAAM,iBAAkC;AAAA,QACtC,UAAU;AAAA,QACV,UAAU;AAAA,QACV;AAAA,MACF;AAEA,YAAM,SAAmB,CAAC;AAC1B,iBAAW,QAAQ,OAAO;AACxB,YAAI,MAAM,SAAS,QAAQ,KAAK,KAAK,KAAK,GAAG;AAC3C,iBAAO,MAAK,UAAK,UAAL,YAAc,KAAK,KAAK;AAAA,QACtC;AAAA,MACF;AACA,qBAAe,QAAQ,OAAO,KAAK,IAAI;AAEvC,eAAS;AAAA,QACP,GAAG,WAAW,gBAAgB,QAAQ,YAAY;AAAA,MACpD;AAAA,IACF;AAEA,QAAI,QAAQ,QAAQ;AAClB,eAAS;AAAA,QACP,KAAE,UAAU;AAAA,UACV,OAAO,CACL,UACS;AAET,kBAAM,OAAO,WAAW,MAAM;AAAA,UAChC;AAAA,QACF,GAAG,QAAQ,MAAM;AAAA,MACnB;AAAA,IACF;AAEA,UAAM,kBAA0C;AAAA,MAC9C,UAAU;AAAA,IACZ;AACA,QAAI,QAAQ,OAAO;AACjB,sBAAgB,QAAQ,QAAQ;AAAA,IAClC;AACA,WAAO,KAAE,YAAY,iBAAiB,QAAQ;AAAA,EAChD;;;ACrPA,OAAK;AAAA,IACH;AAAA,IACA;AAAA,EACF,GAAG;AAAA;AAAA,IAED;AAAA,EACF,CAAC;",
  "names": ["marker", "node", "factory", "node", "BRACKET_CLOSE", "BRACKET_OPEN", "DOT", "EQUAL", "HASH", "QUOTE_SINGLE", "QUOTE_DOUBLE", "selectorToTokenizer", "fctory", "node"]
}
