{
  "version": 3,
  "sources": ["../../staark-common/src/array.ts", "../../staark-common/src/attribute.ts", "../../staark-common/src/clone.ts", "../../staark-common/src/compare.ts", "../../staark-common/src/conditional.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/element.ts", "../../staark-common/src/factory.ts", "../../staark-common/src/selector.ts", "../../staark-common/src/fctory.ts", "../../staark-common/src/identifier.ts", "../../staark-common/src/memo.ts", "../../staark-common/src/nde.ts", "../../staark-common/src/text.ts", "../src/scripts/inputField.ts", "../src/scripts/inputFile.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/factory.ts", "../../staark-common/src/selector.ts", "../../staark-common/src/fctory.ts", "../src/scripts/inputList.ts", "../src/scripts/router.ts"],
  "sourcesContent": ["export const arrayify = function <T>(\n  data: T[] | T,\n): T[] {\n  if (Array.isArray(data)) {\n    return data\n  }\n  return [\n    data,\n  ]\n}\n", "const SUFFIX_MULTIPLE: string = '[]'\n\nexport type MultipleAttributes = {\n  multiple?: boolean,\n  name?: string,\n}\n\nexport const suffixNameIfMultiple = (\n  attributes: MultipleAttributes,\n) => {\n  if (\n    attributes.multiple\n    && attributes.name\n    && !attributes.name.endsWith(SUFFIX_MULTIPLE)\n  ) {\n    attributes.name += SUFFIX_MULTIPLE\n  }\n}\n", "export const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const equalRecursive = (\n  valueA: any,\n  valueB: any,\n): boolean => {\n  if (valueA === valueB) {\n    return true\n  }\n  if (\n    valueA instanceof Date\n    && valueB instanceof Date\n  ) {\n    return valueA.getTime() === valueB.getTime()\n  }\n  if (\n    !valueA\n    || !valueB\n    || (\n      typeof valueA !== 'object' && typeof valueB !== 'object'\n    )\n  ) {\n    return valueA === valueB\n  }\n  if (\n    valueA === null\n    || valueA === undefined\n    || valueB === null\n    || valueB === undefined\n  ) {\n    return false\n  }\n  if (valueA.prototype !== valueB.prototype) {\n    return false\n  }\n  let keys = Object.keys(valueA)\n  if (keys.length !== Object.keys(valueB).length) {\n    return false\n  }\n  return keys.every(\n    (key: string): boolean => equalRecursive(valueA[key], valueB[key]),\n  )\n}\n", "import { arrayify } from './array.js'\nimport { NodeAbstract } from './node.js'\n\nexport const conditional = (\n  condition: any,\n  onTruth: NodeAbstract[] | NodeAbstract,\n  onFalse?: NodeAbstract[] | NodeAbstract,\n): NodeAbstract[] => {\n  if (condition) {\n    return arrayify(onTruth)\n  }\n  return arrayify(onFalse ?? [])\n}\n", "export const marker = Symbol()\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\nimport {\n  TextAbstract,\n} from './text.js'\n\nexport type NodeAttributeListener = (\n  event: Event\n) => unknown\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract |\n  TextAbstract\n\nexport type NodeAbstract = {\n  _: Symbol\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport const childrenToNodes = (\n  element: Element | ChildNode,\n) => {\n  const abstractChildNodes: NodeContent[] = []\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const childNode = element.childNodes[i]\n    if (childNode instanceof Text) {\n      abstractChildNodes.push(\n        childNode.textContent ?? ''\n      )\n    } else {\n      let attributes: NodeAttributes = {}\n      for (let i = 0; i < (childNode as Element).attributes.length; i++) {\n        const attribute = (childNode as Element).attributes[i]\n        attributes[attribute.name] = attribute.value\n      }\n\n      abstractChildNodes.push(\n        node(\n          childNode.nodeName,\n          attributes,\n          childrenToNodes(childNode),\n        )\n      )\n    }\n  }\n  return abstractChildNodes\n}\n", "import {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport type Factory = (\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FactoryCache = {\n  [key: string]: Factory,\n}\n\nexport const factory = new Proxy({}, {\n  get: (\n    target: FactoryCache,\n    type: string,\n  ): Factory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => node(\n      typeConverted,\n      attributesOrContents,\n      contents,\n    )\n  },\n})\n", "const BRACKET_CLOSE = ']'\nconst BRACKET_OPEN = '['\nconst DOT = '.'\nconst EQUAL = '='\nconst HASH = '#'\nconst QUOTE_SINGLE = '\\''\nconst QUOTE_DOUBLE = '\"'\n\nenum TokenTypes {\n  attribute = 0,\n  class = 1,\n  id = 2,\n  type = 3,\n}\n\nexport const selectorToTokenizer = (\n  selector: string,\n): [string, Record<string, any>] => {\n  const length: number = selector.length\n  let i: number = 0\n\n  let type: string = ''\n  const attributes: Record<string, any> = {}\n\n  let tokenA: string = ''\n  let tokenB: string | true = true\n  let tokenType: TokenTypes = TokenTypes.type\n  const storeToken = () => {\n    if (tokenA) {\n      switch (tokenType) {\n        case TokenTypes.attribute:\n          attributes[tokenA] = tokenB === true ? true : tokenB\n          tokenB = true\n          break\n\n        case TokenTypes.class:\n          if (!attributes.class) {\n            attributes.class = tokenA\n            break\n          }\n          attributes.class += ' ' + tokenA\n          break\n\n        case TokenTypes.id:\n          attributes.id = tokenA\n          break\n\n        case TokenTypes.type:\n          type = tokenA\n          break\n      }\n      tokenA = ''\n    }\n  }\n\n  let character: string\n\n  let attributeBracketCount: number\n  const parseAttribute = (\n  ): void => {\n    attributeBracketCount = 0\n\n    while (i < length) {\n      character = selector[i]\n      i++\n      if (character === EQUAL) {\n        // Parse attribute value.\n        tokenB = ''\n        character = selector[i]\n        const endOnDoubleQuote = character === QUOTE_DOUBLE\n        const endOnSingleQuote = character === QUOTE_SINGLE\n        if (endOnDoubleQuote || endOnSingleQuote) {\n          tokenB += character\n          i++\n        }\n\n        while (i < length) {\n          character = selector[i]\n          if (\n            (endOnDoubleQuote && character === QUOTE_DOUBLE) ||\n            (endOnSingleQuote && character === QUOTE_SINGLE)\n          ) {\n            tokenB += character\n            i++\n            break\n          } else if (\n            !endOnDoubleQuote &&\n            !endOnSingleQuote &&\n            character === BRACKET_CLOSE\n          ) {\n            break\n          }\n          tokenB += character\n          i++\n        }\n\n        if (\n          (\n            tokenB[0] === QUOTE_DOUBLE &&\n            tokenB[tokenB.length - 1] === QUOTE_DOUBLE\n          ) ||\n          (\n            tokenB[0] === QUOTE_SINGLE &&\n            tokenB[tokenB.length - 1] === QUOTE_SINGLE\n          )\n        ) {\n          tokenB = tokenB.substring(1, tokenB.length - 1)\n        }\n\n\n        // Consume until closing bracket, but don't store the tokes since these are invalid.\n        while (i < length) {\n          character = selector[i]\n          i++\n          if (character === BRACKET_CLOSE) {\n            break\n          }\n        }\n        break\n      } else if (character === BRACKET_OPEN) {\n        attributeBracketCount++\n        continue\n      } else if (character === BRACKET_CLOSE) {\n        attributeBracketCount--\n        if (attributeBracketCount < 0) {\n          break\n        }\n        continue\n      }\n\n      tokenA += character\n    }\n    storeToken()\n  }\n\n  while (i < length) {\n    character = selector[i]\n    i++\n\n    if (character === HASH) {\n      storeToken()\n      tokenType = TokenTypes.id\n      continue\n    } else if (character === DOT) {\n      storeToken()\n      tokenType = TokenTypes.class\n      continue\n    } else if (character === BRACKET_OPEN) {\n      storeToken()\n      tokenType = TokenTypes.attribute\n      parseAttribute()\n      continue\n    }\n\n    tokenA += character\n  }\n\n  return [type, attributes]\n}\n", "\nimport {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport type Fctory = (\n  attributes?: string,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FctoryCache = {\n  [key: string]: Fctory,\n}\n\nexport const fctory = new Proxy({}, {\n  get: (\n    target: FctoryCache,\n    type: string,\n  ): Fctory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      selector?: string,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => {\n      let attributes: NodeAttributes | undefined\n      if (selector) {\n        const [_, _attributes] = selectorToTokenizer(selector)\n        attributes = _attributes\n      }\n      return node(\n        typeConverted,\n        attributes,\n        contents,\n      )\n    }\n  },\n})\n", "let identifierCount = 0\nexport const uniqueIdentifier = (\n): string => '-' + (identifierCount++)\n", "import {\n  marker,\n} from './marker.js'\nimport { NodeContent } from './node.js'\n\nexport type MemoFunction = (\n  state: Record<string, any>,\n  memory: any,\n) => NodeContent[] | NodeContent\n\nexport type MemoAbstract = {\n  _: Symbol,\n  // Compare data\n  m: any,\n  // Render function\n  r: MemoFunction,\n}\n\nexport const memo = (\n  render: MemoFunction,\n  memory: any,\n) => ({\n  _: marker,\n  r: render,\n  m: memory,\n})\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  NodeAbstract,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport const nde = (\n  selector: string,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  const [type, attributes] = selectorToTokenizer(selector)\n  return {\n    _: marker,\n    a: attributes,\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  marker\n} from './marker.js'\n\nexport type TextAbstract = {\n  _: Symbol,\n  // Contents\n  c: string\n}\n\nexport const text = (\n  contents: number | string | (number | string)[],\n): TextAbstract => ({\n  _: marker,\n  c: (\n    Array.isArray(contents)\n      ? contents.join('')\n      : ('' + contents)\n  ),\n})\n", "import {\n  node as n,\n  NodeAbstract,\n  NodeAttributeListener,\n  NodeAttributes,\n  suffixNameIfMultiple,\n  uniqueIdentifier,\n} from '@doars/staark-common'\n\nconst COMPONENT_CLASS = ' staark-component-input'\n\nexport enum InputFieldTypes {\n  checkbox = 'checkbox',\n  color = 'color',\n  date = 'date',\n  datetimeLocal = 'datetime-local',\n  email = 'email',\n  file = 'file',\n  month = 'month',\n  number = 'number',\n  password = 'password',\n  radio = 'radio',\n  range = 'range',\n  search = 'search',\n  tel = 'tel',\n  text = 'text',\n  time = 'time',\n  url = 'url',\n  week = 'week',\n}\n\nexport type InputAttributes = {\n  autocomplete?: string,\n  accepts?: string,\n  checked?: boolean,\n  class?: string | string[],\n  id?: string,\n  max?: number,\n  maxlength?: number,\n  min?: number,\n  minlength?: number,\n  multiple?: boolean,\n  name?: string,\n  placeholder?: string,\n  readonly?: boolean,\n  step?: number,\n  tabindex?: number,\n  type?: InputFieldTypes,\n  value?: string,\n\n  change?: NodeAttributeListener,\n  click?: NodeAttributeListener,\n  focus?: NodeAttributeListener,\n  keydown?: NodeAttributeListener,\n  keyup?: NodeAttributeListener,\n}\n\nexport type LabelOptions = {\n  label: string,\n  append?: boolean,\n}\n\nexport const inputField = (\n  state: Record<string, any>,\n  attributes: InputAttributes,\n  label?: string | LabelOptions,\n): NodeAbstract[] => {\n  state = Object.assign({\n    value: attributes.value || '',\n  }, state)\n\n  attributes.class = (attributes.class || '') + COMPONENT_CLASS\n  if (!attributes.type) {\n    attributes.type = InputFieldTypes.text\n  }\n  attributes.value = state.value\n  suffixNameIfMultiple(attributes)\n\n  const onChange = attributes.change\n  attributes.change = (\n    event: Event,\n  ) => {\n    // TODO: What about the checkboxes and radio types.\n    // TODO: What about the file type.\n    state.value = (event.target as HTMLDataElement).value\n    if (onChange) {\n      onChange(event)\n    }\n  }\n\n  if (typeof (label) === 'string') {\n    label = {\n      label: label,\n    }\n  }\n\n  if (\n    label\n    && !label.append\n    && (\n      attributes.type === InputFieldTypes.checkbox\n      || attributes.type === InputFieldTypes.radio\n    )\n  ) {\n    label.append = true\n  }\n\n  const contents: NodeAbstract[] = [\n    n('input', attributes),\n  ]\n\n  if (label) {\n    if (!attributes.id) {\n      attributes.id = 'auto-id' + uniqueIdentifier()\n    }\n\n    const labelAttributes: NodeAttributes = {\n      for: attributes.id,\n    }\n    if (\n      attributes.type === InputFieldTypes.checkbox\n      || attributes.type === InputFieldTypes.radio\n    ) {\n      labelAttributes.tabindex = 0\n      labelAttributes.click = (\n        event: Event,\n      ): void => {\n        (\n          (event.target as HTMLElement)\n            .previousSibling as HTMLElement\n        ).focus()\n      }\n    }\n    const labelAbstract: NodeAbstract = n(\n      'label',\n      labelAttributes,\n      label.label,\n    )\n\n    if (\n      label\n      && label.append\n    ) {\n      contents.push(labelAbstract)\n    } else {\n      contents.unshift(labelAbstract)\n    }\n  }\n\n  return contents\n}\n", "import {\n  node as n,\n  NodeAbstract,\n  NodeAttributeListener,\n  // onCreated,\n  suffixNameIfMultiple,\n  uniqueIdentifier,\n} from '@doars/staark-common'\n\nconst COMPONENT_CLASS = ' staark-component-file-input'\n\nexport type FileInputAttributes = {\n  // Constants\n  tabindex?: -1,\n  type?: 'file',\n\n  accepts?: string,\n  class?: string | string[],\n  hidden?: true,\n  id?: string,\n  multiple?: boolean,\n  name?: string,\n  value?: string,\n\n  change?: NodeAttributeListener,\n}\n\nexport const inputFile = (\n  state: Record<string, any>,\n  attributes: FileInputAttributes,\n  label?: string,\n): NodeAbstract[] => {\n  state = Object.assign({\n    files: [],\n  }, state)\n\n  attributes.class = (attributes.class || '') + COMPONENT_CLASS\n  attributes.hidden = true\n  if (!attributes.id) {\n    attributes.id = ('file-input' + uniqueIdentifier())\n  }\n  attributes.tabindex = -1\n  attributes.type = 'file'\n  suffixNameIfMultiple(attributes)\n\n  // TODO: Allow hooks to be placed on nodes that track the life cycle of the node. For instance when the element is created or destroyed.\n  // onCreated(attributes.id, (\n  //   event: CustomEvent,\n  // ) => {\n  //   if (\n  //     event.detail.target\n  //     && state.files\n  //     && state.files.length > 0\n  //   ) {\n  //     const dataTransfer = new DataTransfer()\n  //     for (let i = 0; i < state.files.length; i++) {\n  //       dataTransfer.items.add(\n  //         state.files[i],\n  //       )\n  //     }\n  //     (event.detail.target as HTMLInputElement).files = dataTransfer.files\n  //   }\n  // })\n\n  const onChange = attributes.change\n  attributes.change = (\n    event: Event,\n  ) => {\n    state.files = (event.target as HTMLInputElement).files\n    if (onChange) {\n      onChange(event)\n    }\n  }\n\n  return [\n    n('input', attributes),\n    n('label', {\n      for: attributes.id,\n\n      dragover: (\n        event: Event,\n      ) => {\n        event.preventDefault()\n      },\n      drop: (\n        event: Event,\n      ) => {\n        event.preventDefault()\n\n        state.files = (event as DragEvent).dataTransfer?.files\n        if (onChange) {\n          onChange(event)\n        }\n      },\n    }, label || ''),\n  ]\n}\n", "export const marker = Symbol()\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\nimport {\n  TextAbstract,\n} from './text.js'\n\nexport type NodeAttributeListener = (\n  event: Event\n) => unknown\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract |\n  TextAbstract\n\nexport type NodeAbstract = {\n  _: Symbol\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport type Factory = (\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FactoryCache = {\n  [key: string]: Factory,\n}\n\nexport const factory = new Proxy({}, {\n  get: (\n    target: FactoryCache,\n    type: string,\n  ): Factory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => node(\n      typeConverted,\n      attributesOrContents,\n      contents,\n    )\n  },\n})\n", "const BRACKET_CLOSE = ']'\nconst BRACKET_OPEN = '['\nconst DOT = '.'\nconst EQUAL = '='\nconst HASH = '#'\nconst QUOTE_SINGLE = '\\''\nconst QUOTE_DOUBLE = '\"'\n\nenum TokenTypes {\n  attribute = 0,\n  class = 1,\n  id = 2,\n  type = 3,\n}\n\nexport const selectorToTokenizer = (\n  selector: string,\n): [string, Record<string, any>] => {\n  const length: number = selector.length\n  let i: number = 0\n\n  let type: string = ''\n  const attributes: Record<string, any> = {}\n\n  let tokenA: string = ''\n  let tokenB: string | true = true\n  let tokenType: TokenTypes = TokenTypes.type\n  const storeToken = () => {\n    if (tokenA) {\n      switch (tokenType) {\n        case TokenTypes.attribute:\n          attributes[tokenA] = tokenB === true ? true : tokenB\n          tokenB = true\n          break\n\n        case TokenTypes.class:\n          if (!attributes.class) {\n            attributes.class = tokenA\n            break\n          }\n          attributes.class += ' ' + tokenA\n          break\n\n        case TokenTypes.id:\n          attributes.id = tokenA\n          break\n\n        case TokenTypes.type:\n          type = tokenA\n          break\n      }\n      tokenA = ''\n    }\n  }\n\n  let character: string\n\n  let attributeBracketCount: number\n  const parseAttribute = (\n  ): void => {\n    attributeBracketCount = 0\n\n    while (i < length) {\n      character = selector[i]\n      i++\n      if (character === EQUAL) {\n        // Parse attribute value.\n        tokenB = ''\n        character = selector[i]\n        const endOnDoubleQuote = character === QUOTE_DOUBLE\n        const endOnSingleQuote = character === QUOTE_SINGLE\n        if (endOnDoubleQuote || endOnSingleQuote) {\n          tokenB += character\n          i++\n        }\n\n        while (i < length) {\n          character = selector[i]\n          if (\n            (endOnDoubleQuote && character === QUOTE_DOUBLE) ||\n            (endOnSingleQuote && character === QUOTE_SINGLE)\n          ) {\n            tokenB += character\n            i++\n            break\n          } else if (\n            !endOnDoubleQuote &&\n            !endOnSingleQuote &&\n            character === BRACKET_CLOSE\n          ) {\n            break\n          }\n          tokenB += character\n          i++\n        }\n\n        if (\n          (\n            tokenB[0] === QUOTE_DOUBLE &&\n            tokenB[tokenB.length - 1] === QUOTE_DOUBLE\n          ) ||\n          (\n            tokenB[0] === QUOTE_SINGLE &&\n            tokenB[tokenB.length - 1] === QUOTE_SINGLE\n          )\n        ) {\n          tokenB = tokenB.substring(1, tokenB.length - 1)\n        }\n\n\n        // Consume until closing bracket, but don't store the tokes since these are invalid.\n        while (i < length) {\n          character = selector[i]\n          i++\n          if (character === BRACKET_CLOSE) {\n            break\n          }\n        }\n        break\n      } else if (character === BRACKET_OPEN) {\n        attributeBracketCount++\n        continue\n      } else if (character === BRACKET_CLOSE) {\n        attributeBracketCount--\n        if (attributeBracketCount < 0) {\n          break\n        }\n        continue\n      }\n\n      tokenA += character\n    }\n    storeToken()\n  }\n\n  while (i < length) {\n    character = selector[i]\n    i++\n\n    if (character === HASH) {\n      storeToken()\n      tokenType = TokenTypes.id\n      continue\n    } else if (character === DOT) {\n      storeToken()\n      tokenType = TokenTypes.class\n      continue\n    } else if (character === BRACKET_OPEN) {\n      storeToken()\n      tokenType = TokenTypes.attribute\n      parseAttribute()\n      continue\n    }\n\n    tokenA += character\n  }\n\n  return [type, attributes]\n}\n", "\nimport {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport type Fctory = (\n  attributes?: string,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FctoryCache = {\n  [key: string]: Fctory,\n}\n\nexport const fctory = new Proxy({}, {\n  get: (\n    target: FctoryCache,\n    type: string,\n  ): Fctory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      selector?: string,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => {\n      let attributes: NodeAttributes | undefined\n      if (selector) {\n        const [_, _attributes] = selectorToTokenizer(selector)\n        attributes = _attributes\n      }\n      return node(\n        typeConverted,\n        attributes,\n        contents,\n      )\n    }\n  },\n})\n", "import {\n  node as n,\n  NodeAbstract,\n} from '@doars/staark/src/index.js'\nimport {\n  inputField,\n  InputAttributes,\n  InputFieldTypes,\n} from './inputField.js'\n\nexport type InputListItem = {\n  id?: string,\n  label?: string,\n  value: string,\n  search: string, // TODO: Search this as well as the label/value.\n}\n\nexport type InputListOptions = {\n  class?: string,\n  id?: string,\n  legend?: string,\n  multiple?: boolean,\n  name: string,\n\n  selectAllLabel?: string,\n  selected?: string[],\n  selectedChange?: (argument: string[]) => unknown,\n  selectNoneLabel?: string,\n\n  preview: boolean,\n  previewLabel?: string,\n  previewPlaceholder?: string,\n\n  search: boolean | number,\n  searchChange?: (argument: string) => unknown,\n  searchLabel?: string,\n  searchPlaceholder?: string,\n  searchResetLabel?: string,\n  searchValue?: string,\n}\n\n// TODO: If the user has clicked on the input and starts typing, it should automatically enter into the search bar.\n// TODO: The searching should still show all items, just hide the irrelivent ones.\n// TODO: Add a select all or deselect all option.\n\nexport const inputList = (\n  state: Record<string, any>,\n  options: InputListOptions,\n  items: InputListItem[],\n): NodeAbstract => {\n  // Prefill the state.\n  state = Object.assign({\n    query: options.searchValue,\n    selected: options.selected ? [...options.selected] : [],\n  }, state)\n\n  let contents: NodeAbstract[] = []\n\n  // Setup items.\n  const inputOptions: InputAttributes = {\n    appendLabel: true,\n    multiple: options.multiple,\n    name: options.name,\n    type: options.multiple ? InputFieldTypes.checkbox : InputFieldTypes.radio,\n\n    change: (\n      event: Event,\n    ): void => {\n      // Keep the focus on the input element.\n      // @ts-ignore\n      (event as UIEvent).target.focus()\n\n      const target: HTMLInputElement = event.target as HTMLInputElement\n      if (!target.checked) {\n        const index = state.selected.indexOf(target.value)\n        if (index >= 0) {\n          state.selected.splice(index, 1)\n        }\n      } else if (options.multiple) {\n        if (state.selected.indexOf(target.value) < 0) {\n          state.selected.push(target.value)\n        }\n      } else {\n        state.selected = [target.value]\n      }\n\n      if (options.selectedChange) {\n        options.selectedChange([...state.selected])\n      }\n    },\n  }\n  for (let i = 0; i < items.length; i++) {\n    const item: InputListItem = items[i]\n    // Check if item matches query.\n    if (state.query && (\n      (item.label && item.label.indexOf(state.query) < 0) ||\n      item.value.indexOf(state.query) < 0\n    )) {\n      continue\n    }\n\n    const itemOptions: InputAttributes = {\n      ...inputOptions,\n      value: item.value,\n    }\n    if (state.selected.indexOf(item.value) >= 0) {\n      itemOptions.checked = true\n    }\n    if (item.id) {\n      itemOptions.id = item.id\n    }\n    contents.push(\n      ...inputField(\n        itemOptions,\n        item.label ?? item.value, // TODO: When the label is clicked put the focus on the input element.\n      ),\n    )\n  }\n\n  if (options.selectNoneLabel && state.selected.length > 0) {\n    contents.unshift(\n      n('button', {\n        click: (\n        ): void => {\n          state.selected = []\n\n          if (options.selectedChange) {\n            options.selectedChange([...state.selected])\n          }\n        },\n        type: 'button',\n      }, options.selectNoneLabel),\n    )\n  }\n\n  if (options.selectAllLabel && state.selected.length !== items.length) {\n    contents.unshift(\n      n('button', {\n        click: (\n        ): void => {\n          // Create list of all values.\n          const selected: string[] = []\n          for (const item of items) {\n            state.selected.push(item.value)\n          }\n          state.selected = selected\n\n          if (options.selectedChange) {\n            options.selectedChange(selected)\n          }\n        },\n        type: 'button',\n      }, options.selectAllLabel),\n    )\n  }\n\n  // Setup search input.\n  if (options.search && (\n    typeof (options.search) === 'boolean' ||\n    items.length >= options.search\n  )) {\n    if (state.query) {\n      contents.unshift(\n        n('button', {\n          click: (\n            event: Event,\n          ): void => {\n            // Set focus to search field.\n            // @ts-ignore\n            (event as UIEvent).target.previousSibling.focus()\n\n            state.query = null\n\n            if (options.searchChange) {\n              options.searchChange(state.query)\n            }\n          },\n          type: 'button',\n        }, options.searchResetLabel ?? '\u00D7'),\n      )\n    }\n\n    const searchOptions: InputAttributes = {\n      type: InputFieldTypes.search,\n      value: state.query,\n\n      keyup: (\n        event: Event,\n      ): void => {\n        // @ts-ignore.\n        state.query = event.target.value\n\n        if (options.searchChange) {\n          options.searchChange(state.query)\n        }\n      },\n    }\n    if (options.searchPlaceholder) {\n      searchOptions.placeholder = options.searchPlaceholder\n    }\n\n    contents.unshift(\n      ...inputField(searchOptions, options.searchLabel),\n    )\n  }\n\n  contents = [\n    n('div', {}, contents),\n  ]\n\n  if (options.preview) {\n    const previewOptions: InputAttributes = {\n      readonly: true,\n      tabindex: -1,\n      type: InputFieldTypes.text,\n    }\n\n    const labels: string[] = []\n    for (const item of items) {\n      if (state.selected.indexOf(item.value) >= 0) {\n        labels.push(item.label ?? item.value)\n      }\n    }\n    previewOptions.value = labels.join(', ')\n\n    contents.unshift(\n      ...inputField(previewOptions, options.previewLabel),\n    )\n  }\n\n  if (options.legend) {\n    contents.unshift(\n      n('legend', {\n        click: (\n          event: Event,\n        ): void => {\n          // @ts-ignore\n          event.target.parentNode.focus()\n        },\n      }, options.legend),\n    )\n  }\n\n  const fieldAttributes: { [key: string]: any } = {\n    tabindex: 0,\n  }\n  if (options.class) {\n    fieldAttributes.class = options.class\n  }\n  return n('fieldset', fieldAttributes, contents)\n}\n", "import {\n  node as n,\n  NodeContent,\n  NodeAbstract,\n} from '@doars/staark/src/index.js'\n\nexport type RouterOptions = {\n  initial?: string\n  // TODO:\n}\n\n// TODO: Listen to history changes.\n\nexport const router = (\n  routes: Record<string, NodeContent[] | NodeContent>,\n  state: Record<string, any>,\n  options: RouterOptions = {},\n): NodeAbstract => {\n  state = Object.assign({\n    route: options.initial ?? '',\n  }, state)\n\n  // TODO:\n\n  return n('div')\n}\n"],
  "mappings": "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",
  "names": ["InputFieldTypes", "COMPONENT_CLASS", "marker", "node", "marker", "factory", "node", "BRACKET_CLOSE", "BRACKET_OPEN", "DOT", "EQUAL", "HASH", "QUOTE_SINGLE", "QUOTE_DOUBLE", "selectorToTokenizer", "EQUAL", "QUOTE_DOUBLE", "QUOTE_SINGLE", "BRACKET_CLOSE", "BRACKET_OPEN", "HASH", "DOT", "fctory", "selectorToTokenizer", "node", "node", "node"]
}
