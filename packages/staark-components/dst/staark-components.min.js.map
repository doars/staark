{
  "version": 3,
  "sources": ["../../staark-common/src/array.ts", "../../staark-common/src/attribute.ts", "../../staark-common/src/clone.ts", "../../staark-common/src/compare.ts", "../../staark-common/src/conditional.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/element.ts", "../../staark-common/src/factory.ts", "../../staark-common/src/selector.ts", "../../staark-common/src/fctory.ts", "../../staark-common/src/identifier.ts", "../../staark-common/src/memo.ts", "../../staark-common/src/nde.ts", "../../staark-common/src/text.ts", "../src/scripts/inputField.ts", "../src/scripts/inputFile.ts", "../../staark-common/src/marker.ts", "../../staark-common/src/node.ts", "../../staark-common/src/factory.ts", "../../staark-common/src/selector.ts", "../../staark-common/src/fctory.ts", "../src/scripts/inputList.ts", "../src/scripts/router.ts"],
  "sourcesContent": ["export const arrayify = function <T>(\n  data: T[] | T,\n): T[] {\n  if (Array.isArray(data)) {\n    return data\n  }\n  return [\n    data,\n  ]\n}\n", "const SUFFIX_MULTIPLE: string = '[]'\n\nexport type MultipleAttributes = {\n  multiple?: boolean,\n  name?: string,\n}\n\nexport const suffixNameIfMultiple = (\n  attributes: MultipleAttributes,\n) => {\n  if (\n    attributes.multiple\n    && attributes.name\n    && !attributes.name.endsWith(SUFFIX_MULTIPLE)\n  ) {\n    attributes.name += SUFFIX_MULTIPLE\n  }\n}\n", "export const cloneRecursive = (\n  value: any,\n) => {\n  if (typeof (value) === 'object') {\n    if (Array.isArray(value)) {\n      const clone: any[] = []\n      for (let i = 0; i < value.length; i++) {\n        clone.push(cloneRecursive(value[i]))\n      }\n      value = clone\n    } else {\n      const clone: Record<string, any> = {}\n      for (const key in value) {\n        clone[key] = cloneRecursive(value[key])\n      }\n      value = clone\n    }\n  }\n  return value\n}\n", "export const equalRecursive = (\n  valueA: any,\n  valueB: any,\n): boolean => {\n  if (valueA === valueB) {\n    return true\n  }\n  if (\n    valueA instanceof Date\n    && valueB instanceof Date\n  ) {\n    return valueA.getTime() === valueB.getTime()\n  }\n  if (\n    !valueA\n    || !valueB\n    || (\n      typeof valueA !== 'object' && typeof valueB !== 'object'\n    )\n  ) {\n    return valueA === valueB\n  }\n  if (\n    valueA === null\n    || valueA === undefined\n    || valueB === null\n    || valueB === undefined\n  ) {\n    return false\n  }\n  if (valueA.prototype !== valueB.prototype) {\n    return false\n  }\n  let keys = Object.keys(valueA)\n  if (keys.length !== Object.keys(valueB).length) {\n    return false\n  }\n  return keys.every(\n    (key: string): boolean => equalRecursive(valueA[key], valueB[key]),\n  )\n}\n", "import { arrayify } from './array.js'\nimport { NodeAbstract } from './node.js'\n\nexport const conditional = (\n  condition: any,\n  onTruth: NodeAbstract[] | NodeAbstract,\n  onFalse?: NodeAbstract[] | NodeAbstract,\n): NodeAbstract[] => {\n  if (condition) {\n    return arrayify(onTruth)\n  }\n  return arrayify(onFalse ?? [])\n}\n", "export const marker = Symbol()\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\nimport {\n  TextAbstract,\n} from './text.js'\n\nexport type NodeAttributeListener = (\n  event: Event\n) => unknown\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract |\n  TextAbstract\n\nexport type NodeAbstract = {\n  _: Symbol\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport const childrenToNodes = (\n  element: Element | ChildNode,\n) => {\n  const abstractChildNodes: NodeContent[] = []\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const childNode = element.childNodes[i]\n    if (childNode instanceof Text) {\n      abstractChildNodes.push(\n        childNode.textContent ?? ''\n      )\n    } else {\n      let attributes: NodeAttributes = {}\n      for (let i = 0; i < (childNode as Element).attributes.length; i++) {\n        const attribute = (childNode as Element).attributes[i]\n        attributes[attribute.name] = attribute.value\n      }\n\n      abstractChildNodes.push(\n        node(\n          childNode.nodeName,\n          attributes,\n          childrenToNodes(childNode),\n        )\n      )\n    }\n  }\n  return abstractChildNodes\n}\n", "import {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport type Factory = (\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FactoryCache = {\n  [key: string]: Factory,\n}\n\nexport const factory = new Proxy({}, {\n  get: (\n    target: FactoryCache,\n    type: string,\n  ): Factory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => node(\n      typeConverted,\n      attributesOrContents,\n      contents,\n    )\n  },\n})\n", "const BRACKET_CLOSE = ']'\nconst BRACKET_OPEN = '['\nconst DOT = '.'\nconst EQUAL = '='\nconst HASH = '#'\nconst QUOTE_SINGLE = '\\''\nconst QUOTE_DOUBLE = '\"'\n\nenum TokenTypes {\n  attribute = 0,\n  class = 1,\n  id = 2,\n  type = 3,\n}\n\nexport const selectorToTokenizer = (\n  selector: string,\n): [string, Record<string, any>] => {\n  const length: number = selector.length\n  let i: number = 0\n\n  let type: string = ''\n  const attributes: Record<string, any> = {}\n\n  let tokenA: string = ''\n  let tokenB: string | true = true\n  let tokenType: TokenTypes = TokenTypes.type\n  const storeToken = () => {\n    if (tokenA) {\n      switch (tokenType) {\n        case TokenTypes.attribute:\n          attributes[tokenA] = tokenB === true ? true : tokenB\n          tokenB = true\n          break\n\n        case TokenTypes.class:\n          if (!attributes.class) {\n            attributes.class = tokenA\n            break\n          }\n          attributes.class += ' ' + tokenA\n          break\n\n        case TokenTypes.id:\n          attributes.id = tokenA\n          break\n\n        case TokenTypes.type:\n          type = tokenA\n          break\n      }\n      tokenA = ''\n    }\n  }\n\n  let character: string\n\n  let attributeBracketCount: number\n  const parseAttribute = (\n  ): void => {\n    attributeBracketCount = 0\n\n    while (i < length) {\n      character = selector[i]\n      i++\n      if (character === EQUAL) {\n        // Parse attribute value.\n        tokenB = ''\n        character = selector[i]\n        const endOnDoubleQuote = character === QUOTE_DOUBLE\n        const endOnSingleQuote = character === QUOTE_SINGLE\n        if (endOnDoubleQuote || endOnSingleQuote) {\n          tokenB += character\n          i++\n        }\n\n        while (i < length) {\n          character = selector[i]\n          if (\n            (endOnDoubleQuote && character === QUOTE_DOUBLE) ||\n            (endOnSingleQuote && character === QUOTE_SINGLE)\n          ) {\n            tokenB += character\n            i++\n            break\n          } else if (\n            !endOnDoubleQuote &&\n            !endOnSingleQuote &&\n            character === BRACKET_CLOSE\n          ) {\n            break\n          }\n          tokenB += character\n          i++\n        }\n\n        if (\n          (\n            tokenB[0] === QUOTE_DOUBLE &&\n            tokenB[tokenB.length - 1] === QUOTE_DOUBLE\n          ) ||\n          (\n            tokenB[0] === QUOTE_SINGLE &&\n            tokenB[tokenB.length - 1] === QUOTE_SINGLE\n          )\n        ) {\n          tokenB = tokenB.substring(1, tokenB.length - 1)\n        }\n\n\n        // Consume until closing bracket, but don't store the tokes since these are invalid.\n        while (i < length) {\n          character = selector[i]\n          i++\n          if (character === BRACKET_CLOSE) {\n            break\n          }\n        }\n        break\n      } else if (character === BRACKET_OPEN) {\n        attributeBracketCount++\n        continue\n      } else if (character === BRACKET_CLOSE) {\n        attributeBracketCount--\n        if (attributeBracketCount < 0) {\n          break\n        }\n        continue\n      }\n\n      tokenA += character\n    }\n    storeToken()\n  }\n\n  while (i < length) {\n    character = selector[i]\n    i++\n\n    if (character === HASH) {\n      storeToken()\n      tokenType = TokenTypes.id\n      continue\n    } else if (character === DOT) {\n      storeToken()\n      tokenType = TokenTypes.class\n      continue\n    } else if (character === BRACKET_OPEN) {\n      storeToken()\n      tokenType = TokenTypes.attribute\n      parseAttribute()\n      continue\n    }\n\n    tokenA += character\n  }\n\n  return [type, attributes]\n}\n", "\nimport {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport type Fctory = (\n  attributes?: string,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FctoryCache = {\n  [key: string]: Fctory,\n}\n\nexport const fctory = new Proxy({}, {\n  get: (\n    target: FctoryCache,\n    type: string,\n  ): Fctory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      selector?: string,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => {\n      let attributes: NodeAttributes | undefined\n      if (selector) {\n        const [_, _attributes] = selectorToTokenizer(selector)\n        attributes = _attributes\n      }\n      return node(\n        typeConverted,\n        attributes,\n        contents,\n      )\n    }\n  },\n})\n", "let identifierCount = 0\nexport const uniqueIdentifier = (\n): string => '-' + (identifierCount++)\n", "import {\n  marker,\n} from './marker.js'\nimport { NodeContent } from './node.js'\n\nexport type MemoFunction = (\n  state: Record<string, any>,\n  memory: any,\n) => NodeContent[] | NodeContent\n\nexport type MemoAbstract = {\n  _: Symbol,\n  // Compare data\n  m: any,\n  // Render function\n  r: MemoFunction,\n}\n\nexport const memo = (\n  render: MemoFunction,\n  memory: any,\n) => ({\n  _: marker,\n  r: render,\n  m: memory,\n})\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  NodeAbstract,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport const nde = (\n  selector: string,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  const [type, attributes] = selectorToTokenizer(selector)\n  return {\n    _: marker,\n    a: attributes,\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  marker\n} from './marker.js'\n\nexport type TextAbstract = {\n  _: Symbol,\n  // Contents\n  c: string\n}\n\nexport const text = (\n  contents: number | string | (number | string)[],\n): TextAbstract => ({\n  _: marker,\n  c: (\n    Array.isArray(contents)\n      ? contents.join('')\n      : ('' + contents)\n  ),\n})\n", "import {\n  node as n,\n  NodeAbstract,\n  NodeAttributeListener,\n  NodeAttributes,\n  suffixNameIfMultiple,\n  uniqueIdentifier,\n} from '@doars/staark-common'\n\nconst COMPONENT_CLASS = ' staark-component-input'\n\nexport enum InputFieldTypes {\n  checkbox = 'checkbox',\n  color = 'color',\n  date = 'date',\n  datetimeLocal = 'datetime-local',\n  email = 'email',\n  file = 'file',\n  month = 'month',\n  number = 'number',\n  password = 'password',\n  radio = 'radio',\n  range = 'range',\n  search = 'search',\n  tel = 'tel',\n  text = 'text',\n  time = 'time',\n  url = 'url',\n  week = 'week',\n}\n\nexport type InputAttributes = {\n  autocomplete?: string,\n  accepts?: string,\n  checked?: boolean,\n  class?: string | string[],\n  id?: string,\n  max?: number,\n  maxlength?: number,\n  min?: number,\n  minlength?: number,\n  multiple?: boolean,\n  name?: string,\n  placeholder?: string,\n  readonly?: boolean,\n  step?: number,\n  tabindex?: number,\n  type?: InputFieldTypes,\n  value?: string,\n\n  change?: NodeAttributeListener,\n  click?: NodeAttributeListener,\n  focus?: NodeAttributeListener,\n  keydown?: NodeAttributeListener,\n  keyup?: NodeAttributeListener,\n}\n\nexport type LabelOptions = {\n  label: string,\n  append?: boolean,\n}\n\nexport const inputField = (\n  state: Record<string, any>,\n  attributes: InputAttributes,\n  label?: string | LabelOptions,\n): NodeAbstract[] => {\n  state = Object.assign({\n    value: attributes.value || '',\n  }, state)\n\n  attributes.class = (attributes.class || '') + COMPONENT_CLASS\n  if (!attributes.type) {\n    attributes.type = InputFieldTypes.text\n  }\n  attributes.value = state.value\n  suffixNameIfMultiple(attributes)\n\n  const onChange = attributes.change\n  attributes.change = (\n    event: Event,\n  ) => {\n    // TODO: What about the checkboxes and radio types.\n    // TODO: What about the file type.\n    state.value = (event.target as HTMLDataElement).value\n    if (onChange) {\n      onChange(event)\n    }\n  }\n\n  if (typeof (label) === 'string') {\n    label = {\n      label: label,\n    }\n  }\n\n  if (\n    label\n    && !label.append\n    && (\n      attributes.type === InputFieldTypes.checkbox\n      || attributes.type === InputFieldTypes.radio\n    )\n  ) {\n    label.append = true\n  }\n\n  const contents: NodeAbstract[] = [\n    n('input', attributes),\n  ]\n\n  if (label) {\n    if (!attributes.id) {\n      attributes.id = 'auto-id' + uniqueIdentifier()\n    }\n\n    const labelAttributes: NodeAttributes = {\n      for: attributes.id,\n    }\n    if (\n      attributes.type === InputFieldTypes.checkbox\n      || attributes.type === InputFieldTypes.radio\n    ) {\n      labelAttributes.tabindex = 0\n      labelAttributes.click = (\n        event: Event,\n      ): void => {\n        (\n          (event.target as HTMLElement)\n            .previousSibling as HTMLElement\n        ).focus()\n      }\n    }\n    const labelAbstract: NodeAbstract = n(\n      'label',\n      labelAttributes,\n      label.label,\n    )\n\n    if (\n      label\n      && label.append\n    ) {\n      contents.push(labelAbstract)\n    } else {\n      contents.unshift(labelAbstract)\n    }\n  }\n\n  return contents\n}\n", "import {\n  node as n,\n  NodeAbstract,\n  NodeAttributeListener,\n  // onCreated,\n  suffixNameIfMultiple,\n  uniqueIdentifier,\n} from '@doars/staark-common'\n\nconst COMPONENT_CLASS = ' staark-component-file-input'\n\nexport type FileInputAttributes = {\n  // Constants\n  tabindex?: -1,\n  type?: 'file',\n\n  accepts?: string,\n  class?: string | string[],\n  hidden?: true,\n  id?: string,\n  multiple?: boolean,\n  name?: string,\n  value?: string,\n\n  change?: NodeAttributeListener,\n}\n\nexport const inputFile = (\n  state: Record<string, any>,\n  attributes: FileInputAttributes,\n  label?: string,\n): NodeAbstract[] => {\n  state = Object.assign({\n    files: [],\n  }, state)\n\n  attributes.class = (attributes.class || '') + COMPONENT_CLASS\n  attributes.hidden = true\n  if (!attributes.id) {\n    attributes.id = ('file-input' + uniqueIdentifier())\n  }\n  attributes.tabindex = -1\n  attributes.type = 'file'\n  suffixNameIfMultiple(attributes)\n\n  // TODO: Allow hooks to be placed on nodes that track the life cycle of the node. For instance when the element is created or destroyed.\n  // onCreated(attributes.id, (\n  //   event: CustomEvent,\n  // ) => {\n  //   if (\n  //     event.detail.target\n  //     && state.files\n  //     && state.files.length > 0\n  //   ) {\n  //     const dataTransfer = new DataTransfer()\n  //     for (let i = 0; i < state.files.length; i++) {\n  //       dataTransfer.items.add(\n  //         state.files[i],\n  //       )\n  //     }\n  //     (event.detail.target as HTMLInputElement).files = dataTransfer.files\n  //   }\n  // })\n\n  const onChange = attributes.change\n  attributes.change = (\n    event: Event,\n  ) => {\n    state.files = (event.target as HTMLInputElement).files\n    if (onChange) {\n      onChange(event)\n    }\n  }\n\n  return [\n    n('input', attributes),\n    n('label', {\n      for: attributes.id,\n\n      dragover: (\n        event: Event,\n      ) => {\n        event.preventDefault()\n      },\n      drop: (\n        event: Event,\n      ) => {\n        event.preventDefault()\n\n        state.files = (event as DragEvent).dataTransfer?.files\n        if (onChange) {\n          onChange(event)\n        }\n      },\n    }, label || ''),\n  ]\n}\n", "export const marker = Symbol()\n", "import {\n  marker,\n} from './marker.js'\nimport {\n  MemoAbstract,\n} from './memo.js'\nimport {\n  TextAbstract,\n} from './text.js'\n\nexport type NodeAttributeListener = (\n  event: Event\n) => unknown\n\nexport type NodeAttributes =\n  Record<string,\n    boolean |\n    null |\n    number |\n    string |\n    (number | string)[] |\n    NodeAttributeListener |\n    Record<string,\n      boolean | number | string\n    >\n  >\n\nexport type NodeContent =\n  string |\n  MemoAbstract |\n  NodeAbstract |\n  TextAbstract\n\nexport type NodeAbstract = {\n  _: Symbol\n  // Attributes\n  a?: NodeAttributes\n  // Content\n  c?: NodeContent[]\n  // Node type\n  t: string\n}\n\nexport const node = (\n  type: string,\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n): NodeAbstract => {\n  if (\n    typeof (attributesOrContents) !== 'object'\n    || (attributesOrContents as NodeAbstract)._ === marker\n    || Array.isArray(attributesOrContents)\n  ) {\n    contents = attributesOrContents as NodeContent\n    attributesOrContents = undefined\n  }\n\n  return {\n    _: marker,\n    a: attributesOrContents as (NodeAttributes | undefined),\n    c: (\n      contents\n        ? Array.isArray(contents)\n          ? contents\n          : [contents] as NodeContent[]\n        : []\n    ),\n    t: type.toUpperCase(),\n  }\n}\n", "import {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\n\nexport type Factory = (\n  attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FactoryCache = {\n  [key: string]: Factory,\n}\n\nexport const factory = new Proxy({}, {\n  get: (\n    target: FactoryCache,\n    type: string,\n  ): Factory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      attributesOrContents?: NodeAttributes | NodeContent[] | NodeContent,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => node(\n      typeConverted,\n      attributesOrContents,\n      contents,\n    )\n  },\n})\n", "const BRACKET_CLOSE = ']'\nconst BRACKET_OPEN = '['\nconst DOT = '.'\nconst EQUAL = '='\nconst HASH = '#'\nconst QUOTE_SINGLE = '\\''\nconst QUOTE_DOUBLE = '\"'\n\nenum TokenTypes {\n  attribute = 0,\n  class = 1,\n  id = 2,\n  type = 3,\n}\n\nexport const selectorToTokenizer = (\n  selector: string,\n): [string, Record<string, any>] => {\n  const length: number = selector.length\n  let i: number = 0\n\n  let type: string = ''\n  const attributes: Record<string, any> = {}\n\n  let tokenA: string = ''\n  let tokenB: string | true = true\n  let tokenType: TokenTypes = TokenTypes.type\n  const storeToken = () => {\n    if (tokenA) {\n      switch (tokenType) {\n        case TokenTypes.attribute:\n          attributes[tokenA] = tokenB === true ? true : tokenB\n          tokenB = true\n          break\n\n        case TokenTypes.class:\n          if (!attributes.class) {\n            attributes.class = tokenA\n            break\n          }\n          attributes.class += ' ' + tokenA\n          break\n\n        case TokenTypes.id:\n          attributes.id = tokenA\n          break\n\n        case TokenTypes.type:\n          type = tokenA\n          break\n      }\n      tokenA = ''\n    }\n  }\n\n  let character: string\n\n  let attributeBracketCount: number\n  const parseAttribute = (\n  ): void => {\n    attributeBracketCount = 0\n\n    while (i < length) {\n      character = selector[i]\n      i++\n      if (character === EQUAL) {\n        // Parse attribute value.\n        tokenB = ''\n        character = selector[i]\n        const endOnDoubleQuote = character === QUOTE_DOUBLE\n        const endOnSingleQuote = character === QUOTE_SINGLE\n        if (endOnDoubleQuote || endOnSingleQuote) {\n          tokenB += character\n          i++\n        }\n\n        while (i < length) {\n          character = selector[i]\n          if (\n            (endOnDoubleQuote && character === QUOTE_DOUBLE) ||\n            (endOnSingleQuote && character === QUOTE_SINGLE)\n          ) {\n            tokenB += character\n            i++\n            break\n          } else if (\n            !endOnDoubleQuote &&\n            !endOnSingleQuote &&\n            character === BRACKET_CLOSE\n          ) {\n            break\n          }\n          tokenB += character\n          i++\n        }\n\n        if (\n          (\n            tokenB[0] === QUOTE_DOUBLE &&\n            tokenB[tokenB.length - 1] === QUOTE_DOUBLE\n          ) ||\n          (\n            tokenB[0] === QUOTE_SINGLE &&\n            tokenB[tokenB.length - 1] === QUOTE_SINGLE\n          )\n        ) {\n          tokenB = tokenB.substring(1, tokenB.length - 1)\n        }\n\n\n        // Consume until closing bracket, but don't store the tokes since these are invalid.\n        while (i < length) {\n          character = selector[i]\n          i++\n          if (character === BRACKET_CLOSE) {\n            break\n          }\n        }\n        break\n      } else if (character === BRACKET_OPEN) {\n        attributeBracketCount++\n        continue\n      } else if (character === BRACKET_CLOSE) {\n        attributeBracketCount--\n        if (attributeBracketCount < 0) {\n          break\n        }\n        continue\n      }\n\n      tokenA += character\n    }\n    storeToken()\n  }\n\n  while (i < length) {\n    character = selector[i]\n    i++\n\n    if (character === HASH) {\n      storeToken()\n      tokenType = TokenTypes.id\n      continue\n    } else if (character === DOT) {\n      storeToken()\n      tokenType = TokenTypes.class\n      continue\n    } else if (character === BRACKET_OPEN) {\n      storeToken()\n      tokenType = TokenTypes.attribute\n      parseAttribute()\n      continue\n    }\n\n    tokenA += character\n  }\n\n  return [type, attributes]\n}\n", "\nimport {\n  node,\n  NodeAbstract,\n  NodeAttributes,\n  NodeContent,\n} from './node.js'\nimport {\n  selectorToTokenizer,\n} from './selector.js'\n\nexport type Fctory = (\n  attributes?: string,\n  contents?: NodeContent[] | NodeContent,\n) => NodeAbstract\n\nexport type FctoryCache = {\n  [key: string]: Fctory,\n}\n\nexport const fctory = new Proxy({}, {\n  get: (\n    target: FctoryCache,\n    type: string,\n  ): Fctory => {\n    if (target[type]) {\n      return target[type]\n    }\n\n    const typeConverted = (\n      type[0] + type.substring(1)\n        .replace(\n          /([A-Z])/g,\n          capital => '-' + capital,\n        )\n    ).toUpperCase()\n\n    return target[type] = (\n      selector?: string,\n      contents?: NodeContent[] | NodeContent,\n    ): NodeAbstract => {\n      let attributes: NodeAttributes | undefined\n      if (selector) {\n        const [_, _attributes] = selectorToTokenizer(selector)\n        attributes = _attributes\n      }\n      return node(\n        typeConverted,\n        attributes,\n        contents,\n      )\n    }\n  },\n})\n", "import {\n  node as n,\n  NodeAbstract,\n} from '@doars/staark/src/index.js'\nimport {\n  inputField,\n  InputAttributes,\n  InputFieldTypes,\n} from './inputField.js'\n\nexport type InputListItem = {\n  id?: string,\n  label?: string,\n  value: string,\n  search: string, // TODO: Search this as well as the label/value.\n}\n\nexport type InputListOptions = {\n  class?: string,\n  id?: string,\n  legend?: string,\n  multiple?: boolean,\n  name: string,\n\n  selectAllLabel?: string,\n  selected?: string[],\n  selectedChange?: (argument: string[]) => unknown,\n  selectNoneLabel?: string,\n\n  preview: boolean,\n  previewLabel?: string,\n  previewPlaceholder?: string,\n\n  search: boolean | number,\n  searchChange?: (argument: string) => unknown,\n  searchLabel?: string,\n  searchPlaceholder?: string,\n  searchResetLabel?: string,\n  searchValue?: string,\n}\n\n// TODO: If the user has clicked on the input and starts typing, it should automatically enter into the search bar.\n// TODO: The searching should still show all items, just hide the irrelivent ones.\n// TODO: Add a select all or deselect all option.\n\nexport const inputList = (\n  state: Record<string, any>,\n  options: InputListOptions,\n  items: InputListItem[],\n): NodeAbstract => {\n  // Prefill the state.\n  state = Object.assign({\n    query: options.searchValue,\n    selected: options.selected ? [...options.selected] : [],\n  }, state)\n\n  let contents: NodeAbstract[] = []\n\n  // Setup items.\n  const inputOptions: InputAttributes = {\n    appendLabel: true,\n    multiple: options.multiple,\n    name: options.name,\n    type: options.multiple ? InputFieldTypes.checkbox : InputFieldTypes.radio,\n\n    change: (\n      event: Event,\n    ): void => {\n      // Keep the focus on the input element.\n      // @ts-ignore\n      (event as UIEvent).target.focus()\n\n      const target: HTMLInputElement = event.target as HTMLInputElement\n      if (!target.checked) {\n        const index = state.selected.indexOf(target.value)\n        if (index >= 0) {\n          state.selected.splice(index, 1)\n        }\n      } else if (options.multiple) {\n        if (state.selected.indexOf(target.value) < 0) {\n          state.selected.push(target.value)\n        }\n      } else {\n        state.selected = [target.value]\n      }\n\n      if (options.selectedChange) {\n        options.selectedChange([...state.selected])\n      }\n    },\n  }\n  for (let i = 0; i < items.length; i++) {\n    const item: InputListItem = items[i]\n    // Check if item matches query.\n    if (state.query && (\n      (item.label && item.label.indexOf(state.query) < 0) ||\n      item.value.indexOf(state.query) < 0\n    )) {\n      continue\n    }\n\n    const itemOptions: InputAttributes = {\n      ...inputOptions,\n      value: item.value,\n    }\n    if (state.selected.indexOf(item.value) >= 0) {\n      itemOptions.checked = true\n    }\n    if (item.id) {\n      itemOptions.id = item.id\n    }\n    contents.push(\n      ...inputField(\n        itemOptions,\n        item.label ?? item.value, // TODO: When the label is clicked put the focus on the input element.\n      ),\n    )\n  }\n\n  if (options.selectNoneLabel && state.selected.length > 0) {\n    contents.unshift(\n      n('button', {\n        click: (\n        ): void => {\n          state.selected = []\n\n          if (options.selectedChange) {\n            options.selectedChange([...state.selected])\n          }\n        },\n        type: 'button',\n      }, options.selectNoneLabel),\n    )\n  }\n\n  if (options.selectAllLabel && state.selected.length !== items.length) {\n    contents.unshift(\n      n('button', {\n        click: (\n        ): void => {\n          // Create list of all values.\n          const selected: string[] = []\n          for (const item of items) {\n            state.selected.push(item.value)\n          }\n          state.selected = selected\n\n          if (options.selectedChange) {\n            options.selectedChange(selected)\n          }\n        },\n        type: 'button',\n      }, options.selectAllLabel),\n    )\n  }\n\n  // Setup search input.\n  if (options.search && (\n    typeof (options.search) === 'boolean' ||\n    items.length >= options.search\n  )) {\n    if (state.query) {\n      contents.unshift(\n        n('button', {\n          click: (\n            event: Event,\n          ): void => {\n            // Set focus to search field.\n            // @ts-ignore\n            (event as UIEvent).target.previousSibling.focus()\n\n            state.query = null\n\n            if (options.searchChange) {\n              options.searchChange(state.query)\n            }\n          },\n          type: 'button',\n        }, options.searchResetLabel ?? '\u00D7'),\n      )\n    }\n\n    const searchOptions: InputAttributes = {\n      type: InputFieldTypes.search,\n      value: state.query,\n\n      keyup: (\n        event: Event,\n      ): void => {\n        // @ts-ignore.\n        state.query = event.target.value\n\n        if (options.searchChange) {\n          options.searchChange(state.query)\n        }\n      },\n    }\n    if (options.searchPlaceholder) {\n      searchOptions.placeholder = options.searchPlaceholder\n    }\n\n    contents.unshift(\n      ...inputField(searchOptions, options.searchLabel),\n    )\n  }\n\n  contents = [\n    n('div', {}, contents),\n  ]\n\n  if (options.preview) {\n    const previewOptions: InputAttributes = {\n      readonly: true,\n      tabindex: -1,\n      type: InputFieldTypes.text,\n    }\n\n    const labels: string[] = []\n    for (const item of items) {\n      if (state.selected.indexOf(item.value) >= 0) {\n        labels.push(item.label ?? item.value)\n      }\n    }\n    previewOptions.value = labels.join(', ')\n\n    contents.unshift(\n      ...inputField(previewOptions, options.previewLabel),\n    )\n  }\n\n  if (options.legend) {\n    contents.unshift(\n      n('legend', {\n        click: (\n          event: Event,\n        ): void => {\n          // @ts-ignore\n          event.target.parentNode.focus()\n        },\n      }, options.legend),\n    )\n  }\n\n  const fieldAttributes: { [key: string]: any } = {\n    tabindex: 0,\n  }\n  if (options.class) {\n    fieldAttributes.class = options.class\n  }\n  return n('fieldset', fieldAttributes, contents)\n}\n", "import {\n  node as n,\n  NodeContent,\n  NodeAbstract,\n} from '@doars/staark/src/index.js'\n\nexport type RouterOptions = {\n  initial?: string\n  // TODO:\n}\n\n// TODO: Listen to history changes.\n\nexport const router = (\n  routes: Record<string, NodeContent[] | NodeContent>,\n  state: Record<string, any>,\n  options: RouterOptions = {},\n): NodeAbstract => {\n  state = Object.assign({\n    route: options.initial ?? '',\n  }, state)\n\n  // TODO:\n\n  return n('div')\n}\n"],
  "mappings": "6aCAA,IAAMA,EAA0B,KAOnBC,EACXC,GACG,CAEDA,EAAW,UACRA,EAAW,MACX,CAACA,EAAW,KAAK,SAASF,CAAe,IAE5CE,EAAW,MAAQF,EAEvB,EIjBO,IAAMG,EAAS,OAAO,EC2ChBC,EAAO,CAClBC,EACAC,EACAC,MAGE,OAAQD,GAA0B,UAC9BA,EAAsC,IAAMH,GAC7C,MAAM,QAAQG,CAAoB,KAErCC,EAAWD,EACXA,EAAuB,QAGlB,CACL,EAAGH,EACH,EAAGG,EACH,EACEC,EACI,MAAM,QAAQA,CAAQ,EACpBA,EACA,CAACA,CAAQ,EACX,CAAC,EAEP,EAAGF,EAAK,YAAY,CACtB,GEpDK,IAAMG,GAAU,IAAI,MAAM,CAAC,EAAG,CACnC,IAAK,CACHC,EACAC,IACY,CACZ,GAAID,EAAOC,CAAI,EACb,OAAOD,EAAOC,CAAI,EAGpB,IAAMC,GACJD,EAAK,CAAC,EAAIA,EAAK,UAAU,CAAC,EACvB,QACC,WACAE,GAAW,IAAMA,CACnB,GACF,YAAY,EAEd,OAAOH,EAAOC,CAAI,EAAI,CACpBG,EACAC,IACiBC,EACjBJ,EACAE,EACAC,CACF,CACF,CACF,CAAC,EC1CKE,EAAgB,IAChBC,EAAe,IACfC,EAAM,IACNC,EAAQ,IACRC,EAAO,IACPC,EAAe,IACfC,EAAe,IASRC,EACXC,GACkC,CAClC,IAAMC,EAAiBD,EAAS,OAC5BE,EAAY,EAEZhB,EAAe,GACbiB,EAAkC,CAAC,EAErCC,EAAiB,GACjBC,EAAwB,GACxBC,EAAwB,EACtBC,EAAa,IAAM,CACvB,GAAIH,EAAQ,CACV,OAAQE,EAAW,CACjB,IAAK,GACHH,EAAWC,CAAM,EAAIC,IAAW,GAAO,GAAOA,EAC9CA,EAAS,GACT,MAEF,IAAK,GACH,GAAI,CAACF,EAAW,MAAO,CACrBA,EAAW,MAAQC,EACnB,KACF,CACAD,EAAW,OAAS,IAAMC,EAC1B,MAEF,IAAK,GACHD,EAAW,GAAKC,EAChB,MAEF,IAAK,GACHlB,EAAOkB,EACP,KACJ,CACAA,EAAS,EACX,CACF,EAEII,EAEAC,EACEC,EAAiB,IACZ,CAGT,IAFAD,EAAwB,EAEjBP,EAAID,GAAQ,CAGjB,GAFAO,EAAYR,EAASE,CAAC,EACtBA,IACIM,IAAcb,EAAO,CAEvBU,EAAS,GACTG,EAAYR,EAASE,CAAC,EACtB,IAAMS,EAAmBH,IAAcV,EACjCc,EAAmBJ,IAAcX,EAMvC,KALIc,GAAoBC,KACtBP,GAAUG,EACVN,KAGKA,EAAID,GAAQ,CAEjB,GADAO,EAAYR,EAASE,CAAC,EAEnBS,GAAoBH,IAAcV,GAClCc,GAAoBJ,IAAcX,EACnC,CACAQ,GAAUG,EACVN,IACA,KACF,SACE,CAACS,GACD,CAACC,GACDJ,IAAchB,EAEd,MAEFa,GAAUG,EACVN,GACF,CAiBA,KAbIG,EAAO,CAAC,IAAMP,GACdO,EAAOA,EAAO,OAAS,CAAC,IAAMP,GAG9BO,EAAO,CAAC,IAAMR,GACdQ,EAAOA,EAAO,OAAS,CAAC,IAAMR,KAGhCQ,EAASA,EAAO,UAAU,EAAGA,EAAO,OAAS,CAAC,GAKzCH,EAAID,IACTO,EAAYR,EAASE,CAAC,EACtBA,IACIM,IAAchB,IAAlB,CAIF,KACF,SAAWgB,IAAcf,EAAc,CACrCgB,IACA,QACF,SAAWD,IAAchB,EAAe,CAEtC,GADAiB,IACIA,EAAwB,EAC1B,MAEF,QACF,CAEAL,GAAUI,CACZ,CACAD,EAAW,CACb,EAEA,KAAOL,EAAID,GAAQ,CAIjB,GAHAO,EAAYR,EAASE,CAAC,EACtBA,IAEIM,IAAcZ,EAAM,CACtBW,EAAW,EACXD,EAAY,EACZ,QACF,SAAWE,IAAcd,EAAK,CAC5Ba,EAAW,EACXD,EAAY,EACZ,QACF,SAAWE,IAAcf,EAAc,CACrCc,EAAW,EACXD,EAAY,EACZI,EAAe,EACf,QACF,CAEAN,GAAUI,CACZ,CAEA,MAAO,CAACtB,EAAMiB,CAAU,CAC1B,EC1IaU,GAAS,IAAI,MAAM,CAAC,EAAG,CAClC,IAAK,CACH5B,EACAC,IACW,CACX,GAAID,EAAOC,CAAI,EACb,OAAOD,EAAOC,CAAI,EAGpB,IAAMC,GACJD,EAAK,CAAC,EAAIA,EAAK,UAAU,CAAC,EACvB,QACC,WACAE,GAAW,IAAMA,CACnB,GACF,YAAY,EAEd,OAAOH,EAAOC,CAAI,EAAI,CACpBc,EACAV,IACiB,CACjB,IAAIa,EACJ,GAAIH,EAAU,CACZ,GAAM,CAACc,EAAGC,CAAW,EAAIhB,EAAoBC,CAAQ,EACrDG,EAAaY,CACf,CACA,OAAOxB,EACLJ,EACAgB,EACAb,CACF,CACF,CACF,CACF,CAAC,ECrDG0B,EAAkB,EACTC,EAAmB,IACnB,IAAOD,IIOpB,IAAME,EAAkB,0BAEZC,OACVA,EAAA,SAAW,WACXA,EAAA,MAAQ,QACRA,EAAA,KAAO,OACPA,EAAA,cAAgB,iBAChBA,EAAA,MAAQ,QACRA,EAAA,KAAO,OACPA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,SAAW,WACXA,EAAA,MAAQ,QACRA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,IAAM,MACNA,EAAA,KAAO,OACPA,EAAA,KAAO,OACPA,EAAA,IAAM,MACNA,EAAA,KAAO,OAjBGA,OAAA,IAmDCC,EAAa,CACxBC,EACAC,EACAC,IACmB,CACnBF,EAAQ,OAAO,OAAO,CACpB,MAAOC,EAAW,OAAS,EAC7B,EAAGD,CAAK,EAERC,EAAW,OAASA,EAAW,OAAS,IAAMJ,EACzCI,EAAW,OACdA,EAAW,KAAO,QAEpBA,EAAW,MAAQD,EAAM,MACzBG,EAAqBF,CAAU,EAE/B,IAAMG,EAAWH,EAAW,OAC5BA,EAAW,OACTI,GACG,CAGHL,EAAM,MAASK,EAAM,OAA2B,MAC5CD,GACFA,EAASC,CAAK,CAElB,EAEI,OAAQH,GAAW,WACrBA,EAAQ,CACN,MAAOA,CACT,GAIAA,GACG,CAACA,EAAM,SAERD,EAAW,OAAS,YACjBA,EAAW,OAAS,WAGzBC,EAAM,OAAS,IAGjB,IAAMI,EAA2B,CAC/BC,EAAE,QAASN,CAAU,CACvB,EAEA,GAAIC,EAAO,CACJD,EAAW,KACdA,EAAW,GAAK,UAAYO,EAAiB,GAG/C,IAAMC,EAAkC,CACtC,IAAKR,EAAW,EAClB,GAEEA,EAAW,OAAS,YACjBA,EAAW,OAAS,WAEvBQ,EAAgB,SAAW,EAC3BA,EAAgB,MACdJ,GACS,CAENA,EAAM,OACJ,gBACH,MAAM,CACV,GAEF,IAAMK,EAA8BH,EAClC,QACAE,EACAP,EAAM,KACR,EAGEA,GACGA,EAAM,OAETI,EAAS,KAAKI,CAAa,EAE3BJ,EAAS,QAAQI,CAAa,CAElC,CAEA,OAAOJ,CACT,EC7IA,IAAMK,EAAkB,+BAkBXC,GAAY,CACvBC,EACAC,EACAC,IACmB,CACnBF,EAAQ,OAAO,OAAO,CACpB,MAAO,CAAC,CACV,EAAGA,CAAK,EAERC,EAAW,OAASA,EAAW,OAAS,IAAMH,EAC9CG,EAAW,OAAS,GACfA,EAAW,KACdA,EAAW,GAAM,aAAeE,EAAiB,GAEnDF,EAAW,SAAW,GACtBA,EAAW,KAAO,OAClBG,EAAqBH,CAAU,EAqB/B,IAAMI,EAAWJ,EAAW,OAC5B,OAAAA,EAAW,OACTK,GACG,CACHN,EAAM,MAASM,EAAM,OAA4B,MAC7CD,GACFA,EAASC,CAAK,CAElB,EAEO,CACLC,EAAE,QAASN,CAAU,EACrBM,EAAE,QAAS,CACT,IAAKN,EAAW,GAEhB,SACEK,GACG,CACHA,EAAM,eAAe,CACvB,EACA,KACEA,GACG,CAtFX,IAAAE,EAuFQF,EAAM,eAAe,EAErBN,EAAM,OAASQ,EAAAF,EAAoB,eAApB,YAAAE,EAAkC,MAC7CH,GACFA,EAASC,CAAK,CAElB,CACF,EAAGJ,GAAS,EAAE,CAChB,CACF,EChGO,IAAMO,EAAS,OAAO,EC2CtB,IAAMC,EAAO,CAClBC,EACAC,EACAC,MAGE,OAAQD,GAA0B,UAC9BA,EAAsC,IAAME,GAC7C,MAAM,QAAQF,CAAoB,KAErCC,EAAWD,EACXA,EAAuB,QAGlB,CACL,EAAGE,EACH,EAAGF,EACH,EACEC,EACI,MAAM,QAAQA,CAAQ,EACpBA,EACA,CAACA,CAAQ,EACX,CAAC,EAEP,EAAGF,EAAK,YAAY,CACtB,GCpDK,IAAMI,GAAU,IAAI,MAAM,CAAC,EAAG,CACnC,IAAK,CACHC,EACAC,IACY,CACZ,GAAID,EAAOC,CAAI,EACb,OAAOD,EAAOC,CAAI,EAGpB,IAAMC,GACJD,EAAK,CAAC,EAAIA,EAAK,UAAU,CAAC,EACvB,QACC,WACAE,GAAW,IAAMA,CACnB,GACF,YAAY,EAEd,OAAOH,EAAOC,CAAI,EAAI,CACpBG,EACAC,IACiBC,EACjBJ,EACAE,EACAC,CACF,CACF,CACF,CAAC,EC1CD,IAAME,EAAgB,IAChBC,EAAe,IACfC,EAAM,IACNC,EAAQ,IACRC,EAAO,IACPC,EAAe,IACfC,EAAe,IASd,IAAMC,EACXC,GACkC,CAClC,IAAMC,EAAiBD,EAAS,OAC5BE,EAAY,EAEZC,EAAe,GACbC,EAAkC,CAAC,EAErCC,EAAiB,GACjBC,EAAwB,GACxBC,EAAwB,EACtBC,EAAa,IAAM,CACvB,GAAIH,EAAQ,CACV,OAAQE,EAAW,CACjB,IAAK,GACHH,EAAWC,CAAM,EAAIC,IAAW,GAAO,GAAOA,EAC9CA,EAAS,GACT,MAEF,IAAK,GACH,GAAI,CAACF,EAAW,MAAO,CACrBA,EAAW,MAAQC,EACnB,KACF,CACAD,EAAW,OAAS,IAAMC,EAC1B,MAEF,IAAK,GACHD,EAAW,GAAKC,EAChB,MAEF,IAAK,GACHF,EAAOE,EACP,KACJ,CACAA,EAAS,EACX,CACF,EAEII,EAEAC,EACEC,EAAiB,IACZ,CAGT,IAFAD,EAAwB,EAEjBR,EAAID,GAAQ,CAGjB,GAFAQ,EAAYT,EAASE,CAAC,EACtBA,IACIO,IAAcG,EAAO,CAEvBN,EAAS,GACTG,EAAYT,EAASE,CAAC,EACtB,IAAMW,EAAmBJ,IAAcK,EACjCC,EAAmBN,IAAcO,EAMvC,KALIH,GAAoBE,KACtBT,GAAUG,EACVP,KAGKA,EAAID,GAAQ,CAEjB,GADAQ,EAAYT,EAASE,CAAC,EAEnBW,GAAoBJ,IAAcK,GAClCC,GAAoBN,IAAcO,EACnC,CACAV,GAAUG,EACVP,IACA,KACF,SACE,CAACW,GACD,CAACE,GACDN,IAAcQ,EAEd,MAEFX,GAAUG,EACVP,GACF,CAiBA,KAbII,EAAO,CAAC,IAAMQ,GACdR,EAAOA,EAAO,OAAS,CAAC,IAAMQ,GAG9BR,EAAO,CAAC,IAAMU,GACdV,EAAOA,EAAO,OAAS,CAAC,IAAMU,KAGhCV,EAASA,EAAO,UAAU,EAAGA,EAAO,OAAS,CAAC,GAKzCJ,EAAID,IACTQ,EAAYT,EAASE,CAAC,EACtBA,IACIO,IAAcQ,IAAlB,CAIF,KACF,SAAWR,IAAcS,EAAc,CACrCR,IACA,QACF,SAAWD,IAAcQ,EAAe,CAEtC,GADAP,IACIA,EAAwB,EAC1B,MAEF,QACF,CAEAL,GAAUI,CACZ,CACAD,EAAW,CACb,EAEA,KAAON,EAAID,GAAQ,CAIjB,GAHAQ,EAAYT,EAASE,CAAC,EACtBA,IAEIO,IAAcU,EAAM,CACtBX,EAAW,EACXD,EAAY,EACZ,QACF,SAAWE,IAAcW,EAAK,CAC5BZ,EAAW,EACXD,EAAY,EACZ,QACF,SAAWE,IAAcS,EAAc,CACrCV,EAAW,EACXD,EAAY,EACZI,EAAe,EACf,QACF,CAEAN,GAAUI,CACZ,CAEA,MAAO,CAACN,EAAMC,CAAU,CAC1B,EC1IO,IAAMiB,GAAS,IAAI,MAAM,CAAC,EAAG,CAClC,IAAK,CACHC,EACAC,IACW,CACX,GAAID,EAAOC,CAAI,EACb,OAAOD,EAAOC,CAAI,EAGpB,IAAMC,GACJD,EAAK,CAAC,EAAIA,EAAK,UAAU,CAAC,EACvB,QACC,WACAE,GAAW,IAAMA,CACnB,GACF,YAAY,EAEd,OAAOH,EAAOC,CAAI,EAAI,CACpBG,EACAC,IACiB,CACjB,IAAIC,EACJ,GAAIF,EAAU,CACZ,GAAM,CAACG,EAAGC,CAAW,EAAIC,EAAoBL,CAAQ,EACrDE,EAAaE,CACf,CACA,OAAOE,EACLR,EACAI,EACAD,CACF,CACF,CACF,CACF,CAAC,ECRM,IAAMM,GAAY,CACvBC,EACAC,EACAC,IACiB,CAjDnB,IAAAC,EAAAC,EAAAC,EAmDEL,EAAQ,OAAO,OAAO,CACpB,MAAOC,EAAQ,YACf,SAAUA,EAAQ,SAAW,CAAC,GAAGA,EAAQ,QAAQ,EAAI,CAAC,CACxD,EAAGD,CAAK,EAER,IAAIM,EAA2B,CAAC,EAG1BC,EAAgC,CACpC,YAAa,GACb,SAAUN,EAAQ,SAClB,KAAMA,EAAQ,KACd,KAAMA,EAAQ,4BAEd,OACEO,GACS,CAGRA,EAAkB,OAAO,MAAM,EAEhC,IAAMC,EAA2BD,EAAM,OACvC,GAAKC,EAAO,QAKDR,EAAQ,SACbD,EAAM,SAAS,QAAQS,EAAO,KAAK,EAAI,GACzCT,EAAM,SAAS,KAAKS,EAAO,KAAK,EAGlCT,EAAM,SAAW,CAACS,EAAO,KAAK,MAVX,CACnB,IAAMC,EAAQV,EAAM,SAAS,QAAQS,EAAO,KAAK,EAC7CC,GAAS,GACXV,EAAM,SAAS,OAAOU,EAAO,CAAC,CAElC,CAQIT,EAAQ,gBACVA,EAAQ,eAAe,CAAC,GAAGD,EAAM,QAAQ,CAAC,CAE9C,CACF,EACA,QAASW,EAAI,EAAGA,EAAIT,EAAM,OAAQS,IAAK,CACrC,IAAMC,EAAsBV,EAAMS,CAAC,EAEnC,GAAIX,EAAM,QACPY,EAAK,OAASA,EAAK,MAAM,QAAQZ,EAAM,KAAK,EAAI,GACjDY,EAAK,MAAM,QAAQZ,EAAM,KAAK,EAAI,GAElC,SAGF,IAAMa,EAA+BC,EAAAC,EAAA,GAChCR,GADgC,CAEnC,MAAOK,EAAK,KACd,GACIZ,EAAM,SAAS,QAAQY,EAAK,KAAK,GAAK,IACxCC,EAAY,QAAU,IAEpBD,EAAK,KACPC,EAAY,GAAKD,EAAK,IAExBN,EAAS,KACP,GAAGU,EACDH,GACAV,EAAAS,EAAK,QAAL,KAAAT,EAAcS,EAAK,KACrB,CACF,CACF,CAwCA,GAtCIX,EAAQ,iBAAmBD,EAAM,SAAS,OAAS,GACrDM,EAAS,QACPW,EAAE,SAAU,CACV,MAAO,IACI,CACTjB,EAAM,SAAW,CAAC,EAEdC,EAAQ,gBACVA,EAAQ,eAAe,CAAC,GAAGD,EAAM,QAAQ,CAAC,CAE9C,EACA,KAAM,QACR,EAAGC,EAAQ,eAAe,CAC5B,EAGEA,EAAQ,gBAAkBD,EAAM,SAAS,SAAWE,EAAM,QAC5DI,EAAS,QACPW,EAAE,SAAU,CACV,MAAO,IACI,CAET,IAAMC,EAAqB,CAAC,EAC5B,QAAWN,KAAQV,EACjBF,EAAM,SAAS,KAAKY,EAAK,KAAK,EAEhCZ,EAAM,SAAWkB,EAEbjB,EAAQ,gBACVA,EAAQ,eAAeiB,CAAQ,CAEnC,EACA,KAAM,QACR,EAAGjB,EAAQ,cAAc,CAC3B,EAIEA,EAAQ,SACV,OAAQA,EAAQ,QAAY,WAC5BC,EAAM,QAAUD,EAAQ,QACvB,CACGD,EAAM,OACRM,EAAS,QACPW,EAAE,SAAU,CACV,MACET,GACS,CAGRA,EAAkB,OAAO,gBAAgB,MAAM,EAEhDR,EAAM,MAAQ,KAEVC,EAAQ,cACVA,EAAQ,aAAaD,EAAM,KAAK,CAEpC,EACA,KAAM,QACR,GAAGI,EAAAH,EAAQ,mBAAR,KAAAG,EAA4B,MAAG,CACpC,EAGF,IAAMe,EAAiC,CACrC,cACA,MAAOnB,EAAM,MAEb,MACEQ,GACS,CAETR,EAAM,MAAQQ,EAAM,OAAO,MAEvBP,EAAQ,cACVA,EAAQ,aAAaD,EAAM,KAAK,CAEpC,CACF,EACIC,EAAQ,oBACVkB,EAAc,YAAclB,EAAQ,mBAGtCK,EAAS,QACP,GAAGU,EAAWG,EAAelB,EAAQ,WAAW,CAClD,CACF,CAMA,GAJAK,EAAW,CACTW,EAAE,MAAO,CAAC,EAAGX,CAAQ,CACvB,EAEIL,EAAQ,QAAS,CACnB,IAAMmB,EAAkC,CACtC,SAAU,GACV,SAAU,GACV,WACF,EAEMC,EAAmB,CAAC,EAC1B,QAAWT,KAAQV,EACbF,EAAM,SAAS,QAAQY,EAAK,KAAK,GAAK,GACxCS,EAAO,MAAKhB,EAAAO,EAAK,QAAL,KAAAP,EAAcO,EAAK,KAAK,EAGxCQ,EAAe,MAAQC,EAAO,KAAK,IAAI,EAEvCf,EAAS,QACP,GAAGU,EAAWI,EAAgBnB,EAAQ,YAAY,CACpD,CACF,CAEIA,EAAQ,QACVK,EAAS,QACPW,EAAE,SAAU,CACV,MACET,GACS,CAETA,EAAM,OAAO,WAAW,MAAM,CAChC,CACF,EAAGP,EAAQ,MAAM,CACnB,EAGF,IAAMqB,EAA0C,CAC9C,SAAU,CACZ,EACA,OAAIrB,EAAQ,QACVqB,EAAgB,MAAQrB,EAAQ,OAE3BgB,EAAE,WAAYK,EAAiBhB,CAAQ,CAChD,EC7OO,IAAMiB,GAAS,CACpBC,EACAC,EACAC,EAAyB,CAAC,IACT,CAjBnB,IAAAC,EAkBE,OAAAF,EAAQ,OAAO,OAAO,CACpB,OAAOE,EAAAD,EAAQ,UAAR,KAAAC,EAAmB,EAC5B,EAAGF,CAAK,EAIDG,EAAE,KAAK,CAChB",
  "names": ["SUFFIX_MULTIPLE", "suffixNameIfMultiple", "attributes", "marker", "node", "type", "attributesOrContents", "contents", "factory", "target", "type", "typeConverted", "capital", "attributesOrContents", "contents", "node", "BRACKET_CLOSE", "BRACKET_OPEN", "DOT", "EQUAL", "HASH", "QUOTE_SINGLE", "QUOTE_DOUBLE", "selectorToTokenizer", "selector", "length", "i", "attributes", "tokenA", "tokenB", "tokenType", "storeToken", "character", "attributeBracketCount", "parseAttribute", "endOnDoubleQuote", "endOnSingleQuote", "fctory", "_", "_attributes", "identifierCount", "uniqueIdentifier", "COMPONENT_CLASS", "InputFieldTypes", "inputField", "state", "attributes", "label", "suffixNameIfMultiple", "onChange", "event", "contents", "node", "uniqueIdentifier", "labelAttributes", "labelAbstract", "COMPONENT_CLASS", "inputFile", "state", "attributes", "label", "uniqueIdentifier", "suffixNameIfMultiple", "onChange", "event", "node", "_a", "marker", "node", "type", "attributesOrContents", "contents", "marker", "factory", "target", "type", "typeConverted", "capital", "attributesOrContents", "contents", "node", "BRACKET_CLOSE", "BRACKET_OPEN", "DOT", "EQUAL", "HASH", "QUOTE_SINGLE", "QUOTE_DOUBLE", "selectorToTokenizer", "selector", "length", "i", "type", "attributes", "tokenA", "tokenB", "tokenType", "storeToken", "character", "attributeBracketCount", "parseAttribute", "EQUAL", "endOnDoubleQuote", "QUOTE_DOUBLE", "endOnSingleQuote", "QUOTE_SINGLE", "BRACKET_CLOSE", "BRACKET_OPEN", "HASH", "DOT", "fctory", "target", "type", "typeConverted", "capital", "selector", "contents", "attributes", "_", "_attributes", "selectorToTokenizer", "node", "inputList", "state", "options", "items", "_a", "_b", "_c", "contents", "inputOptions", "event", "target", "index", "i", "item", "itemOptions", "__spreadProps", "__spreadValues", "inputField", "node", "selected", "searchOptions", "previewOptions", "labels", "fieldAttributes", "router", "routes", "state", "options", "_a", "node"]
}
