- [Hyperapp compared to staark](#hyperapp-compared-to-staark)
- [Snabbdom compared to staark patch](#snabbdom-compared-to-staark-patch)

# Hyperapp compared to staark

[Hyperapp](https://github.com/jorgebucaran/hyperapp#readme) is a similar library to [staark](https://github.com/doars/staark/tree/main/packages/staark#readme) that offers almost the same functionality with some exceptions. Out of the box it does not have the `factory`, `fctory`, and `nde` function, although these could be added as wrappers. Hyperapp also doesn't handle `class` and `style` attributes the same way, but the biggest difference is in how you as the user make changes to the state. Hyperapp expects you to return a new copy of the state with the mutations made as the return of a listener. This means only listeners can easily mutate the state at the end of the event. staark on the other had allows mutation of any key on the state no matter when, it will then after a change has been made re-render the application. This means staark allows you to comfortably use asynchronous functions such [fetch](https://github.com/doars/staark/tree/main/packages/vroagn#readme) and have it automatically update the interface afterwards. And an added bonus of staark is that if an event does not change the state then no re-rendering will happen.

- **File size** - Compared to Hyperapp using the same build configuration Hyperapp is the same size as the base build of staark which has an equivalent feature set. Both builds have been produced using the same configuration and were compressed before comparing them.
- **Performance** - To give an indication how staark performs I tried writing a simple, probably flawed, benchmark that pushes items onto a list similar to a todo app. It shows a significant performance improvement when compared to HyperApp and causes less calls to the garbage collector when multiple mutations happen because the same event, if this is all bundled in a single mutation staark still takes the edge, but with less significance. See the [benchmarks directory](https://github.com/doars/staark/tree/main/benchmarks) for the code used.

# Snabbdom compared to staark patch

[Snabbdom](https://github.com/snabbdom/snabbdom#readme) is similar library to [staark patch](https://github.com/doars/staark/tree/main/packages/staark-patch#readme) and has many overlapping features. Snabbdom comes with many more, mainly focussed at being the base for your own framework to be build on top, whereas staark patch is only concerned with you brining your own state, since [staark](https://github.com/doars/staark/tree/main/packages/staark#readme) already exists providing a full solution.

- **File size** - Compared to Snabbdom using the same build configuration Snabbdom is four times larger as the base build of staark. This is because there is less of focus on being as adaptable and modular, for instance setting the event listeners is build into staark with no additional module or configuration needed, neither does staark patch currently provide lifecycle hooks. Both builds have been produced using the same configuration and were compressed before comparing them.
- **Performance** - To give an indication how staark performs I tried writing a simple, probably flawed, benchmark that pushes items onto a list similar to a todo app. It shows a slight performance improvement when compared Snabbdom. See the [benchmarks directory](https://github.com/doars/staark/tree/main/benchmarks) for the code used.
